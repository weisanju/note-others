<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">我的笔记库</a></li><li class="chapter-item expanded affix "><li class="part-title">绘图与建模</li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> UML</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="0.绘图与建模_UML/UML.html"><strong aria-hidden="true">1.1.</strong> UML</a></li></ol></li><li class="chapter-item expanded "><a href="1.绘图与建模_MERMAID/index.html"><strong aria-hidden="true">2.</strong> MERMAID</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1.绘图与建模_MERMAID/时序图.html"><strong aria-hidden="true">2.1.</strong> 时序图</a></li><li class="chapter-item expanded "><a href="1.绘图与建模_MERMAID/流程图.html"><strong aria-hidden="true">2.2.</strong> 流程图</a></li><li class="chapter-item expanded "><a href="1.绘图与建模_MERMAID/类图.html"><strong aria-hidden="true">2.3.</strong> 类图</a></li><li class="chapter-item expanded "><a href="1.绘图与建模_MERMAID/语法总览.html"><strong aria-hidden="true">2.4.</strong> 语法总览</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Flowchart</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="2.绘图与建模_Flowchart/flowchart_fun.html"><strong aria-hidden="true">3.1.</strong> flowchart_fun</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> PlantUml</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="3.绘图与建模_PlantUml/plantUML语法.html"><strong aria-hidden="true">4.1.</strong> plantUML语法</a></li></ol></li><li class="chapter-item expanded "><li class="part-title"></li><li class="chapter-item expanded "><a href="4.模板引擎/index.html"><strong aria-hidden="true">5.</strong> 模板引擎</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4.模板引擎/mustache/index.html"><strong aria-hidden="true">5.1.</strong> mustache</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 常用软件</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="5.常用软件/Multipass.html"><strong aria-hidden="true">6.1.</strong> Multipass</a></li><li class="chapter-item expanded "><a href="5.常用软件/Wallabag.html"><strong aria-hidden="true">6.2.</strong> Wallabag</a></li><li class="chapter-item expanded "><a href="5.常用软件/v2rayN代理.html"><strong aria-hidden="true">6.3.</strong> v2rayN代理</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> 生活事宜</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="6.生活事宜/个人清算汇缴.html"><strong aria-hidden="true">7.1.</strong> 个人清算汇缴</a></li></ol></li><li class="chapter-item expanded "><a href="7.思考/index.html"><strong aria-hidden="true">8.</strong> 思考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7.思考/学习总结.html"><strong aria-hidden="true">8.1.</strong> 学习总结</a></li><li class="chapter-item expanded "><a href="7.思考/杂项.html"><strong aria-hidden="true">8.2.</strong> 杂项</a></li><li class="chapter-item expanded "><a href="7.思考/编程技巧.html"><strong aria-hidden="true">8.3.</strong> 编程技巧</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 学习</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="8.学习/概率论与数理统计.html"><strong aria-hidden="true">9.1.</strong> 概率论与数理统计</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> 数据格式</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="9.数据格式/XML.html"><strong aria-hidden="true">10.1.</strong> XML</a></li><li class="chapter-item expanded "><a href="9.数据格式/yaml.html"><strong aria-hidden="true">10.2.</strong> yaml</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Linux</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="10.Linux/CFSBandwidthControl.html"><strong aria-hidden="true">11.1.</strong> CFSBandwidthControl</a></li><li class="chapter-item expanded "><a href="10.Linux/LinuxFor.html"><strong aria-hidden="true">11.2.</strong> LinuxFor</a></li><li class="chapter-item expanded "><a href="10.Linux/LinuxWOL设置.html"><strong aria-hidden="true">11.3.</strong> LinuxWOL设置</a></li><li class="chapter-item expanded "><a href="10.Linux/Linux条件测试.html"><strong aria-hidden="true">11.4.</strong> Linux条件测试</a></li><li class="chapter-item expanded "><a href="10.Linux/Seed.html"><strong aria-hidden="true">11.5.</strong> Seed</a></li><li class="chapter-item expanded "><a href="10.Linux/VIM.html"><strong aria-hidden="true">11.6.</strong> VIM</a></li><li class="chapter-item expanded "><a href="10.Linux/caseIn.html"><strong aria-hidden="true">11.7.</strong> caseIn</a></li><li class="chapter-item expanded "><a href="10.Linux/cgroup.html"><strong aria-hidden="true">11.8.</strong> cgroup</a></li><li class="chapter-item expanded "><a href="10.Linux/curl.html"><strong aria-hidden="true">11.9.</strong> curl</a></li><li class="chapter-item expanded "><a href="10.Linux/dd.html"><strong aria-hidden="true">11.10.</strong> dd</a></li><li class="chapter-item expanded "><a href="10.Linux/diffPatch.html"><strong aria-hidden="true">11.11.</strong> diffPatch</a></li><li class="chapter-item expanded "><a href="10.Linux/find.html"><strong aria-hidden="true">11.12.</strong> find</a></li><li class="chapter-item expanded "><a href="10.Linux/iptables.html"><strong aria-hidden="true">11.13.</strong> iptables</a></li><li class="chapter-item expanded "><a href="10.Linux/jq.html"><strong aria-hidden="true">11.14.</strong> jq</a></li><li class="chapter-item expanded "><a href="10.Linux/lsof.html"><strong aria-hidden="true">11.15.</strong> lsof</a></li><li class="chapter-item expanded "><a href="10.Linux/ps.html"><strong aria-hidden="true">11.16.</strong> ps</a></li><li class="chapter-item expanded "><a href="10.Linux/read.html"><strong aria-hidden="true">11.17.</strong> read</a></li><li class="chapter-item expanded "><a href="10.Linux/scp.html"><strong aria-hidden="true">11.18.</strong> scp</a></li><li class="chapter-item expanded "><a href="10.Linux/select.html"><strong aria-hidden="true">11.19.</strong> select</a></li><li class="chapter-item expanded "><a href="10.Linux/service脚本.html"><strong aria-hidden="true">11.20.</strong> service脚本</a></li><li class="chapter-item expanded "><a href="10.Linux/set.html"><strong aria-hidden="true">11.21.</strong> set</a></li><li class="chapter-item expanded "><a href="10.Linux/shell字符串.html"><strong aria-hidden="true">11.22.</strong> shell字符串</a></li><li class="chapter-item expanded "><a href="10.Linux/shell脚本参数.html"><strong aria-hidden="true">11.23.</strong> shell脚本参数</a></li><li class="chapter-item expanded "><a href="10.Linux/stat.html"><strong aria-hidden="true">11.24.</strong> stat</a></li><li class="chapter-item expanded "><a href="10.Linux/tar.html"><strong aria-hidden="true">11.25.</strong> tar</a></li><li class="chapter-item expanded "><a href="10.Linux/top命令.html"><strong aria-hidden="true">11.26.</strong> top命令</a></li><li class="chapter-item expanded "><a href="10.Linux/uidGidSetUidSetGid.html"><strong aria-hidden="true">11.27.</strong> uidGidSetUidSetGid</a></li><li class="chapter-item expanded "><a href="10.Linux/wsl关闭提示音.html"><strong aria-hidden="true">11.28.</strong> wsl关闭提示音</a></li><li class="chapter-item expanded "><a href="10.Linux/yum本地包依赖.html"><strong aria-hidden="true">11.29.</strong> yum本地包依赖</a></li><li class="chapter-item expanded "><a href="10.Linux/大端与小端.html"><strong aria-hidden="true">11.30.</strong> 大端与小端</a></li><li class="chapter-item expanded "><a href="10.Linux/确定Linux发行版本.html"><strong aria-hidden="true">11.31.</strong> 确定Linux发行版本</a></li><li class="chapter-item expanded "><a href="10.Linux/零拷贝.html"><strong aria-hidden="true">11.32.</strong> 零拷贝</a></li><li class="chapter-item expanded "><a href="10.Linux/默认值语法糖.html"><strong aria-hidden="true">11.33.</strong> 默认值语法糖</a></li></ol></li><li class="chapter-item expanded "><a href="11.algorithm/index.html"><strong aria-hidden="true">12.</strong> algorithm</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11.algorithm/Base64编码.html"><strong aria-hidden="true">12.1.</strong> Base64编码</a></li><li class="chapter-item expanded "><a href="11.algorithm/Huffman编码.html"><strong aria-hidden="true">12.2.</strong> Huffman编码</a></li><li class="chapter-item expanded "><a href="11.algorithm/base64.html"><strong aria-hidden="true">12.3.</strong> base64</a></li><li class="chapter-item expanded "><a href="11.algorithm/fnv-hash算法.html"><strong aria-hidden="true">12.4.</strong> fnv-hash算法</a></li><li class="chapter-item expanded "><a href="11.algorithm/二叉搜索平衡树.html"><strong aria-hidden="true">12.5.</strong> 二叉搜索平衡树</a></li><li class="chapter-item expanded "><a href="11.algorithm/位运算.html"><strong aria-hidden="true">12.6.</strong> 位运算</a></li><li class="chapter-item expanded "><a href="11.algorithm/动态规划.html"><strong aria-hidden="true">12.7.</strong> 动态规划</a></li><li class="chapter-item expanded "><a href="11.algorithm/动态规划-新.html"><strong aria-hidden="true">12.8.</strong> 动态规划-新</a></li><li class="chapter-item expanded "><a href="11.algorithm/字符编码.html"><strong aria-hidden="true">12.9.</strong> 字符编码</a></li><li class="chapter-item expanded "><a href="11.algorithm/布隆过滤器.html"><strong aria-hidden="true">12.10.</strong> 布隆过滤器</a></li><li class="chapter-item expanded "><a href="11.algorithm/浮点数.html"><strong aria-hidden="true">12.11.</strong> 浮点数</a></li><li class="chapter-item expanded "><a href="11.algorithm/红黑树.html"><strong aria-hidden="true">12.12.</strong> 红黑树</a></li><li class="chapter-item expanded "><a href="11.algorithm/贪心算法.html"><strong aria-hidden="true">12.13.</strong> 贪心算法</a></li><li class="chapter-item expanded "><a href="11.algorithm/逆波兰表达式.html"><strong aria-hidden="true">12.14.</strong> 逆波兰表达式</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="我的笔记库"><a class="header" href="#我的笔记库">我的笔记库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><!-- toc -->
<h1 id="umlunifier-modeling-language"><a class="header" href="#umlunifier-modeling-language">UML(unifier modeling language)</a></h1>
<h2 id="uml概述"><a class="header" href="#uml概述">UML概述</a></h2>
<h3 id="什么是uml"><a class="header" href="#什么是uml">什么是UML</a></h3>
<ol>
<li>通过文字符号和可视化的图形符号表达建模设计思路的 一种语言</li>
</ol>
<h3 id="为什么要使用uml"><a class="header" href="#为什么要使用uml">为什么要使用UML</a></h3>
<p>UML为 业务人员,开发人员,测试人员等在系统构建的生命周期内的所有相关人员提供了一个统一的,表达丰富,功能强大的沟通语言</p>
<h3 id="uml的基本构成要素"><a class="header" href="#uml的基本构成要素">UML的基本构成要素</a></h3>
<ol>
<li>事物</li>
<li>关系</li>
<li>图</li>
</ol>
<h3 id="uml图的分类"><a class="header" href="#uml图的分类">UML图的分类</a></h3>
<ol>
<li>分为五大类
<ol>
<li>用例图:
<ol>
<li>在系统抽象过程中,描述需求</li>
</ol>
</li>
<li>静态图:
<ol>
<li>描述系统的类以及类结构</li>
<li>类图:描述系统抽象的 基本单位</li>
<li>对象图:描述系统某时刻,某个类的状态与值</li>
<li>包图:划分类的结构</li>
</ol>
</li>
<li>实现图
<ol>
<li>描述系统的软件架构</li>
<li>组件图:描述系统所依赖的各个组件</li>
<li>部署图:描述系统的软件架构</li>
</ol>
</li>
<li>行为图
<ol>
<li>描述系统的 动态行为</li>
<li>状态图:描述系统状态间的转换</li>
<li>活动图:描述系统的活动以及活动间的约束</li>
</ol>
</li>
<li>交互图
<ol>
<li>描述系统内部对象间的交互</li>
<li>序列图:描述对象间的交互关系,侧重于时间顺序</li>
<li>协作图:描述对象间的交互关系,侧重于对象间的层次关系(例如上下级关系,平级等)</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="用例图"><a class="header" href="#用例图">用例图</a></h2>
<h3 id="什么是用例what"><a class="header" href="#什么是用例what">什么是用例(what)</a></h3>
<p>​	在系统需求分析阶段,描述角色是如何使用系统</p>
<h3 id="为什么要使用用例why"><a class="header" href="#为什么要使用用例why">为什么要使用用例(why)</a></h3>
<p>通过用例我们可以:</p>
<ol>
<li>
<p>用户:确定系统应具有哪些用户</p>
</li>
<li>
<p>功能;确定系统应具有哪些相应的功能</p>
</li>
<li>
<p>开发:让开发人员更深刻的理解业务</p>
</li>
<li>
<p>测试:为后期测试提供测试依据</p>
</li>
<li>
<p>把需求与设计实现分离</p>
</li>
</ol>
<h3 id="用例的使用how"><a class="header" href="#用例的使用how">用例的使用(how)</a></h3>
<ol>
<li>用例图的基本元素构成:4部分
<ol>
<li>参与者:系统的参与者</li>
<li>用例:系统的功能</li>
<li>系统边界:用于将各个划分模块</li>
<li>通信连接:用于表示参与者与 用例之间的关系</li>
</ol>
</li>
<li>用例建立过程
<ol>
<li>如何发现参与者?
<ol>
<li>参与者主要有两类: 
<ol>
<li>所有使用该系统的用户</li>
<li>所有依赖该系统,或者该系统依赖的  外部系统</li>
</ol>
</li>
</ol>
</li>
<li>发现用例
<ol>
<li>依据以上发现参与者 列出参与者所进行的所有操作</li>
<li>不同参与者的 用例可能会重复,可以合并重复的用例</li>
</ol>
</li>
<li>编写用例规约
<ol>
<li>用例规约描述了 用户与用例发生关系的 约束</li>
<li>用例规约模板
<ol>
<li>简要说明: 用例摘要,描述该用例的动作和目的</li>
<li>事件流:基本流与备用流,表示该用例上执行的所有可能发生的动作</li>
<li>用例场景:在特定上下文中, 基本流域备用流的组合</li>
<li>特殊需求: 该用例对 性能,可靠性,容错性,可扩展性等于需求无关的 要求</li>
<li>前置条件:执行该用例系统应所处的状态</li>
<li>后置条件:用例执行后,系统所应处于的状态</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="静态图"><a class="header" href="#静态图">静态图</a></h2>
<p>静态图是用来描述系统内部代码结构</p>
<h3 id="类图与对象图"><a class="header" href="#类图与对象图">类图与对象图</a></h3>
<ol>
<li>类图是系统抽象的基本单位</li>
<li>对象图是类图的实例,是在某个时间点的类的状态与值</li>
<li>类图的表示法:矩形的三部分</li>
<li>对象图的使用场景:用于交互图</li>
</ol>
<h3 id="包图"><a class="header" href="#包图">包图</a></h3>
<ol>
<li>包图是对 系统中的类 划分机构</li>
<li>包图的表示法:小矩形+大矩形</li>
<li>包可以包含子包</li>
<li>包之间可以有依赖关系</li>
</ol>
<h2 id="实现图"><a class="header" href="#实现图">实现图</a></h2>
<p>描述了需求是利用 哪些解决方案实现的</p>
<h3 id="组件图"><a class="header" href="#组件图">组件图</a></h3>
<ol>
<li>
<p>多个包完成某一类功能 一起构成组件,组件图描述了系统内使用的组件以及他们的依赖关系</p>
</li>
<li>
<p>组件包含四类元素</p>
<p>多个包  构成组件 , 多个组件构成程序, 程序完成某个特定任务</p>
</li>
</ol>
<h3 id="部署图"><a class="header" href="#部署图">部署图</a></h3>
<p>描述了该系统 运行的软件结构,和硬件架构</p>
<ol>
<li>部署图包含两种元素:
<ol>
<li>节点</li>
<li>关联关系:一般指 &lt;&lt;通信协议&gt;&gt;</li>
</ol>
</li>
</ol>
<h2 id="行为图"><a class="header" href="#行为图">行为图</a></h2>
<ol>
<li>行为图描述了活动的发生以及在这个过程中状态的转换,主要有活动图,状态图</li>
<li>活动图,状态图的区别
<ol>
<li>活动图描述了活动的流向,不需要事件触发</li>
<li>状态描述了状态的转换,会停留在某个状态,等待事件的发生</li>
</ol>
</li>
</ol>
<h3 id="活动图"><a class="header" href="#活动图">活动图</a></h3>
<ol>
<li>
<p>什么是活动图 </p>
<p>以活动 的角度,描述活动的流向以及状态的转换</p>
</li>
<li>
<p>活动图的基本要素</p>
<ol>
<li>活动
<ol>
<li>原子的</li>
<li>瞬时的</li>
<li>内部四个动作</li>
</ol>
</li>
<li>转换
<ol>
<li>事件名(事件参数)[条件变量]/动作</li>
</ol>
</li>
<li>分支与合并: 活动流向的改变</li>
<li>分叉与会和:活动的并行</li>
<li>泳道:活动 以对象为分类</li>
</ol>
</li>
</ol>
<h3 id="状态图"><a class="header" href="#状态图">状态图</a></h3>
<ol>
<li>
<p>什么是状态图?</p>
<p>以 状态为中心,描述了随着活动的流动,状态的转换</p>
</li>
<li>
<p>状态图的基本要素</p>
<ol>
<li>状态
<ol>
<li>包含四个内部动作</li>
</ol>
</li>
<li>转换
<ol>
<li>五部分信息</li>
<li>四种状态转换</li>
</ol>
</li>
</ol>
</li>
<li>
<p>状态图的绘制</p>
<ol>
<li>初始状态</li>
<li>终止状态</li>
<li>简单状态</li>
<li>子状态,复合状态</li>
<li>历史状态</li>
</ol>
</li>
<li>
<p>状态图的例子</p>
<p><img src="0.%E7%BB%98%E5%9B%BE%E4%B8%8E%E5%BB%BA%E6%A8%A1_UML/..%5Cimages%5Cvisio%5Cjava%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="java线程状态图" /></p>
</li>
</ol>
<h2 id="交互图"><a class="header" href="#交互图">交互图</a></h2>
<p>描述系统内部对象之间的交互,更加精细表达用例</p>
<h3 id="序列图"><a class="header" href="#序列图">序列图</a></h3>
<ol>
<li>
<p>什么是序列图</p>
<p>描述对象间的交互,从时间顺序来描述</p>
</li>
<li>
<p>基本要素</p>
<ol>
<li>对象</li>
<li>生命线</li>
<li>激活</li>
<li>消息
<ol>
<li>消息分类</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="协作图"><a class="header" href="#协作图">协作图</a></h3>
<ol>
<li>
<p>什么是协作图</p>
<p>描述对象间的交互,侧重于对象的层次关系,能更准确的反应 一个对象与哪些对象发生了交互</p>
</li>
<li>
<p>协作图的基本要素</p>
<ol>
<li>对象或者类等静态结构</li>
<li>连接:将静态结构关联在一起,表示有交互</li>
<li>消息:以带序列号的消息与箭头表示,消息交互
<ol>
<li>消息分类</li>
</ol>
</li>
</ol>
</li>
</ol>
<!-- endtoc -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>Mermaid 是一个用于画流程图、状态图、时序图、甘特图的库，使用 JS 进行本地渲染，广泛集成于许多 Markdown 编辑器中。</p>
<p>官网：https://mermaidjs.github.io/</p>
<p>Github 项目地址：https://github.com/knsv/mermaid</p>
<h2 id="mermaid-is-a-diagramming-tool-for-everyone"><a class="header" href="#mermaid-is-a-diagramming-tool-for-everyone">Mermaid is a Diagramming tool for everyone.</a></h2>
<ul>
<li>非编程人员可以 使用在线编辑器， <a href="https://github.com/mermaid-js/mermaid-live-editor">Mermaid Live Editor</a>，访问 教程页 <a href="https://mermaid-js.github.io/mermaid/#/./Tutorials">Tutorials Page</a> </li>
<li>很多 应用也 集成了 <em>mermaid</em>  ，看<a href="https://mermaid-js.github.io/mermaid/#/./integrations">Integrations and Usages for Mermaid</a>.</li>
</ul>
<p>🌐 <a href="https://unpkg.com/mermaid/">CDN</a> | 📖 <a href="https://mermaidjs.github.io/">Documentation</a> | 🙌 <a href="https://github.com/mermaid-js/mermaid/blob/develop/docs/development.md">Contribution</a> | 📜 <a href="https://mermaid-js.github.io/mermaid/#/./CHANGELOG">Version Log</a></p>
<h2 id="可以渲染的图像"><a class="header" href="#可以渲染的图像">可以渲染的图像</a></h2>
<h3 id="简单流程图"><a class="header" href="#简单流程图">简单流程图</a></h3>
<pre><code>graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</code></pre>
<h3 id="时序图"><a class="header" href="#时序图">时序图</a></h3>
<pre><code>sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br/&gt;prevail!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!
</code></pre>
<h3 id="甘特图"><a class="header" href="#甘特图">甘特图</a></h3>
<pre><code>gantt
dateFormat  YYYY-MM-DD
title Adding GANTT diagram to mermaid
excludes weekdays 2014-01-10

section A section
Completed task            :done,    des1, 2014-01-06,2014-01-08
Active task               :active,  des2, 2014-01-09, 3d
Future task               :         des3, after des2, 5d
Future task2               :         des4, after des3, 5d
</code></pre>
<h3 id="类图"><a class="header" href="#类图">类图</a></h3>
<pre><code>classDiagram
Class01 &lt;|-- AveryLongClass : Cool
Class03 *-- Class04
Class05 o-- Class06
Class07 .. Class08
Class09 --&gt; C2 : Where am i?
Class09 --* C3
Class09 --|&gt; Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
Class08 &lt;--&gt; C2: Cool label
</code></pre>
<h3 id="git提交图"><a class="header" href="#git提交图">Git提交图</a></h3>
<pre><code>gitGraph:
options
{
    &quot;nodeSpacing&quot;: 150,
    &quot;nodeRadius&quot;: 10
}
end
commit
branch newbranch
checkout newbranch
commit
commit
checkout master
commit
commit
merge newbranch
</code></pre>
<h3 id="er图"><a class="header" href="#er图">ER图</a></h3>
<pre><code>erDiagram
    CUSTOMER ||--o{ ORDER : places
    ORDER ||--|{ LINE-ITEM : contains
    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses
</code></pre>
<h3 id="用户日志图"><a class="header" href="#用户日志图">用户日志图</a></h3>
<pre><code>journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 5: Me
</code></pre>
<h2 id="安装"><a class="header" href="#安装">安装</a></h2>
<p><code>https://unpkg.com/mermaid@&lt;version&gt;/dist/</code></p>
<p>Latest Version: https://unpkg.com/browse/mermaid@8.8.0/</p>
<h2 id="部署mermaid"><a class="header" href="#部署mermaid">部署Mermaid</a></h2>
<pre><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;mermaid.initialize({startOnLoad:true});&lt;/script&gt;
</code></pre>
<h2 id="兄弟项目"><a class="header" href="#兄弟项目">兄弟项目</a></h2>
<ul>
<li><a href="https://github.com/mermaid-js/mermaid-live-editor">Mermaid Live Editor</a></li>
<li><a href="https://github.com/mermaid-js/mermaid-cli">Mermaid CLI</a></li>
<li><a href="https://github.com/mermaidjs/mermaid-webpack-demo">Mermaid Webpack Demo</a></li>
<li><a href="https://github.com/mermaidjs/mermaid-parcel-demo">Mermaid Parcel Demo</a></li>
</ul>
<p><strong>请求协助</strong></p>
<p>欢迎来共享源代码，我们以后的方向是</p>
<ul>
<li>Adding more types of diagrams like mindmaps, ert diagrams, etc. 更多的类型的图，例如 mindmap</li>
<li>Improving existing diagrams 改进现有的图</li>
</ul>
<h2 id="代码贡献步骤"><a class="header" href="#代码贡献步骤"><strong>代码贡献步骤</strong></a></h2>
<ul>
<li>yarn install</li>
<li>yarn build:watch</li>
<li>yarn lint</li>
<li>yarn test</li>
<li>npm publish</li>
</ul>
<h1 id="使用步骤"><a class="header" href="#使用步骤">使用步骤</a></h1>
<p>有四种方式 使用<em>mermaid</em></p>
<ol>
<li>Using the mermaid <a href="https://mermaid-js.github.io/mermaid-live-editor/">live editor</a>. For some popular video tutorials on the live editor go to <a href="https://mermaid-js.github.io/mermaid/#/./n00b-overview">Overview</a>.</li>
<li>Using one of the many <a href="https://mermaid-js.github.io/mermaid/#/../overview/integrations">mermaid plugins</a>. </li>
<li>Hosting mermaid on a webpage, with an absolute link.</li>
<li>Downloading mermaid and hosting it on your Web Page.</li>
</ol>
<h2 id="在线编辑器"><a class="header" href="#在线编辑器">在线编辑器</a></h2>
<h2 id="mermaid插件"><a class="header" href="#mermaid插件">mermaid插件</a></h2>
<p><strong>This is covered in greater detail in the <a href="https://mermaid-js.github.io/mermaid/#/usage">Usage section</a></strong></p>
<h2 id="浏览器使用"><a class="header" href="#浏览器使用">浏览器使用</a></h2>
<p>a. A reference for fetching the online mermaid renderer, which is written in Javascript.</p>
<p>b. The mermaid code for the diagram we want to create.</p>
<p>c. The <code>mermaid.initialize()</code> call to start the rendering process.</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;body&gt;
  Here is a mermaid diagram:
  &lt;div class=&quot;mermaid&quot;&gt;
    graph TD
    A[Client] --&gt; B[Load Balancer]
    B --&gt; C[Server01]
    B --&gt; D[Server02]
  &lt;/div&gt;
&lt;/body&gt;

&lt;body&gt;
  &lt;script&gt;mermaid.initialize({startOnLoad:true});&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p><strong>相对链接</strong></p>
<pre><code class="language-html">&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div class=&quot;mermaid&quot;&gt;
  graph LR
      A --- B
      B--&gt;C[fa:fa-ban forbidden]
      B--&gt;D(fa:fa-spinner);
  &lt;/div&gt;
  &lt;div class=&quot;mermaid&quot;&gt;
     graph TD
     A[Client] --&gt; B[Load Balancer]
     B --&gt; C[Server1]
     B --&gt; D[Server2]
  &lt;/div&gt;
  &lt;script src=&quot;C:\Users\MyPC\mermaid\dist\mermaid.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;mermaid.initialize({startOnLoad:true});&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequence-diagrams"><a class="header" href="#sequence-diagrams">Sequence diagrams</a></h1>
<p>序列图是一个交互图，它显示了对象间如何相互操作以及以什么顺序进行操作。</p>
<pre><code>sequenceDiagram
    Alice-&gt;&gt;John: Hello John, how are you?
    John--&gt;&gt;Alice: Great!
    Alice-)John: See you later!
</code></pre>
<h2 id="语法"><a class="header" href="#语法">语法</a></h2>
<h3 id="参与者"><a class="header" href="#参与者">参与者</a></h3>
<blockquote>
<p>Participants</p>
</blockquote>
<pre><code>sequenceDiagram
    participant John
    participant Alice
    Alice-&gt;&gt;John: Hello John, how are you?
    John--&gt;&gt;Alice: Great!
</code></pre>
<h2 id="别名"><a class="header" href="#别名">别名</a></h2>
<pre><code>sequenceDiagram
    participant A as Alice
    participant J as John
    A-&gt;&gt;J: Hello John, how are you?
    J-&gt;&gt;A: Great!
</code></pre>
<h2 id="消息"><a class="header" href="#消息">消息</a></h2>
<p>消息可以是实线或虚线显示的两种。</p>
<pre><code>[Actor][Arrow][Actor]:Message text
</code></pre>
<p>主要有以下六种Arrow</p>
<table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>-&gt;</td><td>Solid line without arrow，实线，无箭头</td></tr>
<tr><td>--&gt;</td><td>Dotted line without arrow，虚线，无箭头</td></tr>
<tr><td>-&gt;&gt;</td><td>Solid line with arrowhead，实线，有箭头</td></tr>
<tr><td>--&gt;&gt;</td><td>Dotted line with arrowhead，虚线，有箭头</td></tr>
<tr><td>-x</td><td>Solid line with a cross at the end，实线，有箭头，带叉</td></tr>
<tr><td>--x</td><td>Dotted line with a cross at the end.虚线，有箭头，带叉</td></tr>
<tr><td>-)</td><td>Solid line with an open arrowat the end (async)</td></tr>
<tr><td>--)</td><td>Dotted line with a open arrow at the end (async)</td></tr>
</tbody></table>
<h2 id="activations"><a class="header" href="#activations">Activations</a></h2>
<p>可以激活和停用角色。 （de）激活可以是专门的声明：</p>
<pre><code>sequenceDiagram
    Alice-&gt;&gt;John: Hello John, how are you?
    activate John
    John--&gt;&gt;Alice: Great!
    deactivate John
</code></pre>
<p>还可以通过在消息箭头后添加+/-后缀来表示快捷方式：</p>
<pre><code>sequenceDiagram
    Alice-&gt;&gt;+John: Hello John, how are you?
    John--&gt;&gt;-Alice: Great!
    
    
sequenceDiagram
    Alice-&gt;&gt;+John: Hello John, how are you?
    Alice-&gt;&gt;+John: John, can you hear me?
    John--&gt;&gt;-Alice: Hi Alice, I can hear you!
    John--&gt;&gt;-Alice: I feel great!
</code></pre>
<h2 id="notes"><a class="header" href="#notes">Notes</a></h2>
<p><strong>指定方向的note</strong></p>
<pre><code>sequenceDiagram
    participant John
    Note right of John: Text in note
</code></pre>
<p><strong>也可以创建跨越两个参与者的笔记</strong></p>
<pre><code>sequenceDiagram
    Alice-&gt;John: Hello John, how are you?
    Note over Alice,John: A typical interaction
</code></pre>
<h2 id="循环"><a class="header" href="#循环">循环</a></h2>
<pre><code>loop Loop text
... statements ...
end
</code></pre>
<pre><code>sequenceDiagram
    Alice-&gt;John: Hello John, how are you?
    loop Every minute
        John--&gt;Alice: Great!
    end
</code></pre>
<h2 id="alt"><a class="header" href="#alt">Alt</a></h2>
<pre><code>alt Describing text
... statements ...
else
... statements ...
end

opt Describing text
... statements ...
end
</code></pre>
<pre><code>sequenceDiagram
    Alice-&gt;&gt;Bob: Hello Bob, how are you?
    alt is sick
        Bob-&gt;&gt;Alice: Not so good :(
    else is well
        Bob-&gt;&gt;Alice: Feeling fresh like a daisy
    end
    opt Extra response
        Bob-&gt;&gt;Alice: Thanks for asking
    end
</code></pre>
<h2 id="parallel"><a class="header" href="#parallel">Parallel</a></h2>
<pre><code>par [Action 1]
... statements ...
and [Action 2]
... statements ...
and [Action N]
... statements ...
end
</code></pre>
<h2 id="可选"><a class="header" href="#可选">可选</a></h2>
<pre><code>opt 条件描述
    分支描述语句
end
</code></pre>
<h2 id="background-highlighting"><a class="header" href="#background-highlighting">Background Highlighting</a></h2>
<pre><code>rect rgb(0, 255, 0)
... content ...
end

rect rgba(0, 0, 255, .1)
... content ...
end
</code></pre>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<pre><code>sequenceDiagram
    Alice-&gt;&gt;John: Hello John, how are you?
    %% this is a comment
    John--&gt;&gt;Alice: Great!
</code></pre>
<h2 id="sequencenumbers"><a class="header" href="#sequencenumbers">sequenceNumbers</a></h2>
<p>编号</p>
<pre><code>   &lt;script&gt;
      mermaid.initialize({
        sequence: { showSequenceNumbers: true },
      });
    &lt;/script&gt;
</code></pre>
<pre><code>sequenceDiagram
    autonumber
    Alice-&gt;&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts!
    John--&gt;&gt;Alice: Great!
    John-&gt;&gt;Bob: How about you?
    Bob--&gt;&gt;John: Jolly good!
</code></pre>
<h2 id="styling"><a class="header" href="#styling"><a href="https://mermaid-js.github.io/mermaid/#/sequenceDiagram?id=styling">Styling</a></a></h2>
<h2 id="configuration"><a class="header" href="#configuration"><a href="https://mermaid-js.github.io/mermaid/#/sequenceDiagram?id=configuration">Configuration</a></a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flowcharts"><a class="header" href="#flowcharts">Flowcharts</a></h1>
<h2 id="方向定义"><a class="header" href="#方向定义">方向定义</a></h2>
<p><strong>基本语法</strong></p>
<pre><code>graph 方向描述
    图表中的其他语句...
</code></pre>
<p><strong>方向描述</strong></p>
<table><thead><tr><th>用词</th><th>含义</th></tr></thead><tbody>
<tr><td>TB</td><td>从上到下</td></tr>
<tr><td>BT</td><td>从下到上</td></tr>
<tr><td>RL</td><td>从右到左</td></tr>
<tr><td>LR</td><td>从左到右</td></tr>
</tbody></table>
<h2 id="节点形状"><a class="header" href="#节点形状">节点形状</a></h2>
<p>即流程图中每个文本块，包括开始、结束、处理、判断等。Mermaid 中每个节点都有一个 id，以及节点的文字。</p>
<table><thead><tr><th>表述</th><th>说明</th></tr></thead><tbody>
<tr><td><code>id[文字]</code></td><td>矩形节点</td></tr>
<tr><td><code>id(文字)</code></td><td>圆角矩形</td></tr>
<tr><td><code>id1([This is the text in the box])</code></td><td>体育场</td></tr>
<tr><td><code>id((文字))</code></td><td>圆形节点</td></tr>
<tr><td><code>id&gt;文字]</code></td><td>右向旗帜状，不对称</td></tr>
<tr><td><code>id{文字}</code></td><td>菱形</td></tr>
<tr><td><code>id1[[This is the text in the box]]</code></td><td>子例程形状</td></tr>
<tr><td><code>id1[(Database)]</code></td><td>柱状</td></tr>
<tr><td><code>id1{{This is the text in the box}}</code></td><td>六边形</td></tr>
<tr><td><code>id1[/This is the text in the box/]</code> or <code>id1[\This is the text in the box\]</code></td><td>平行四边形</td></tr>
<tr><td><code>A[/Christmas\] or B[\Go shopping/]</code></td><td>梯形</td></tr>
</tbody></table>
<h2 id="连接线"><a class="header" href="#连接线">连接线</a></h2>
<table><thead><tr><th>格式</th><th>效果</th></tr></thead><tbody>
<tr><td><code>A--&gt;B</code></td><td>实线，箭头，无文字</td></tr>
<tr><td><code>A---B</code></td><td>实线，无箭头，无文字</td></tr>
<tr><td><code>A--文字---B</code>或`A---</td><td>文字</td></tr>
<tr><td><code>A--文字--&gt;B</code>或`A--&gt;</td><td>文字</td></tr>
<tr><td><code>A-.-&gt;B</code></td><td>虚线，箭头，无文字</td></tr>
<tr><td><code>A-.文字.-&gt;B</code></td><td>虚线，箭头，文字</td></tr>
<tr><td><code>A==&gt;B</code></td><td>大箭头，无文字</td></tr>
<tr><td><code>A==文字==&gt;B</code></td><td>大箭头，文字</td></tr>
<tr><td><code>A -- text --&gt; B -- text2 --&gt; C</code></td><td>箭头链</td></tr>
<tr><td><code>a --&gt; b &amp; c--&gt; d</code></td><td>多方向</td></tr>
<tr><td><code>A &amp; B--&gt; C &amp; D</code></td><td>a,b同时都指向 c,d</td></tr>
</tbody></table>
<p><strong>长度，虚实，箭头</strong></p>
<table><thead><tr><th>Length</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody>
<tr><td>Normal</td><td><code>---</code></td><td><code>----</code></td><td><code>-----</code></td></tr>
<tr><td>Normal with arrow</td><td><code>--&gt;</code></td><td><code>---&gt;</code></td><td><code>----&gt;</code></td></tr>
<tr><td>Thick</td><td><code>===</code></td><td><code>====</code></td><td><code>=====</code></td></tr>
<tr><td>Thick with arrow</td><td><code>==&gt;</code></td><td><code>===&gt;</code></td><td><code>====&gt;</code></td></tr>
<tr><td>Dotted</td><td><code>-.-</code></td><td><code>-..-</code></td><td><code>-...-</code></td></tr>
<tr><td>Dotted with arrow</td><td><code>-.-&gt;</code></td><td><code>-..-&gt;</code></td><td><code>-...-&gt;</code></td></tr>
</tbody></table>
<h2 id="文本块"><a class="header" href="#文本块">文本块</a></h2>
<p>使用 双引号 包裹 文本块</p>
<h2 id="使用特殊字符"><a class="header" href="#使用特殊字符">使用特殊字符</a></h2>
<pre><code class="language-mermaid">  graph LR
        A[&quot;A double quote:#quot;&quot;] --&gt;B[&quot;A dec char:#9829;&quot;]
</code></pre>
<h2 id="子图"><a class="header" href="#子图">子图</a></h2>
<p><strong>语法</strong></p>
<pre><code>subgraph title
    graph definition
end
</code></pre>
<p><strong>example</strong></p>
<pre><code>graph TB
    c1--&gt;a2
    subgraph one
    a1--&gt;a2
    end
    subgraph two
    b1--&gt;b2
    end
    subgraph three
    c1--&gt;c2
    end
</code></pre>
<p><strong>指定显示ID</strong></p>
<pre><code>graph TB
    c1--&gt;a2
    subgraph ide1 [one]
    a1--&gt;a2
    end
</code></pre>
<h2 id="flowcharts-1"><a class="header" href="#flowcharts-1">flowcharts</a></h2>
<p>使用graphtype流程图，也可以如下图所示在子图之间设置边线。</p>
<pre><code>flowchart TB
    c1--&gt;a2
    subgraph one
    a1--&gt;a2
    end
    subgraph two
    b1--&gt;b2
    end
    subgraph three
    c1--&gt;c2
    end
    one --&gt; two
    three --&gt; two
    two --&gt; c2
</code></pre>
<h2 id="交互"><a class="header" href="#交互">交互</a></h2>
<p>可以将click事件绑定到节点，单击可能导致JavaScript回调或链接，该链接将在新的浏览器选项卡中打开。
注意：使用securityLevel ='strict'时禁用此功能，而使用securityLevel ='loose'时启用。</p>
<p><strong>语法</strong></p>
<pre><code>click nodeId callback
click nodeId call callback()
</code></pre>
<ul>
<li>nodeId is the id of the node</li>
<li>callback is the name of a javascript function defined on the page displaying the graph, the function will be called with the nodeId as parameter.</li>
</ul>
<pre><code>&lt;body&gt;
  &lt;div class=&quot;mermaid&quot;&gt;
    graph LR;
        A--&gt;B;
        B--&gt;C;
        C--&gt;D;
        click A callback &quot;Tooltip&quot;
        click B &quot;http://www.github.com&quot; &quot;This is a link&quot;
        click C call callback() &quot;Tooltip&quot;
        click D href &quot;http://www.github.com&quot; &quot;This is a link&quot;
  &lt;/div&gt;

  &lt;script&gt;
    var callback = function(){
        alert('A callback was triggered');
    }
    var config = {
        startOnLoad:true,
        flowchart:{
            useMaxWidth:true,
            htmlLabels:true,
            curve:'cardinal',
        },
        securityLevel:'loose',
    };

    mermaid.initialize(config);
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="打开文件页面"><a class="header" href="#打开文件页面">打开文件页面</a></h2>
<pre><code>graph LR
A--&gt;B[新窗口打开当前页面]
    click B &quot;README.md&quot;
</code></pre>
<h2 id="注释-1"><a class="header" href="#注释-1"><strong>注释</strong></a></h2>
<pre><code>graph LR
%% this is a comment A -- text --&gt; B{node}
   A -- text --&gt; B -- text2 --&gt; C
</code></pre>
<p>可以在流程图中输入注释，解析器将忽略它们。
注释必须自己一行，并且必须以%%（双百分号）开头。
注释开始到下一个换行符之后的所有文本都将被视为注释，包括任何流语法</p>
<h2 id="样式"><a class="header" href="#样式">样式</a></h2>
<h3 id="linkstyle"><a class="header" href="#linkstyle">linkStyle</a></h3>
<p>linkStyle 后面的数字表示第几根线，从 0 开始。可以指定颜色和粗细。</p>
<pre><code>graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
    linkStyle 0 stroke:#0ff,stroke-width:2px;
    linkStyle 3 stroke:#ff3,stroke-width:4px;
</code></pre>
<h3 id="结点样式"><a class="header" href="#结点样式">结点样式</a></h3>
<pre><code>graph LR
    id1(Start)--&gt;id2(Stop)
    style id1 fill:#f9f,stroke:#333,stroke-width:4px
    style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5
</code></pre>
<h3 id="样式类"><a class="header" href="#样式类">样式类</a></h3>
<pre><code>    classDef className fill:#f9f,stroke:#333,stroke-width:4px;
    class nodeId1 className;
    class nodeId1,nodeId2 className;
    
    
    graph LR
    A:::someclass --&gt; B
    classDef someclass fill:#f96;
</code></pre>
<h3 id="css样式"><a class="header" href="#css样式">css样式</a></h3>
<pre><code>&lt;style&gt;
    .cssClass &gt; rect{
        fill:#FF0000;
        stroke:#FFFF00;
        stroke-width:4px;
    }
&lt;/style&gt;

graph LR;
    A--&gt;B[AAA&lt;span&gt;BBB&lt;/span&gt;];
    B--&gt;D;
    class A cssClass;
</code></pre>
<h3 id="default-class"><a class="header" href="#default-class">Default class</a></h3>
<p>默认赋给所有图形 </p>
<pre><code>  classDef default fill:#f9f,stroke:#333,stroke-width:4px;
</code></pre>
<h2 id="fontawaresome"><a class="header" href="#fontawaresome">fontawaresome</a></h2>
<pre><code>graph TD
    B[&quot;fa:fa-twitter for peace&quot;]
    B--&gt;C[fa:fa-ban forbidden]
    B--&gt;D(fa:fa-spinner);
    B--&gt;E(A fa:fa-camera-retro perhaps?);
</code></pre>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>可以调整渲染流程图的宽度。</p>
<pre><code>mermaid.flowchartConfig = {
    width: 100%
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="示例"><a class="header" href="#示例">示例</a></h1>
<pre><code class="language-text"> classDiagram
      Animal &lt;|-- Duck
      Animal &lt;|-- Fish
      Animal &lt;|-- Zebra
      Animal : +int age
      Animal : +String gender
      Animal: +isMammal()
      Animal: +mate()
      class Duck{
          +String beakColor
          +swim()
          +quack()
      }
      class Fish{
          -int sizeInFeet
          -canEat()
      }
      class Zebra{
          +bool is_wild
          +run()
      }
</code></pre>
<h1 id="语法-1"><a class="header" href="#语法-1">语法</a></h1>
<h2 id="类"><a class="header" href="#类">类</a></h2>
<p><strong>类的表示</strong></p>
<ol>
<li>类有三个块</li>
<li>顶部的块是 类名，加黑，居中</li>
<li>中间的是 类属性，居左</li>
<li>下面的是类 方法，居左</li>
</ol>
<pre><code>classDiagram
    class BankAccount
    BankAccount : +String owner
    BankAccount : +Bigdecimal balance
    BankAccount : +deposit(amount)
    BankAccount : +withdrawl(amount)
</code></pre>
<p><strong>类的定义</strong></p>
<ol>
<li>使用 <code>class</code> 关键字 定义 类</li>
<li>使用 类的关系 符合 定义两个类 例如 <code>&lt;|--</code></li>
</ol>
<pre><code>classDiagram
    class Animal
    Vehicle &lt;|-- Car
</code></pre>
<h2 id="类成员"><a class="header" href="#类成员">类成员</a></h2>
<p>使用  <code>()</code> 来区分方法和类</p>
<ol>
<li>使用 类名限定 定义类成员</li>
</ol>
<pre><code>class BankAccount
 BankAccount : +String owner
 BankAccount : +BigDecimal balance
 BankAccount : +deposit(amount)
 BankAccount : +withdrawal(amount)
</code></pre>
<ol start="2">
<li>使用 <code>{}</code> 限定</li>
</ol>
<pre><code>classDiagram
class BankAccount{
    +String owner
    +BigDecimal balance
    +deposit(amount)
    +withdrawl(amount)
}
</code></pre>
<h2 id="返回值"><a class="header" href="#返回值">返回值</a></h2>
<pre><code>class BankAccount{
    +String owner
    +BigDecimal balance
    +deposit(amount) bool
    +withdrawl(amount) int
}
</code></pre>
<h2 id="泛型"><a class="header" href="#泛型">泛型</a></h2>
<pre><code>classDiagram
class Square~Shape~{
    int id
    List~int~ position
    setPoints(List~int~ points)
    getPoints() List~int~
}

Square : -List~string~ messages
Square : +setMessages(List~string~ messages)
Square : +getMessages() List~string~
</code></pre>
<h2 id="可见性"><a class="header" href="#可见性">可见性</a></h2>
<ul>
<li><code>+</code> Public</li>
<li><code>-</code> Private</li>
<li><code>#</code> Protected</li>
<li><code>~</code> Package/Internal</li>
</ul>
<h2 id="类之间的关系"><a class="header" href="#类之间的关系">类之间的关系</a></h2>
<p>There are different types of relations defined for classes under UML which are currently supported:</p>
<table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td>&lt;|--</td><td>Inheritance（继承）</td></tr>
<tr><td>*--</td><td>Composition（组合）</td></tr>
<tr><td>o--</td><td>Aggregation（聚合）</td></tr>
<tr><td>--&gt;</td><td>Association（关联）</td></tr>
<tr><td>--</td><td>Link (Solid)（链接）</td></tr>
<tr><td>..&gt;</td><td>Dependency（依赖）</td></tr>
<tr><td>..|&gt;</td><td>Realization（实现）</td></tr>
<tr><td>..</td><td>Link (Dashed)（链接）</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h2 id="甘特图-1"><a class="header" href="#甘特图-1">甘特图</a></h2>
<p><strong>示例1</strong></p>
<pre><code>gantt
section Section
Completed :done,    des1, 2014-01-06,2014-01-08
Active        :active,  des2, 2014-01-07, 3d
Parallel 1   :         des3, after des1, 1d
Parallel 2   :         des4, after des1, 1d
Parallel 3   :         des5, after des3, 1d
Parallel 4   :         des6, after des4, 1d
    
</code></pre>
<p><strong>示例2</strong></p>
<pre><code>​```gantt
    title 项目开发流程
    section 项目确定
        需求分析       :a1, 2016-06-22, 3d
        可行性报告     :after a1, 5d
        概念验证       : 5d
    section 项目实施
        概要设计      :2016-07-05  , 5d
        详细设计      :2016-07-08, 10d
        编码          :2016-07-15, 10d
        测试          :2016-07-22, 5d
    section 发布验收
        发布: 2d
        验收: 3d
​```
</code></pre>
<h2 id="类图-1"><a class="header" href="#类图-1">类图</a></h2>
<pre><code class="language-mermaid">classDiagram
Class01 &lt;|-- AveryLongClass : Cool
&lt;&lt;interface&gt;&gt; Class01
Class09 --&gt; C2 : Where am i?
Class09 --* C3
Class09 --|&gt; Class07
Class07 : equals()
Class07 : Object[] elementData
Class01 : size()
Class01 : int chimp
Class01 : int gorilla
class Class10 {
  &lt;&lt;service&gt;&gt;
  int id
  size()
}
</code></pre>
<h2 id="状态图-1"><a class="header" href="#状态图-1">状态图</a></h2>
<pre><code>stateDiagram
[*] --&gt; Still
Still --&gt; [*]
Still --&gt; Moving
Moving --&gt; Still
Moving --&gt; Crash
Crash --&gt; [*]
</code></pre>
<h2 id="pie图"><a class="header" href="#pie图">PIE图</a></h2>
<pre><code>pie
&quot;Dogs&quot; : 386
&quot;Cats&quot; : 85
&quot;Rats&quot; : 15
</code></pre>
<h2 id="用户日志图-1"><a class="header" href="#用户日志图-1">用户日志图</a></h2>
<pre><code> journey
    title My working day
    section Go to work
      Make tea: 5: Me
      Go upstairs: 3: Me
      Do work: 1: Me, Cat
    section Go home
      Go downstairs: 5: Me
      Sit down: 3: Me
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><pre><code>this app works by typing
 new lines create new nodes
  indentation creates child nodes 
  and any text: before a colon+space creates a label
 [linking] you can link to nodes using their ID in parentheses
  like this: (1)
  lines have a default ID of their line-number
   but you can also supply a custom ID in brackets
    like this: (linking) // use single line comments

/*
or 
multiline 
comments

Have fun! 🎉
*/
</code></pre>
<ul>
<li>每一行代表一个结点</li>
<li>缩进创建一个结点</li>
<li>冒号+空格之前的 为 label</li>
<li>行号就是 默认id</li>
<li>可以自定义ID</li>
<li>如果某一行以 <code>(ID)</code> 开头则 表明上一个结点的指向</li>
</ul>
<pre><code>[linking] you can link to nodes using their ID in parentheses
</code></pre>
<p><a href="https://github.com/tone-row/flowchart-fun">github地址</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="活动图-1"><a class="header" href="#活动图-1">活动图</a></h1>
<h2 id="开始结束"><a class="header" href="#开始结束">开始/结束</a></h2>
<pre><code>start 
statement...
end
</code></pre>
<h2 id="条件语句"><a class="header" href="#条件语句">条件语句</a></h2>
<pre><code>start
if (condition A) then (yes)
  :Text 1;
elseif (condition B) then (yes)
  :Text 2;
  stop
elseif (condition C) then (yes)
  :Text 3;
elseif (condition D) then (yes)
  :Text 4;
else (nothing)
  :Text else;
endif
stop
</code></pre>
<h2 id="循环-1"><a class="header" href="#循环-1">循环</a></h2>
<pre><code>repeat循环
start
repeat
  :read data;
  :generate diagrams;
repeat while (more data?)
stop

while循环
start
while (data available?)
  :read data;
  :generate diagrams;
endwhile
stop
</code></pre>
<h2 id="并行处理"><a class="header" href="#并行处理">并行处理</a></h2>
<pre><code>start

if (multiprocessor?) then (yes)
  fork
    :Treatment 1;
  fork again
    :Treatment 2;
  end fork
else (monoproc)
  :Treatment 1;
  :Treatment 2;
endif
</code></pre>
<h2 id="注释-2"><a class="header" href="#注释-2">注释</a></h2>
<pre><code>start
:foo1;
floating note left: This is a note
:foo2;
note right
  This note is on several
  //lines// and can
  contain &lt;b&gt;HTML&lt;/b&gt;
  ====
  * Calling the method &quot;&quot;foo()&quot;&quot; is prohibited
end note
stop
</code></pre>
<h2 id="箭头样式"><a class="header" href="#箭头样式">箭头样式</a></h2>
<pre><code>:foo1;
-&gt; You can put text on arrows;
if (test) then
  -[#blue]-&gt;
  :foo2;
  -[#green,dashed]-&gt; The text can
  also be on several lines
  and **very** long...;
  :foo3;
else
  -[#black,dotted]-&gt;
  :foo4;
endif
-[#gray,bold]-&gt;
:foo5;
</code></pre>
<h2 id="连接器"><a class="header" href="#连接器">连接器</a></h2>
<pre><code>start
:Some activity;
(A)
detach
(A)
:Other activity;
</code></pre>
<h2 id="组合grouping"><a class="header" href="#组合grouping">组合(<em>Grouping</em>)</a></h2>
<pre><code>start
partition Initialization {
    :read config file;
    :init internal variable;
}
partition Running {
    :wait for user interaction;
    :print information;
}

stop
</code></pre>
<h2 id="泳道swimlanes"><a class="header" href="#泳道swimlanes">泳道(<em>Swimlanes</em>)</a></h2>
<pre><code>可以改变泳道颜色
|Swimlane1|
start
:foo1;
|#AntiqueWhite|Swimlane2|
:foo2;
:foo3;
|Swimlane1|
:foo4;
|Swimlane2|
:foo5;
stop
</code></pre>
<h2 id="分离detach"><a class="header" href="#分离detach">分离(detach)</a></h2>
<pre><code>在fork中分离
:start;
 fork
   :foo1;
   :foo2;
 fork again
   :foo3;
   detach
 endfork
 if (foo4) then
   :foo5;
   detach
 endif
 :foo6;
 detach
 :foo7;
 stop
</code></pre>
<h1 id="类图-2"><a class="header" href="#类图-2">类图</a></h1>
<h2 id="类之间的关系-1"><a class="header" href="#类之间的关系-1">类之间的关系</a></h2>
<table><thead><tr><th><strong>Type</strong></th><th><strong>Symbol</strong></th><th><strong>Drawing</strong></th></tr></thead><tbody>
<tr><td>Extension（扩展）</td><td>`&lt;</td><td>--`</td></tr>
<tr><td>Composition（组合）</td><td><code>*--</code></td><td><img src="https://s.plantuml.com/img/sym03.png" alt="img" /></td></tr>
<tr><td>Aggregation（聚合）</td><td><code>o--</code></td><td><img src="https://s.plantuml.com/img/sym01.png" alt="img" /></td></tr>
</tbody></table>
<h2 id="箭头样式-1"><a class="header" href="#箭头样式-1">箭头样式</a></h2>
<pre><code>[arrow_style]line_style
arrow_style=*|o|#|x|}|+|^
line_style= --|..
</code></pre>
<h2 id="箭头标识"><a class="header" href="#箭头标识">箭头标识</a></h2>
<pre><code>&quot;&quot;:位于 某个类的左右,
: 位于连接线中间
@startuml

Class01 &quot;1&quot; *-- &quot;many&quot; Class02 : contains

Class03 o-- Class04 : aggregation

Class05 --&gt; &quot;1&quot; Class06

@enduml
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="name"><a class="header" href="#name">NAME</a></h2>
<p><code>mustache</code> - Logic-less templates.</p>
<h2 id="synopsis"><a class="header" href="#synopsis">SYNOPSIS</a></h2>
<p>A typical Mustache template:</p>
<pre><code>Hello {{name}}
You have just won {{value}} dollars!
{{#in_ca}}
Well, {{taxed_value}} dollars, after taxes.
{{/in_ca}}
</code></pre>
<p>Given the following hash:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;Chris&quot;,
  &quot;value&quot;: 10000,
  &quot;taxed_value&quot;: 10000 - (10000 * 0.4),
  &quot;in_ca&quot;: true
}
</code></pre>
<p>Will produce the following:</p>
<pre><code>Hello Chris
You have just won 10000 dollars!
Well, 6000.0 dollars, after taxes.
</code></pre>
<h2 id="description"><a class="header" href="#description">DESCRIPTION</a></h2>
<p>Mustache can be used for HTML, config files, source code - anything. It works by expanding tags in a template using values provided in a hash or object.</p>
<p>We call it &quot;logic-less&quot; because there are no if statements, else clauses, or for loops. Instead there are only tags. Some tags are replaced with a value, some nothing, and others a series of values. This document explains the different types of Mustache tags.</p>
<p><em>Mustache</em>可以用于HTML，配置文件，源代码。它通过使用哈希或对象中提供的值扩展模板中的标记来工作。
我们称其为 “无逻辑”，因为没有if语句，else子句或for循环。相反，只有标签。有些标签被替换为一个值，有些什么都没有，而另一些则是一系列值。本文档解释了不同类型的<em>Mustache</em>标签。</p>
<h2 id="tag-types"><a class="header" href="#tag-types">TAG TYPES</a></h2>
<p>标签由 <em>double-mustaches</em> 表示。{{person}} 是一个标签，和 {{# person}} 一样。在这两个示例中，我们都将person称为键或标签键。让我们谈谈不同类型的标签。</p>
<h3 id="variables"><a class="header" href="#variables">Variables</a></h3>
<p>最基本的标签类型是变量。一个基本模板中的<code> {{name}}</code> 标签会尝试在当前上下文中找到name键。如果没有名称键，则将递归检查父上下文。如果到达顶部上下文并且仍然找不到名称键，则不会呈现任何内容。</p>
<p>默认情况下，所有变量都是HTML转义的。如果要返回未转义的HTML，请使用三重胡子 :<code>{{{ name }}}</code>。</p>
<p>可以使用 &amp;  反转义 一个变量 <code>{{&amp; name}}</code>。这在更改分隔符时可能很有用 (请参阅下面的 “设置分隔符”)。</p>
<p>默认情况下，变量 <em>miss</em> 返回一个空字符串。这通常可以在你的小胡子库中配置。例如，Ruby版本的Mustache支持在这种情况下引发异常。</p>
<p>Template:</p>
<pre><code>* {{name}}
* {{age}}
* {{company}}
* {{{company}}}
</code></pre>
<p>Hash:</p>
<pre><code>{
  &quot;name&quot;: &quot;Chris&quot;,
  &quot;company&quot;: &quot;&lt;b&gt;GitHub&lt;/b&gt;&quot;
}
</code></pre>
<p>Output:</p>
<pre><code>* Chris
*
* &amp;lt;b&amp;gt;GitHub&amp;lt;/b&amp;gt;
* &lt;b&gt;GitHub&lt;/b&gt;
</code></pre>
<h3 id="sections"><a class="header" href="#sections">Sections</a></h3>
<p>Sections render blocks of text one or more times, depending on the value of the key in the current context.</p>
<p>A section begins with a pound and ends with a slash. That is, <code>{{#person}}</code> begins a &quot;person&quot; section while <code>{{/person}}</code> ends it.</p>
<p>The behavior of the section is determined by the value of the key.</p>
<p><strong>False Values or Empty Lists</strong></p>
<p>If the <code>person</code> key exists and has a value of false or an empty list, the HTML between the pound and slash will not be displayed.</p>
<p>Template:</p>
<pre><code>Shown.
{{#person}}
  Never shown!
{{/person}}
</code></pre>
<p>Hash:</p>
<pre><code>{
  &quot;person&quot;: false
}
</code></pre>
<p>Output:</p>
<pre><code>Shown.
</code></pre>
<p><strong>Non-Empty Lists</strong></p>
<p>If the <code>person</code> key exists and has a non-false value, the HTML between the pound and slash will be rendered and displayed one or more times.</p>
<p>When the value is a non-empty list, the text in the block will be displayed once for each item in the list. The context of the block will be set to the current item for each iteration. In this way we can loop over collections.</p>
<p>Template:</p>
<pre><code>{{#repo}}
  &lt;b&gt;{{name}}&lt;/b&gt;
{{/repo}}
</code></pre>
<p>Hash:</p>
<pre><code>{
  &quot;repo&quot;: [
    { &quot;name&quot;: &quot;resque&quot; },
    { &quot;name&quot;: &quot;hub&quot; },
    { &quot;name&quot;: &quot;rip&quot; }
  ]
}
</code></pre>
<p>Output:</p>
<pre><code>&lt;b&gt;resque&lt;/b&gt;
&lt;b&gt;hub&lt;/b&gt;
&lt;b&gt;rip&lt;/b&gt;
</code></pre>
<p><strong>Lambdas</strong></p>
<p>When the value is a callable object, such as a function or lambda, the object will be invoked and passed the block of text. The text passed is the literal block, unrendered. <code>{{tags}}</code> will not have been expanded - the lambda should do that on its own. In this way you can implement filters or caching.</p>
<p>Template:</p>
<pre><code>{{#wrapped}}
  {{name}} is awesome.
{{/wrapped}}
</code></pre>
<p>Hash:</p>
<pre><code>{
  &quot;name&quot;: &quot;Willy&quot;,
  &quot;wrapped&quot;: function() {
    return function(text, render) {
      return &quot;&lt;b&gt;&quot; + render(text) + &quot;&lt;/b&gt;&quot;
    }
  }
}
</code></pre>
<p>Output:</p>
<pre><code>&lt;b&gt;Willy is awesome.&lt;/b&gt;
</code></pre>
<p><strong>Non-False Values</strong></p>
<p>When the value is non-false but not a list, it will be used as the context for a single rendering of the block.</p>
<p>Template:</p>
<pre><code>{{#person?}}
  Hi {{name}}!
{{/person?}}
</code></pre>
<p>Hash:</p>
<pre><code>{
  &quot;person?&quot;: { &quot;name&quot;: &quot;Jon&quot; }
}
</code></pre>
<p>Output:</p>
<pre><code>Hi Jon!
</code></pre>
<h3 id="inverted-sections"><a class="header" href="#inverted-sections">Inverted Sections</a></h3>
<p>An inverted section begins with a caret (hat) and ends with a slash. That is <code>{{^person}}</code> begins a &quot;person&quot; inverted section while <code>{{/person}}</code> ends it.</p>
<p>While sections can be used to render text one or more times based on the value of the key, inverted sections may render text once based on the inverse value of the key. That is, they will be rendered if the key doesn't exist, is false, or is an empty list.</p>
<p>Template:</p>
<pre><code>{{#repo}}
  &lt;b&gt;{{name}}&lt;/b&gt;
{{/repo}}
{{^repo}}
  No repos :(
{{/repo}}
</code></pre>
<p>Hash:</p>
<pre><code>{
  &quot;repo&quot;: []
}
</code></pre>
<p>Output:</p>
<pre><code>No repos :(
</code></pre>
<h3 id="comments"><a class="header" href="#comments">Comments</a></h3>
<p>Comments begin with a bang and are ignored. The following template:</p>
<pre><code>&lt;h1&gt;Today{{! ignore me }}.&lt;/h1&gt;
</code></pre>
<p>Will render as follows:</p>
<pre><code>&lt;h1&gt;Today.&lt;/h1&gt;
</code></pre>
<p>Comments may contain newlines.</p>
<h3 id="partials"><a class="header" href="#partials">Partials</a></h3>
<p>Partials begin with a greater than sign, like <code>{{&gt; box}}</code>.</p>
<p>Partials are rendered at runtime (as opposed to compile time), so recursive partials are possible. Just avoid infinite loops.</p>
<p>They also inherit the calling context. Whereas in an <a href="http://en.wikipedia.org/wiki/ERuby">ERB</a> file you may have this:</p>
<pre><code>&lt;%= partial :next_more, :start =&gt; start, :size =&gt; size %&gt;
</code></pre>
<p>Mustache requires only this:</p>
<pre><code>{{&gt; next_more}}
</code></pre>
<p>Why? Because the <code>next_more.mustache</code> file will inherit the <code>size</code> and <code>start</code> methods from the calling context.</p>
<p>In this way you may want to think of partials as includes, imports, template expansion, nested templates, or subtemplates, even though those aren't literally the case here.</p>
<p>For example, this template and partial:</p>
<pre><code>base.mustache:
&lt;h2&gt;Names&lt;/h2&gt;
{{#names}}
  {{&gt; user}}
{{/names}}

user.mustache:
&lt;strong&gt;{{name}}&lt;/strong&gt;
</code></pre>
<p>Can be thought of as a single, expanded template:</p>
<pre><code>&lt;h2&gt;Names&lt;/h2&gt;
{{#names}}
  &lt;strong&gt;{{name}}&lt;/strong&gt;
{{/names}}
</code></pre>
<h3 id="set-delimiter"><a class="header" href="#set-delimiter">Set Delimiter</a></h3>
<p>Set Delimiter tags start with an equal sign and change the tag delimiters from <code>{{</code> and <code>}}</code> to custom strings.</p>
<p>Consider the following contrived example:</p>
<pre><code>* {{default_tags}}
{{=&lt;% %&gt;=}}
* &lt;% erb_style_tags %&gt;
&lt;%={{ }}=%&gt;
* {{ default_tags_again }}
</code></pre>
<p>Here we have a list with three items. The first item uses the default tag style, the second uses erb style as defined by the Set Delimiter tag, and the third returns to the default style after yet another Set Delimiter declaration.</p>
<p>According to <a href="http://google-ctemplate.googlecode.com/svn/trunk/doc/howto.html">ctemplates</a>, this &quot;is useful for languages like TeX, where double-braces may occur in the text and are awkward to use for markup.&quot;</p>
<p>Custom delimiters may not contain whitespace or the equals sign.</p>
<h2 id="see-also"><a class="header" href="#see-also">SEE ALSO</a></h2>
<p><a href="http://mustache.github.io/mustache.1.ron.html">mustache(1)</a>, http://mustache.github.io/</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="github首页"><a class="header" href="#github首页">GitHub首页</a></h2>
<p>https://github.com/canonical/multipass/</p>
<h2 id="find-available-images"><a class="header" href="#find-available-images">Find available images</a></h2>
<pre><code>$ multipass find
Image                       Aliases           Version          Description
core                        core16            20200213         Ubuntu Core 16
core18                                        20200210         Ubuntu Core 18
16.04                       xenial            20200721         Ubuntu 16.04 LTS
18.04                       bionic,lts        20200717         Ubuntu 18.04 LTS
20.04                       focal             20200720         Ubuntu 20.04 LTS
daily:20.10                 devel,groovy      20200721         Ubuntu 20.10
</code></pre>
<h2 id="launch-a-fresh-instance-of-the-current-ubuntu-lts"><a class="header" href="#launch-a-fresh-instance-of-the-current-ubuntu-lts">Launch a fresh instance of the current Ubuntu LTS</a></h2>
<pre><code>$ multipass launch ubuntu
Launching dancing-chipmunk...
Downloading Ubuntu 18.04 LTS..........
Launched: dancing chipmunk
</code></pre>
<h3 id="指定cpu内存磁盘"><a class="header" href="#指定cpu内存磁盘">指定CPU内存磁盘</a></h3>
<pre><code class="language-shell">$ multipass launch --name myVM --mem 2G --disk 10G --cpus 2 impish
</code></pre>
<h1 id="how-to-share-data-with-an-instance"><a class="header" href="#how-to-share-data-with-an-instance">How to share data with an instance</a></h1>
<pre><code class="language-nohighlight">$ multipass mount $HOME keen-yak
$ multipass info keen-yak
…
Mounts:         /home/michal =&gt; /home/ubuntu
</code></pre>
<p>从这一点开始，/home/ubuntu将在实例内部可用。使用umount再次卸载它，您可以通过在实例名称后传递指定的目标来更改目标:</p>
<pre><code class="language-nohighlight">$ multipass umount keen-yak
$ multipass mount $HOME keen-yak:/some/path
$ multipass info keen-yak                
…
Mounts:         /home/michal =&gt; /some/path
</code></pre>
<h2 id="传输文件"><a class="header" href="#传输文件">传输文件</a></h2>
<pre><code class="language-nohighlight">$ multipass transfer keen-yak:/etc/crontab keen-yak:/etc/fstab /home/michal
$ ls -l /home/michal/crontab /home/michal/fstab
-rw-r--r-- 1 ubuntu ubuntu 722 Oct 18 12:13 /home/michal/crontab
-rw-r--r-- 1 ubuntu ubuntu  82 Oct 18 12:13 /home/michal/fstab
$ multipass transfer /home/michal/crontab /home/michal/fstab keen-yak:
$ multipass exec keen-yak -- ls -l crontab fstab
-rw-rw-r-- 1 multipass multipass 722 Oct 18 12:14 crontab
-rw-rw-r-- 1 multipass multipass  82 Oct 18 12:14 fstab
</code></pre>
<h2 id="check-out-the-running-instances"><a class="header" href="#check-out-the-running-instances">Check out the running instances</a></h2>
<pre><code>$ multipass list
Name                    State             IPv4             Release
dancing-chipmunk        RUNNING           10.125.174.247   Ubuntu 18.04 LTS
live-naiad              RUNNING           10.125.174.243   Ubuntu 18.04 LTS
snapcraft-asciinema     STOPPED           --               Ubuntu Snapcraft builder for Core 18
</code></pre>
<h2 id="learn-more-about-the-vm-instance-you-just-launched"><a class="header" href="#learn-more-about-the-vm-instance-you-just-launched">Learn more about the VM instance you just launched</a></h2>
<pre><code>$ multipass info dancing-chipmunk
Name:           dancing-chipmunk
State:          RUNNING
IPv4:           10.125.174.247
Release:        Ubuntu 18.04.1 LTS
Image hash:     19e9853d8267 (Ubuntu 18.04 LTS)
Load:           0.97 0.30 0.10
Disk usage:     1.1G out of 4.7G
Memory usage:   85.1M out of 985.4M
</code></pre>
<h2 id="connect-to-a-running-instance"><a class="header" href="#connect-to-a-running-instance">Connect to a running instance</a></h2>
<pre><code> multipass shell dancing-chipmunk
</code></pre>
<h2 id="run-commands-inside-an-instance-from-outside"><a class="header" href="#run-commands-inside-an-instance-from-outside">Run commands inside an instance from outside</a></h2>
<pre><code>$ multipass exec dancing-chipmunk -- lsb_release -a
No LSB modules are available.
Distributor ID:  Ubuntu
Description:     Ubuntu 18.04.1 LTS
Release:         18.04
Codename:        bionic
</code></pre>
<h2 id="stop-an-instance-to-save-resources"><a class="header" href="#stop-an-instance-to-save-resources">Stop an instance to save resources</a></h2>
<pre><code>$ multipass stop dancing-chipmunk
</code></pre>
<h2 id="delete-the-instance"><a class="header" href="#delete-the-instance">Delete the instance</a></h2>
<pre><code>$ multipass delete dancing-chipmunk
</code></pre>
<p>And when you want to completely get rid of it:</p>
<pre><code>$ multipass purge
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="启动命令"><a class="header" href="#启动命令">启动命令</a></h3>
<pre><code>sudo docker run -v /home/lighthouse/wallabag/data:/var/www/wallabag/data  -v /home/lighthouse/wallabag/images:/var/www/wallabag/web/assets/images -p 80:80  -e &quot;SYMFONY__ENV__DOMAIN_NAME=http://IP&quot; wallabag/wallabag
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><a href="https://github.com/2dust/v2rayN/releases">GITHUB</a></p>
<h2 id="geo文件"><a class="header" href="#geo文件">Geo文件</a></h2>
<pre><code>Geo文件即路由规则文件：

&quot;geosite.dat&quot;：提供一个预定义好的 「全球域名」 列表;  

&quot;geoip.dat&quot; ：提供一个预定义好的 「全球 ip-地区」 列表.
</code></pre>
<pre><code>.dat文件里面有无数个分类，比如,中国的域名和IP都在 geosite:cn 和 geoip:cn*

gfwlist的网址(也就是经典的PAC)在 geosite:gfw | [点击跳转](https://youtu.be/jjpBvUYotDc)

广告域名在 geosite:category-ads-all
国外域名在 geosite:geolocation-!cn
本地IP在 geoip:private里;
还有一千多种分类细分，比如 geosite:steam geosite:google 等，
</code></pre>
<p><strong>路由规则输入的格式</strong></p>
<pre><code>domian:jamesdailylife.com
</code></pre>
<p><strong>相关域名和IP分类名的解释</strong></p>
<pre><code>category-ads：包含了常见的广告域名。
category-ads-all：包含了常见的广告域名，以及广告提供商的域名。
cn：相当于 geolocation-cn 和 tld-cn 的合集。
apple：包含了 Apple 旗下绝大部分域名。
google：包含了 Google 旗下绝大部分域名。
microsoft：包含了 Microsoft 旗下绝大部分域名。
facebook：包含了 Facebook 旗下绝大部分域名。
twitter：包含了 Twitter 旗下绝大部分域名。
telegram：包含了 Telegram 旗下绝大部分域名。
geolocation-cn：包含了常见的大陆站点域名。
geolocation-!cn：包含了常见的非大陆站点域名，同时包含了 tld-!cn。
tld-cn：包含了 CNNIC 管理的用于中国大陆的顶级域名，如以 .cn、.中国 结尾的域名。
tld-!cn：包含了非中国大陆使用的顶级域名，如以 .hk（香港）、.tw（台湾）、.jp（日本）、.sg（新加坡）、.us（美国）.ca（加拿大）等结尾的域名。

category-games： 包含了 steam、ea、blizzard、epicgames 和 nintendo 等常见的游戏厂商。
更多域名类别，请查看 data 目录 。
</code></pre>
<p><strong>OutBoundTag</strong></p>
<ul>
<li><em>proxy</em>: 代理</li>
<li><em>direct</em>：直连</li>
<li><em>block</em>: 阻止</li>
</ul>
<h4 id="越靠前的规则优先级越高"><a class="header" href="#越靠前的规则优先级越高">越靠前的规则，优先级越高</a></h4>
<p><strong>路由规则集范本</strong></p>
<p><strong>白名单范例</strong>：https://raw.githubusercontent.com/2dust/v2rayCustomRoutingList/master/custom_routing_rules_whitelist</p>
<p><strong>黑名单范例</strong>：https://raw.githubusercontent.com/2dust/v2rayCustomRoutingList/master/custom_routing_rules_blacklist</p>
<p><a href="https://xtrojan.cc/client/new-v2rayn-c-4-12.html">参考链接-1</a></p>
<p><a href="https://www.v2fly.org/config/overview.html">官方文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应纳税所得额计算公式"><a class="header" href="#应纳税所得额计算公式">应纳税所得额计算公式</a></h1>
<p>$$
应纳税所得额 = 综合所得额 - 免征 - 扣除\
综合所得税 =  工资 + 劳务*80% + 稿酬 * 80% <em>70% + 特许</em>80%\
免征 = 60000元/年\
$$</p>
<h1 id="扣除项"><a class="header" href="#扣除项">扣除项</a></h1>
<ul>
<li>专项：三险一金</li>
<li>附加：
<ul>
<li>子女教育（1.2W/年）</li>
<li>继续教育（4800/年，3600/年）</li>
<li>大病医疗（  0&lt;医疗费用-1.5w&lt; 8w）的部分</li>
<li>房贷（1.2w/年，只能首套房贷）</li>
<li>房租（大城市：1.8w/年，中城市：1.32w/年，小城市：9600/年）</li>
<li>赡养老人（独生子女2.4w/年，非独生子女最多1w2/年）</li>
</ul>
</li>
</ul>
<h1 id="应纳税所得额纳税区间"><a class="header" href="#应纳税所得额纳税区间">应纳税所得额纳税区间</a></h1>
<table><thead><tr><th>级数</th><th>累计预扣缴应纳税所得额</th><th>预扣税（%）</th><th>速算扣除数</th></tr></thead><tbody>
<tr><td>1</td><td>&lt; 3.6w</td><td>3</td><td>0</td></tr>
<tr><td>2</td><td>3.6w&lt;   &lt; 14.4w</td><td>10</td><td>3.6*(10-3)%=2520</td></tr>
<tr><td>3</td><td>14.4w &lt; &lt; 30W</td><td>20</td><td>16920</td></tr>
<tr><td>4</td><td>30w &lt; &lt;42w</td><td>25</td><td>31920</td></tr>
<tr><td>5</td><td>42w &lt; &lt; 66w</td><td>30</td><td>52920</td></tr>
<tr><td>6</td><td>66w &lt; &lt; 96w</td><td>35</td><td>85920</td></tr>
<tr><td>7</td><td>&gt; 96w</td><td>45</td><td>181920</td></tr>
</tbody></table>
<h1 id="汇算清缴"><a class="header" href="#汇算清缴">汇算清缴</a></h1>
<ul>
<li>
<p>原因</p>
<ul>
<li>目前按月 预扣，预扣的标准是 每月工资*12 然后选定区间 算税率，但可能每个月工资不是固定的所以 年总工资 可能落在的区间 与每月的不太一致，故需要清缴</li>
</ul>
</li>
<li>
<p>示例</p>
<ul>
<li>张三，1~6个月 1w的工资，6~12个月跳槽，2w工资
$$
上一家公司交税 = ((12w-6w)<em>10%- 2520)/2 = 1740\
新公司交税 = ((2w</em>12-6w)*20% - 16920)/2 = 9540\
实际总交税 = 1740 + 9540 = 11280\
应交税 = (6w+12w - 6w) * 10% - 2520 = 9480\
可以退换税款 = 11280 - 9480
$$</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><strong>在项目开发中的一些思考</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="碎片化任务"><a class="header" href="#碎片化任务">碎片化任务</a></h1>
<ol>
<li>所有的任务 都要有一个目标,要达到某个特定的目标</li>
<li>如果短时间 就能结束的任务 立马去做</li>
<li>如果长时间 的任务, 分步骤 去完成</li>
</ol>
<h1 id="一定要总结"><a class="header" href="#一定要总结">一定要总结</a></h1>
<ul>
<li>无论是 工作还是 学习 一定要总结</li>
</ul>
<h1 id="实践与理论结合"><a class="header" href="#实践与理论结合">实践与理论结合</a></h1>
<p>在接触新事务时 先 使用 后 了解原理</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert调试"><a class="header" href="#assert调试">Assert调试</a></h1>
<p>支持assert需要在运行时开启该功能,java  -ea 表示开启-da 表示关闭 全称是-enableassertions和-disenableassertions 在开发调试时开启在发布时关闭</p>
<p>assert有助于帮助开发者找到程序错误状态提高程序健壮性,当不应成为程序正常运行逻辑的一部分.</p>
<pre><code>try {
    throw  new RuntimeException(&quot;多少度电&quot;);
} catch (RuntimeException e) {
    assert false : &quot;Exception raised while reading logging configuration: &quot;+e;
}
</code></pre>
<h1 id="io流体系"><a class="header" href="#io流体系"><strong>IO流体系</strong></a></h1>
<table><thead><tr><th>分类</th><th>字节输入流</th><th>字节输出流</th><th>字符输入流</th><th>字符输出流</th></tr></thead><tbody>
<tr><td>抽象基类</td><td>InputStream</td><td>OutputStream</td><td>Reader</td><td>Writer</td></tr>
<tr><td>访问文件</td><td>FileInputStream</td><td>FileOutputStream</td><td>FileReader</td><td>FIleWriter</td></tr>
<tr><td>访问数组</td><td>ByteArrayInputStream</td><td>ByteArrayOutputStream</td><td>CharArrayReader</td><td>CharArrayWriter</td></tr>
<tr><td>访问管道</td><td>PipedInputStream</td><td>PipedOutputStream</td><td>PipedReader</td><td>PipedReader</td></tr>
<tr><td>访问字符串</td><td></td><td></td><td>StringReader</td><td>StringWriter</td></tr>
<tr><td>缓冲流</td><td>BufferedInputStream</td><td>BufferOutputStream</td><td>BufferedReader</td><td>BufferedWriter</td></tr>
<tr><td>转换流</td><td></td><td></td><td>InputStreamReader</td><td>OutputStreamWriter</td></tr>
<tr><td>对象流</td><td>ObjectInputStream</td><td>ObjectOutputStream</td><td></td><td></td></tr>
<tr><td></td><td>FilterInputStream</td><td>FilterOutputStream</td><td>FilterReader</td><td>FilterWriter</td></tr>
<tr><td>打印流</td><td></td><td>PrintStream</td><td></td><td>PrintWriter</td></tr>
<tr><td>推回输入流</td><td>PushbackInputStream</td><td></td><td>PushbackReader</td><td></td></tr>
<tr><td>特殊流</td><td>DataInputStream</td><td>DataOutputStream</td><td></td><td></td></tr>
</tbody></table>
<h1 id="性能优化指标"><a class="header" href="#性能优化指标">性能优化指标</a></h1>
<p>系统吞吐量指的是系统的抗压、负载能力，代表一个系统每秒钟能承受的最大用户访问量。</p>
<p><strong>QPS</strong></p>
<p>Queries Per Second，每秒查询数,简单理解可以认为查询=请求request。</p>
<p><strong>TPS</strong></p>
<p>Transactions Per Second 的缩写，每秒处理的事务数</p>
<p>针对单接口而言，TPS可以认为是等价于QPS的，比如访问一个页面/index.html，是一个TPS，而访问/index.html页面可能请求了3次服务器比如css、js、index接口，产生了3个QPS。</p>
<p>tps=每秒钟事务数量</p>
<p><strong>RT</strong></p>
<p>Response Time缩写，简单理解为系统从输入到输出的时间间隔，宽泛的来说，他代表从客户端发起请求到服务端接受到请求并响应所有数据的时间差。一般取平均响应时间</p>
<p><strong>并发数</strong></p>
<p>系统能同时处理的请求或者事务数量。</p>
<p><strong>计算方式</strong></p>
<pre><code>QPS=并发数/RT 或者 并发数=QPS*RT


</code></pre>
<h1 id="java知识体系学习"><a class="header" href="#java知识体系学习">java知识体系学习</a></h1>
<p>https://www.pdai.tech</p>
<p>另外还有已经上传好的学习视频，有课件配合学习的。</p>
<p>Java架构师教程全集：https://www.bilibili.com/video/BV1mz4y1y7nM</p>
<p>Java面试突击训练全套教程：https://www.bilibili.com/video/BV1bA411M7My</p>
<p>深入理解计算机网络底层原理：https://www.bilibili.com/video/BV1Gr4y1F7UV</p>
<p>透彻解析-高并发&amp;分布式&amp;微服务架构实现：https://www.bilibili.com/video/BV1aT4y1F7HD</p>
<p>Spring源码+SpringBoot源码精讲：https://www.bilibili.com/video/BV1t5411L7Gd</p>
<p>左程云算法基础+进阶全集：https://www.bilibili.com/video/BV1pK4y1S743</p>
<p>马士兵职业规划：教你如何进大厂：https://www.bilibili.com/video/BV1KV411y7gx</p>
<p>MySQL数据库教程从入门到精通全集：https://www.bilibili.com/video/BV1Fy4y1D7ne</p>
<p>课件地址：https://pan.baidu.com/s/1cmyp4rbF3qsHK42uKLMCRw 提取码：6666</p>
<h1 id="百度云链接"><a class="header" href="#百度云链接">百度云链接</a></h1>
<ol>
<li>2021考研数学全程班
链接：https://pan.baidu.com/share/init?surl=u8mffBz-ImaJFXkPNFrCuw提取码：Lion</li>
<li>2021考研英语全程班
链接：https://pan.baidu.com/s/1P18ixlHWyVizT63asWskmQ 提取码：Lion</li>
<li>2021考研政治全程班
链接：https://pan.baidu.com/share/init?surl=i_vipTIJEYGARFHhYoegdg提取码：Lion</li>
<li>20考研复试灯塔计划
链接：https://pan.baidu.com/share/init?surl=Qn0pZQJvn9SzUX0-InCCww 提取码：
lion</li>
</ol>
<h1 id="常见系统设计类问题"><a class="header" href="#常见系统设计类问题">常见系统设计类问题</a></h1>
<p>1.tiny URL
2.rateLimit
3.messager/chatroom</p>
<p>4.stat server统计分析后台</p>
<p>5.news feed 新闻/社交
6.web crawler 网络爬虫
7.location Based service 基于地址的服务
8.web application</p>
<h1 id="海量数据处理方法"><a class="header" href="#海量数据处理方法">海量数据处理方法</a></h1>
<p>1.hash
2.bitmap
3.bloom filter
4.heap
5.双层桶划分
6.数据库索引
7.inverted index
8.B+树
9.trie树
10.MapReduce</p>
<h1 id="aop实现分布式锁"><a class="header" href="#aop实现分布式锁">AOP实现分布式锁</a></h1>
<p><a href="https://developer.ibm.com/zh/articles/j-spring-boot-aop-web-log-processing-and-distributed-locking/">AOP实现分布式锁</a></p>
<h1 id="技术学习"><a class="header" href="#技术学习">技术学习</a></h1>
<h2 id="java底层"><a class="header" href="#java底层">java底层</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
ThreadLocal使用弱引用,ThreadLocal使用</li>
<li><input disabled="" type="checkbox"/>
tryCatch多捕获</li>
<li><input disabled="" type="checkbox"/>
AQS实现原理</li>
<li><input disabled="" type="checkbox"/>
java引用类型</li>
<li><input disabled="" type="checkbox"/>
throw,与throws区别</li>
<li><input disabled="" type="checkbox"/>
Java序列化机制</li>
<li><input disabled="" type="checkbox"/>
countDownLatch</li>
<li><input disabled="" type="checkbox"/>
jdk1.8BUG</li>
<li><input disabled="" type="checkbox"/>
编译自己的jdk</li>
<li><input disabled="" type="checkbox"/>
类加载过程</li>
<li><input disabled="" type="checkbox"/>
ArrayList的五到面试</li>
<li><input disabled="" type="checkbox"/>
java8的默认方法和静态方法</li>
<li><input disabled="" type="checkbox"/>
Java Builder设计模式</li>
<li><input disabled="" type="checkbox" checked=""/>
java8日期实践</li>
<li><input disabled="" type="checkbox"/>
java种null的存在</li>
<li><input disabled="" type="checkbox"/>
Object header</li>
<li><input disabled="" type="checkbox"/>
ThreadPoolExecutor拒绝策略</li>
<li><input disabled="" type="checkbox"/>
hashMap七种遍历方式</li>
<li><input disabled="" type="checkbox"/>
StampedLock解析</li>
<li><input disabled="" type="checkbox"/>
java注解</li>
<li><input disabled="" type="checkbox"/>
javaAPT开发</li>
<li><input disabled="" type="checkbox"/>
注解</li>
</ul>
<h2 id="java工具包"><a class="header" href="#java工具包">java工具包</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>Objects工具类方法</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>instrument包</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>常见的20种类库,和API</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Collections的使用</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>16个Java工具包</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>java生成校验码</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>java常用工具类</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Collectors19个常用示例</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>cglib动态代理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>JavaAIO内核增强类库</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>mapstruct</p>
</li>
</ul>
<h2 id="spring"><a class="header" href="#spring">spring</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
spring中的JavaConfig</li>
<li><input disabled="" type="checkbox" checked=""/>
spring-36个注解</li>
<li><input disabled="" type="checkbox"/>
spring-xml解析流程</li>
<li><input disabled="" type="checkbox"/>
spring-扫描自定义注解</li>
<li><input disabled="" type="checkbox"/>
AOP实现自定义注解</li>
<li><input disabled="" type="checkbox"/>
spring-profile解析</li>
<li><input disabled="" type="checkbox"/>
spring-循环依赖</li>
<li><input disabled="" type="checkbox"/>
springEL</li>
<li><input disabled="" type="checkbox"/>
springQuartz框架基础知识</li>
<li><input disabled="" type="checkbox"/>
spring-Async,异步调用</li>
<li><input disabled="" type="checkbox"/>
spring data jpa</li>
<li><input disabled="" type="checkbox"/>
Resource与Autowired</li>
<li><input disabled="" type="checkbox"/>
ResponseBodyAdvice故障排查</li>
</ul>
<h2 id="springboot"><a class="header" href="#springboot">springboot</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
<p>springMVC全局异常处理</p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>springboot-多模块开发指南</p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>springBoot-动态数据源切换 HikariCp(连接池)</p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>springboot-devtools热部署</p>
</li>
<li><input disabled="" type="checkbox" checked=""/>
<p>springboot-过滤器</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-webMVCcofigurer</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springBoot-Guava-retrying机制</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springBoot配置 HTTP/2</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-exectuors线程池</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-整合nosql</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-核心注解</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-自动配置原理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-搭建全局唯一的短链接数据中心</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-hikaricp连接池</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-Admin微服务监控</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-minio做文件服务器</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-整合https</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-项目瘦身</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-全局唯一ID生成器</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springBoot springSession</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springBoot:hazelcast,分布式缓存</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-配置文件属性跟踪</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-参数校验</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-集成CAS</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-AOP和注解实现权限校验</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-mokito</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-整合shiro基于URL身份认证</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-整合drools</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-oauth 单点登录</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-excel将对象转换成excel</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-配置文件加解密</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-mybatis</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-restTemplate</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-shiro权限管理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-swagger自动生成API文档</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-多数据源配置</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-定时任务</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-jwt接口权限认证</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-websocket实时通信</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-自定义start</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-async,异步线程池</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-使用aop</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-声明式事务</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-使用缓存</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-批处理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot全家桶:23篇博客:springboot-echarts 导出图片</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>怎样系统学习springboot</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-问题</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-nginx负载均衡</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-解决接口返回NUll的问题</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>springboot-RPC轻量级实现</p>
</li>
</ul>
<h2 id="权限控制与登录认证"><a class="header" href="#权限控制与登录认证">权限控制与登录认证</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>基于RBAC模型的权限设计</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>token超时刷新策略</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>JWT规范实现的认证微服务</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Oauth2 spring-security</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>session-&gt;token 身份验证演变过程</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>SAML sso,jwt,session</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>spring-session</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>如何设计强大的权限系统</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Session一致性解决方案</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>JWT认证</p>
</li>
</ul>
<h2 id="mybatis"><a class="header" href="#mybatis">Mybatis</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>Mybatis通用Mapper</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Mybatis3.4.5新特性</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>mybatis插件拦截delete</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>mybatis四大核心概念</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>mybatis插件机制</p>
</li>
</ul>
<h2 id="日志管理"><a class="header" href="#日志管理">日志管理</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>lockback的日志规范与脱敏</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Java日志之log4j,logback总结</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>logback配置优化</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>日志收集系统</p>
</li>
</ul>
<h2 id="高并发与锁"><a class="header" href="#高并发与锁">高并发与锁</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Java实现的6种负载均衡</li>
<li><input disabled="" type="checkbox"/>
sentinel限流,降级</li>
<li><input disabled="" type="checkbox"/>
Java并发编程框架 Disruptor</li>
<li><input disabled="" type="checkbox"/>
Java读写锁</li>
<li><input disabled="" type="checkbox"/>
JUC必备知识,AQS</li>
</ul>
<h2 id="分布式与微服务"><a class="header" href="#分布式与微服务">分布式与微服务</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>一致性hash</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>大厂分布式唯一ID生成</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>开源微服务框架</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>分布式唯一ID生成器-百度UidGenerator</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>RPC框架手写</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>分布式定时任务调度框架实现</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>接口聚合服务</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Java中的SPI</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>微服务之间的最佳调用方式</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Raft算法-处理一致性问题</p>
</li>
</ul>
<p>​</p>
<h2 id="api管理"><a class="header" href="#api管理">API管理</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>springBoot swagger2</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>opiping</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>eolinker</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>rap</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>nei</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>API接口加密方式</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>api管理工具:OpenAPI</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>开源接口管理平台</p>
</li>
</ul>
<h2 id="mysql"><a class="header" href="#mysql">mysql</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>MySQLorderby 语句实现原理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>分库分表</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>mysql学习笔记</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>mysqlGTID</p>
</li>
</ul>
<h2 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>类型化消息</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>构建模式</p>
</li>
</ul>
<h2 id="缓存"><a class="header" href="#缓存">缓存</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>布隆过滤器防止缓存穿透</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Redis-持久化</p>
</li>
</ul>
<h2 id="加密与解密"><a class="header" href="#加密与解密">加密与解密</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>open ssl:密码学基础</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Java生成随机密钥</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Java解密加密工具</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>ras加密原理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>MD5算法解析</p>
</li>
</ul>
<h2 id="linux命令"><a class="header" href="#linux命令">Linux命令</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>whereis</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>tree</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>tcpdump使用指南</p>
</li>
</ul>
<h2 id="idea使用"><a class="header" href="#idea使用">idea使用</a></h2>
<pre><code>idea调试技巧

Idea远程调试
</code></pre>
<p>代码审查与规范</p>
<ul>
<li><input disabled="" type="checkbox"/>
<p>CodeReview规范</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>35Java优化细节</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>阿里巴巴规范</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Java性能编码规范</p>
</li>
</ul>
<h2 id="数据库相关"><a class="header" href="#数据库相关">数据库相关</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>数据治理:元数据</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>ClickHouse列式数据库</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>MongoDB文档数据库</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>graphSQL</p>
</li>
</ul>
<h2 id="数据结构与算法"><a class="header" href="#数据结构与算法">数据结构与算法</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
algorithm visualizer算法可视化</li>
<li><input disabled="" type="checkbox"/>
动态规划</li>
<li><input disabled="" type="checkbox"/>
skiplist跳表</li>
<li><input disabled="" type="checkbox"/>
卡尔曼过滤器</li>
<li><input disabled="" type="checkbox"/>
红黑树</li>
</ul>
<h2 id="服务器"><a class="header" href="#服务器">服务器</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>nginx动静分离</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>nginx限速</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>tomcat-配置文件说明</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>优雅停服</p>
</li>
</ul>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>Jmeter压测</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>junit4使用</p>
</li>
</ul>
<h2 id="爬虫"><a class="header" href="#爬虫">爬虫</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
webscraper网页爬虫</li>
</ul>
<h2 id="消息中间件"><a class="header" href="#消息中间件">消息中间件</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>消息中间件的应用场景</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>MQ比较</p>
</li>
</ul>
<h2 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
git</li>
</ul>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>CDN</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>边缘计算</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>HTTP/2</p>
</li>
</ul>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
<p>Java实现重试机制</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>webpack打包原理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>Java规则引擎EasyRules</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>使用netty完成 websocket的推送</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>ffmpeg视频处理</p>
</li>
<li><input disabled="" type="checkbox"/>
<p>nginx反向代理,负载均衡,reids session共享,keep alive高可用</p>
</li>
</ul>
<ol>
<li>
<p>可继承的ThreadLocal
https://mp.weixin.qq.com/s/RBAIHnfzDXXKEc9m1eP5ZA</p>
</li>
<li>
<p>注解元编程
https://mp.weixin.qq.com/s/QjBN3SDSol7yDowJpPbvEw</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="对象构建"><a class="header" href="#对象构建">对象构建</a></h1>
<ol>
<li>
<p>构建者模式,方便创建对象</p>
</li>
<li>
<p>ObjectConfig,构建对象的配置</p>
</li>
<li>
<p>Context :构建对象的上下文</p>
</li>
</ol>
<h1 id="代理委托"><a class="header" href="#代理委托">代理委托</a></h1>
<p>Delate :委托代理类, 持有目标功能类的引用,来代理完成其他与主业务逻辑不相关的东西 例如 校验</p>
<h1 id="申明式编程"><a class="header" href="#申明式编程">申明式编程</a></h1>
<ol>
<li>
<p>接口声明式编程: 以接口的形式去 实现特定的功能, 通过接口就能找到 所有实现这个接口的对象</p>
</li>
<li>
<p>功能分明:每个接口只申明 限定的单个功能</p>
</li>
</ol>
<h1 id="模板方法"><a class="header" href="#模板方法">模板方法</a></h1>
<p>在抽象类完成 任务调用步骤, 在子类实现核心业务,或 before,after</p>
<h1 id="观察者"><a class="header" href="#观察者">观察者</a></h1>
<p>事件的发布 使用观察者模式</p>
<h1 id="接口隔离"><a class="header" href="#接口隔离">接口隔离</a></h1>
<p><strong>单一职责</strong></p>
<h1 id="看源码技巧"><a class="header" href="#看源码技巧">看源码技巧</a></h1>
<ol>
<li>先会如何使用,怎么使用</li>
<li>然后了解 整体模块</li>
<li>最后分析调试 单一功能, 从整体 到局部</li>
</ol>
<h2 id="适配器模式"><a class="header" href="#适配器模式">适配器模式</a></h2>
<p>机构转换</p>
<p>员工类型转换</p>
<h1 id="面向对象设计-三步走"><a class="header" href="#面向对象设计-三步走">面向对象设计 三步走</a></h1>
<p>数据获取
数据处理
数据转换</p>
<h2 id="failfast机制的-代码风格"><a class="header" href="#failfast机制的-代码风格">failFast机制的 代码风格</a></h2>
<ul>
<li>把所有异常情况 放在最前面处理, 尽可能减少通用代码块的复杂性</li>
<li>规定业务模糊的异常处理,  转换 为业务正常的情况
<ul>
<li>抓住某个点 进行 分类拆分</li>
</ul>
</li>
</ul>
<h1 id="牺牲性能提高代码兼容度"><a class="header" href="#牺牲性能提高代码兼容度">牺牲性能,提高代码兼容度</a></h1>
<h1 id="伪代码先行"><a class="header" href="#伪代码先行"><strong>伪代码先行</strong></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念-1"><a class="header" href="#概念-1">概念</a></h1>
<h2 id="随机试验"><a class="header" href="#随机试验">随机试验</a></h2>
<ul>
<li>
<p>在客观世界存在两类不同现象,确定性现象,和随机现象我们把<code>对随机现象进行一次观测或一次试验称为一个试验</code></p>
</li>
<li>
<p>如果这个实验满足以下三个条件称为随机试验</p>
<ul>
<li>可重复
<ul>
<li>在相同条件下,实验可以重复地进行</li>
</ul>
</li>
<li>已知
<ul>
<li>事先可以确定试验的所有结果</li>
</ul>
</li>
<li>不确定性
<ul>
<li>试验不能确定出现哪一个结果</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一般用 E表示 随机试验</p>
</li>
</ul>
<h2 id="样本空间"><a class="header" href="#样本空间">样本空间</a></h2>
<ul>
<li>随机试验发生每个可能的结果称为 基本事件,或样本点,用 <em>w</em>表示</li>
<li>某个随机试验 所有可能的结果集 称为 样本空间, <em>Ω</em></li>
</ul>
<h2 id="事件"><a class="header" href="#事件">事件</a></h2>
<h3 id="随机事件"><a class="header" href="#随机事件">随机事件</a></h3>
<ul>
<li>随机事件 是指 样本空间的一个子集</li>
<li>随机事件 是样本点的集合</li>
</ul>
<h3 id="事件之间的基本关系"><a class="header" href="#事件之间的基本关系">事件之间的基本关系</a></h3>
<p>$$
包含:A \subset B,a发生,b一定发生\
相等:A = B,a,b事件等价\
互斥:A \cap B = \emptyset,a,b事件不可能同时发生\
对立:A\cup B = Ω
$$</p>
<h3 id="事件的运算"><a class="header" href="#事件的运算">事件的运算</a></h3>
<p>$$
和事件:A \cup B\
积事件:A \cap B\
差事件:A - B\
符合事件 的
$$</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xml"><a class="header" href="#xml">XML</a></h1>
<h2 id="xml语法规则"><a class="header" href="#xml语法规则">XML语法规则</a></h2>
<ul>
<li>
<p>必须有跟元素</p>
</li>
<li>
<p>XML声明 可选</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code></p>
</li>
<li>
<p>所有的 XML 元素都必须有一个关闭标签</p>
</li>
<li>
<p>XML 标签对大小写敏感</p>
</li>
<li>
<p>XML <strong>必须正确嵌套</strong></p>
</li>
<li>
<p>XML 属性值必须加引号</p>
</li>
<li>
<p>实体引用：特殊字符用实体引用替代</p>
<table><thead><tr><th>实体引用</th><th>符号</th><th>含义</th></tr></thead><tbody>
<tr><td><code>&amp;lt;</code></td><td>&lt;</td><td>less than</td></tr>
<tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>greater than</td></tr>
<tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>ampersand</td></tr>
<tr><td><code>&amp;apos;</code></td><td>'</td><td>apostrophe</td></tr>
<tr><td><code>&amp;quot;</code></td><td>&quot;</td><td>quotation mark</td></tr>
</tbody></table>
</li>
<li>
<p>XML 中的注释</p>
<p><code>&lt;!-- This is a comment --&gt;</code></p>
</li>
<li>
<p>空格会被保留</p>
<p>HTML 会把多个连续的空格字符裁减（合并）为一个：</p>
</li>
<li>
<p>XML 以 LF 存储换行</p>
</li>
</ul>
<h2 id="xml元素"><a class="header" href="#xml元素">XML元素</a></h2>
<ul>
<li>
<p>XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。</p>
</li>
<li>
<p>一个元素可以包含：</p>
<ul>
<li>其他元素</li>
<li>文本</li>
<li>属性</li>
<li>或混合以上所有...</li>
</ul>
</li>
<li>
<p>元素命名规则</p>
<ul>
<li>字母数字其他字符</li>
<li>不能以数字标点符号开始</li>
<li>不能以字母xml开始</li>
<li>不能有空格</li>
<li>避免使用 : -  . 的字符</li>
</ul>
</li>
</ul>
<h2 id="xml属性"><a class="header" href="#xml属性">XML属性</a></h2>
<p>XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用元素吧</p>
<p>元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。</p>
<h2 id="xml验证"><a class="header" href="#xml验证">XML验证</a></h2>
<ul>
<li>
<p>合法的 XML 文档是&quot;形式良好&quot;的 XML 文档，这也符合文档类型定义（DTD,documentTyoeDefinition ）的规则</p>
</li>
<li>
<p><code>&lt;!DOCTYPE note system &quot;note.dtd&quot;</code></p>
</li>
<li>
<p>DTD 的目的是定义 XML 文档的结构</p>
</li>
<li>
<p>W3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema</p>
</li>
</ul>
<h2 id="使用-css-xslt显示-xml"><a class="header" href="#使用-css-xslt显示-xml">使用 CSS /XSLT显示 XML</a></h2>
<ul>
<li>
<p><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;</code></p>
</li>
<li>
<p>使用 CSS 格式化 XML 不是常用的方法。W3C 推荐使用 XSLT。</p>
</li>
<li>
<p>XSLT（eXtensible Stylesheet Language Transformations）远比 CSS 更加完善。</p>
</li>
<li>
<p>通过使用 XSLT，您可以把 XML 文档转换成 HTML 格式。</p>
</li>
</ul>
<h2 id="xml-命名空间"><a class="header" href="#xml-命名空间">XML 命名空间</a></h2>
<ul>
<li>
<p>XML 命名空间提供避免元素命名冲突的方法。</p>
</li>
<li>
<p>在 XML 中的命名冲突可以通过使用名称前缀从而容易地避免。</p>
<pre><code>&lt;h:table&gt;
&lt;h:tr&gt;
&lt;h:td&gt;Apples&lt;/h:td&gt;
&lt;h:td&gt;Bananas&lt;/h:td&gt;
&lt;/h:tr&gt;
&lt;/h:table&gt;
</code></pre>
</li>
<li>
<p>当在 XML 中使用前缀时，一个所谓的用于前缀的<strong>命名空间</strong>必须被定义。xmlns:<em>前缀</em>=&quot;<em>URI</em>&quot;</p>
<pre><code>&lt;h:table xmlns:h=&quot;http://www.w3.org/TR/html4/&quot;&gt;
&lt;h:tr&gt;
&lt;h:td&gt;Apples&lt;/h:td&gt;
&lt;h:td&gt;Bananas&lt;/h:td&gt;
&lt;/h:tr&gt;
&lt;/h:table&gt;
</code></pre>
</li>
<li>
<p>元素定义默认的命名空间可以让我们省去在所有的子元素中使用前缀的工作</p>
<p><code>&lt;table xmlns=&quot;http://www.w3.org/TR/html4/&quot;&gt;</code></p>
</li>
</ul>
<h2 id="xml-cdata"><a class="header" href="#xml-cdata">XML CDATA</a></h2>
<ul>
<li>XML 文档中的所有文本均会被解析器解析。只有 CDATA 区段中的文本会被解析器忽略。</li>
<li>CDATA 部分由 <code>&lt;![CDATA[</code> 开始，由 &quot;<strong>]]&gt;</strong>&quot; 结束：</li>
</ul>
<h1 id=""><a class="header" href="#"></a></h1>
<h1 id="dtd"><a class="header" href="#dtd">DTD</a></h1>
<h2 id="简介-1"><a class="header" href="#简介-1">简介</a></h2>
<p>DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。</p>
<p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。</p>
<h2 id="xml构建模块"><a class="header" href="#xml构建模块">XML构建模块</a></h2>
<ul>
<li>所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：
<ul>
<li>元素</li>
<li>属性</li>
<li>实体：特殊字符的实体引用</li>
<li>PCDATA：parsed character data，<strong>被解析器解析的文本</strong></li>
<li>CDATA：<strong>不会被解析器解析的文本</strong></li>
</ul>
</li>
</ul>
<h2 id="dtd元素申明"><a class="header" href="#dtd元素申明">DTD元素申明</a></h2>
<p>声明一个元素</p>
<pre><code>&lt;!ELEMENT element-name category&gt;
或
&lt;!ELEMENT element-name (element-content)&gt;
</code></pre>
<ul>
<li>
<p>空元素：<code>&lt;!ELEMENT br EMPTY&gt;</code></p>
</li>
<li>
<p>PCDATA 的元素：<code>&lt;!ELEMENT from (#PCDATA)&gt;</code></p>
</li>
<li>
<p>带有任何内容的元素:<code>&lt;!ELEMENT note ANY&gt;</code></p>
</li>
<li>
<p>带有子元素（序列）的元素</p>
<ul>
<li>带有一个或多个子元素的元素通过圆括号中的子元素名进行声明：</li>
<li><code>&lt;!ELEMENT element-name (child1)&gt;</code></li>
<li><code>&lt;!ELEMENT element-name (child1,child2,...)&gt;</code></li>
</ul>
</li>
<li>
<p>声明只出现一次的元素</p>
<ul>
<li><code>&lt;!ELEMENT note (message)&gt;</code></li>
</ul>
</li>
<li>
<p>声明最少出现一次的元素</p>
<ul>
<li><code>&lt;!ELEMENT note (message+)&gt;</code></li>
</ul>
</li>
<li>
<p>声明出现零次或多次的元素</p>
<ul>
<li><code>&lt;!ELEMENT note (message*)&gt;</code></li>
</ul>
</li>
<li>
<p>声明出现零次或一次的元素</p>
<ul>
<li><code>&lt;!ELEMENT note (message?)&gt;</code></li>
</ul>
</li>
<li>
<p>声明&quot;非.../即...&quot;类型的内容</p>
<ul>
<li><code>&lt;!ELEMENT note (to,from,header,(message|body))&gt;</code></li>
</ul>
</li>
<li>
<p>声明混合型的内容</p>
<ul>
<li><code>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="dtd属性申明"><a class="header" href="#dtd属性申明">DTD属性申明</a></h2>
<p>在 DTD 中，属性通过 ATTLIST 声明来进行声明。</p>
<ul>
<li>
<p>语法：</p>
<p><code>&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt;</code></p>
</li>
<li>
<p>类型选项</p>
<table><thead><tr><th style="text-align: left">类型</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">CDATA</td><td style="text-align: left">值为字符数据 (character data)</td></tr>
<tr><td style="text-align: left">(<em>en1</em>|<em>en2</em>|..)</td><td style="text-align: left">此值是枚举列表中的一个值</td></tr>
<tr><td style="text-align: left">ID</td><td style="text-align: left">值为唯一的 id</td></tr>
<tr><td style="text-align: left">IDREF</td><td style="text-align: left">值为另外一个元素的 id</td></tr>
<tr><td style="text-align: left">IDREFS</td><td style="text-align: left">值为其他 id 的列表</td></tr>
<tr><td style="text-align: left">NMTOKEN</td><td style="text-align: left">值为合法的 XML 名称</td></tr>
<tr><td style="text-align: left">NMTOKENS</td><td style="text-align: left">值为合法的 XML 名称的列表</td></tr>
<tr><td style="text-align: left">ENTITY</td><td style="text-align: left">值是一个实体</td></tr>
<tr><td style="text-align: left">ENTITIES</td><td style="text-align: left">值是一个实体列表</td></tr>
<tr><td style="text-align: left">NOTATION</td><td style="text-align: left">此值是符号的名称</td></tr>
<tr><td style="text-align: left">xml:</td><td style="text-align: left">值是一个预定义的 XML 值</td></tr>
</tbody></table>
</li>
<li>
<p>默认<strong>属性值</strong></p>
<table><thead><tr><th>值</th><th>属性的默认值</th></tr></thead><tbody>
<tr><td></td><td>属性值</td></tr>
<tr><td>#REQUIRED</td><td>属性值是必需的</td></tr>
<tr><td>#IMPLIED</td><td>属性不是必需的</td></tr>
<tr><td>#FIXED value</td><td>属性值是固定的</td></tr>
</tbody></table>
</li>
</ul>
<h2 id="dtd实体"><a class="header" href="#dtd实体">DTD实体</a></h2>
<ul>
<li>
<p>实体是用于定义引用普通文本或特殊字符的快捷方式的变量。</p>
</li>
<li>
<p>实体引用是对实体的引用</p>
</li>
<li>
<p>实体可在内部或外部进行声明。</p>
</li>
<li>
<p>一个内部实体声明</p>
<ul>
<li>
<p><code>&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;</code></p>
<pre><code>&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;
&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;

XML 实例：

&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;
</code></pre>
</li>
<li>
<p>一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。</p>
</li>
</ul>
</li>
<li>
<p>一个外部实体声明</p>
<pre><code>DTD 实例:

&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;
&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;

XML example:

&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;
</code></pre>
</li>
</ul>
<h2 id="example"><a class="header" href="#example">EXAMPLE</a></h2>
<h3 id="电视节目表-dtd"><a class="header" href="#电视节目表-dtd">电视节目表 DTD</a></h3>
<pre><code>由 David Moisan 创造。拷贝自： http://www.davidmoisan.org/

&lt;!DOCTYPE TVSCHEDULE [

&lt;!ELEMENT TVSCHEDULE (CHANNEL+)&gt;
&lt;!ELEMENT CHANNEL (BANNER,DAY+)&gt;
&lt;!ELEMENT BANNER (#PCDATA)&gt;
&lt;!ELEMENT DAY (DATE,(HOLIDAY|PROGRAMSLOT+)+)&gt;
&lt;!ELEMENT HOLIDAY (#PCDATA)&gt;
&lt;!ELEMENT DATE (#PCDATA)&gt;
&lt;!ELEMENT PROGRAMSLOT (TIME,TITLE,DESCRIPTION?)&gt;
&lt;!ELEMENT TIME (#PCDATA)&gt;
&lt;!ELEMENT TITLE (#PCDATA)&gt; 
&lt;!ELEMENT DESCRIPTION (#PCDATA)&gt;

&lt;!ATTLIST TVSCHEDULE NAME CDATA #REQUIRED&gt;
&lt;!ATTLIST CHANNEL CHAN CDATA #REQUIRED&gt;
&lt;!ATTLIST PROGRAMSLOT VTR CDATA #IMPLIED&gt;
&lt;!ATTLIST TITLE RATING CDATA #IMPLIED&gt;
&lt;!ATTLIST TITLE LANGUAGE CDATA #IMPLIED&gt;
]&gt;


</code></pre>
<hr />
<h3 id="报纸文章-dtd"><a class="header" href="#报纸文章-dtd">报纸文章 DTD</a></h3>
<pre><code>拷贝自：http://www.vervet.com/

&lt;!DOCTYPE NEWSPAPER [

&lt;!ELEMENT NEWSPAPER (ARTICLE+)&gt;
&lt;!ELEMENT ARTICLE (HEADLINE,BYLINE,LEAD,BODY,NOTES)&gt;
&lt;!ELEMENT HEADLINE (#PCDATA)&gt;
&lt;!ELEMENT BYLINE (#PCDATA)&gt;
&lt;!ELEMENT LEAD (#PCDATA)&gt;
&lt;!ELEMENT BODY (#PCDATA)&gt;
&lt;!ELEMENT NOTES (#PCDATA)&gt;

&lt;!ATTLIST ARTICLE AUTHOR CDATA #REQUIRED&gt;
&lt;!ATTLIST ARTICLE EDITOR CDATA #IMPLIED&gt;
&lt;!ATTLIST ARTICLE DATE CDATA #IMPLIED&gt;
&lt;!ATTLIST ARTICLE EDITION CDATA #IMPLIED&gt;

&lt;!ENTITY NEWSPAPER &quot;Vervet Logic Times&quot;&gt;
&lt;!ENTITY PUBLISHER &quot;Vervet Logic Press&quot;&gt;
&lt;!ENTITY COPYRIGHT &quot;Copyright 1998 Vervet Logic Press&quot;&gt;

]&gt;
</code></pre>
<hr />
<h3 id="产品目录-dtd"><a class="header" href="#产品目录-dtd">产品目录 DTD</a></h3>
<pre><code>拷贝自： http://www.vervet.com/

&lt;!DOCTYPE CATALOG [

&lt;!ENTITY AUTHOR &quot;John Doe&quot;&gt;
&lt;!ENTITY COMPANY &quot;JD Power Tools, Inc.&quot;&gt;
&lt;!ENTITY EMAIL &quot;jd@jd-tools.com&quot;&gt;

&lt;!ELEMENT CATALOG (PRODUCT+)&gt;

&lt;!ELEMENT PRODUCT
(SPECIFICATIONS+,OPTIONS?,PRICE+,NOTES?)&gt;
&lt;!ATTLIST PRODUCT
NAME CDATA #IMPLIED
CATEGORY (HandTool|Table|Shop-Professional) &quot;HandTool&quot;
PARTNUM CDATA #IMPLIED
PLANT (Pittsburgh|Milwaukee|Chicago) &quot;Chicago&quot;
INVENTORY (InStock|Backordered|Discontinued) &quot;InStock&quot;&gt;

&lt;!ELEMENT SPECIFICATIONS (#PCDATA)&gt;
&lt;!ATTLIST SPECIFICATIONS
WEIGHT CDATA #IMPLIED
POWER CDATA #IMPLIED&gt;

&lt;!ELEMENT OPTIONS (#PCDATA)&gt;
&lt;!ATTLIST OPTIONS
FINISH (Metal|Polished|Matte) &quot;Matte&quot;
ADAPTER (Included|Optional|NotApplicable) &quot;Included&quot;
CASE (HardShell|Soft|NotApplicable) &quot;HardShell&quot;&gt;

&lt;!ELEMENT PRICE (#PCDATA)&gt;
&lt;!ATTLIST PRICE
MSRP CDATA #IMPLIED
WHOLESALE CDATA #IMPLIED
STREET CDATA #IMPLIED
SHIPPING CDATA #IMPLIED&gt;

&lt;!ELEMENT NOTES (#PCDATA)&gt;

]&gt;
</code></pre>
<h1 id="xmlschema"><a class="header" href="#xmlschema">XMLSchema</a></h1>
<p>描述</p>
<ul>
<li>
<p>XML Schema 是基于 XML 的 DTD 替代者。</p>
</li>
<li>
<p>XML Schema 可描述 XML 文档的结构。</p>
</li>
<li>
<p>XML Schema 语言也可作为 XSD（XML Schema Definition）来引用。</p>
</li>
<li>
<p>XML Schema 的作用是定义 XML 文档的合法构建模块，</p>
</li>
</ul>
<h2 id="xmlschema定义"><a class="header" href="#xmlschema定义">XMLSchema定义</a></h2>
<ul>
<li>存在性问题定义</li>
</ul>
<p>​	定义了文档中可以出现的元素和属性</p>
<ul>
<li>
<p>层次结构</p>
<p>定义了子元素，子元素的次序，数目</p>
</li>
<li>
<p>元素和属性的值</p>
<p>数据类型，是否为空，是否可包含文本，默认值，固定值</p>
</li>
</ul>
<h2 id="xsdschema元素"><a class="header" href="#xsdschema元素">XSDschema元素</a></h2>
<p><code>&lt;schema&gt;</code>  为root元素</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;

&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.runoob.com&quot;
xmlns=&quot;http://www.runoob.com&quot;
elementFormDefault=&quot;qualified&quot;&gt;
...
...
&lt;/xs:schema&gt;

xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; 申明一个名称空间使用xs前缀
xmlns=&quot;http://www.runoob.com&quot; ：申明默认的名称空间
xmlns=&quot;http://www.runoob.com&quot; ：被此schema定义的元素的名称空间
xs:schemaLocation=&quot;http://www.runoob.com note.xsd&quot;：xs引用的名称空间的 XML schema 的位置
</code></pre>
<h2 id="xsd-简易元素"><a class="header" href="#xsd-简易元素">XSD 简易元素</a></h2>
<ul>
<li>
<p>简易元素指那些只包含文本的元素。它不会包含任何其他的元素或属性。</p>
</li>
<li>
<p>它可以是 XML Schema 定义中包括的类型中的一种（布尔、字符串、数据等等）</p>
</li>
</ul>
<p>定义简易元素</p>
<p>​	<code>&lt;xs:element name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt;</code></p>
<p>常见数据类型</p>
<ul>
<li>xs:string</li>
<li>xs:decimal</li>
<li>xs:integer</li>
<li>xs:boolean</li>
<li>xs:date</li>
<li>xs:time</li>
</ul>
<p>简易元素的默认值和固定值</p>
<p><code>&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; default=&quot;red&quot;/&gt;</code></p>
<p><code>&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; fixed=&quot;red&quot;/&gt;</code></p>
<h2 id="xsd属性"><a class="header" href="#xsd属性">XSD属性</a></h2>
<p>定义属性</p>
<p><code>&lt;xs:attribute name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt;</code></p>
<ul>
<li>xs:string</li>
<li>xs:decimal</li>
<li>xs:integer</li>
<li>xs:boolean</li>
<li>xs:date</li>
<li>xs:time</li>
</ul>
<p>默认值和固定值</p>
<p><code>&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; default=&quot;EN&quot;/&gt;</code></p>
<p><code>&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; fixed=&quot;EN&quot;/&gt;</code></p>
<p>可选的和必需</p>
<p>在默认的情况下，属性是可选的</p>
<p><code>&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;</code></p>
<h2 id="xsd限定"><a class="header" href="#xsd限定">XSD限定</a></h2>
<h3 id="对值的限定"><a class="header" href="#对值的限定">对值的限定</a></h3>
<p>限定 元素age 的值不能低于 0 或者高于 120</p>
<pre><code>&lt;xs:element name=&quot;age&quot;&gt;
 &lt;xs:simpleType&gt;
  &lt;xs:restriction base=&quot;xs:integer&quot;&gt;
   &lt;xs:minInclusive value=&quot;0&quot;/&gt;
   &lt;xs:maxInclusive value=&quot;120&quot;/&gt;
  &lt;/xs:restriction&gt;
 &lt;/xs:simpleType&gt;
&lt;/xs:element&gt;
</code></pre>
<h3 id="对一组值的限定"><a class="header" href="#对一组值的限定">对一组值的限定</a></h3>
<p>使用枚举约束（enumeration constraint）	</p>
<pre><code>&lt;xs:element name=&quot;car&quot;&gt;
  &lt;xs:simpleType&gt;
    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
      &lt;xs:enumeration value=&quot;Audi&quot;/&gt;
      &lt;xs:enumeration value=&quot;Golf&quot;/&gt;
      &lt;xs:enumeration value=&quot;BMW&quot;/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
&lt;/xs:element&gt;
</code></pre>
<p>或者</p>
<pre><code>&lt;xs:element name=&quot;car&quot; type=&quot;carType&quot;/&gt;

&lt;xs:simpleType name=&quot;carType&quot;&gt;
  &lt;xs:restriction base=&quot;xs:string&quot;&gt;
    &lt;xs:enumeration value=&quot;Audi&quot;/&gt;
    &lt;xs:enumeration value=&quot;Golf&quot;/&gt;
    &lt;xs:enumeration value=&quot;BMW&quot;/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;
</code></pre>
<h3 id="对一系列值的限定"><a class="header" href="#对一系列值的限定">对一系列值的限定</a></h3>
<p>使用模式约束（pattern constraint），符合正则表达式</p>
<pre><code>&lt;xs:element name=&quot;letter&quot;&gt;
  &lt;xs:simpleType&gt;
    &lt;xs:restriction base=&quot;xs:string&quot;&gt;
      &lt;xs:pattern value=&quot;[a-z]&quot;/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
&lt;/xs:element&gt;
</code></pre>
<h3 id="对空白字符的限定"><a class="header" href="#对空白字符的限定">对空白字符的限定</a></h3>
<pre><code>&lt;xs:whiteSpace value=&quot;preserve&quot;/&gt;：保留空格
&lt;xs:whiteSpace value=&quot;replace&quot;/&gt;：移除所有空格
&lt;xs:whiteSpace value=&quot;collapse&quot;/&gt;：合并空格
</code></pre>
<h3 id="对长度的限定"><a class="header" href="#对长度的限定">对长度的限定</a></h3>
<pre><code>&lt;xs:length value=&quot;8&quot;/&gt;：值的长度
&lt;xs:minLength value=&quot;5&quot;/&gt;：最小值
&lt;xs:maxLength value=&quot;8&quot;/&gt;：最大值
</code></pre>
<h3 id="数据类型限定表"><a class="header" href="#数据类型限定表">数据类型限定表</a></h3>
<table><thead><tr><th style="text-align: left">限定</th><th style="text-align: left">描述</th></tr></thead><tbody>
<tr><td style="text-align: left">enumeration</td><td style="text-align: left">定义可接受值的一个列表</td></tr>
<tr><td style="text-align: left">fractionDigits</td><td style="text-align: left">定义所允许的最大的小数位数。必须大于等于0。</td></tr>
<tr><td style="text-align: left">length</td><td style="text-align: left">定义所允许的字符或者列表项目的精确数目。必须大于或等于0。</td></tr>
<tr><td style="text-align: left">maxExclusive</td><td style="text-align: left">定义数值的上限。所允许的值必须小于此值。</td></tr>
<tr><td style="text-align: left">maxInclusive</td><td style="text-align: left">定义数值的上限。所允许的值必须小于或等于此值。</td></tr>
<tr><td style="text-align: left">maxLength</td><td style="text-align: left">定义所允许的字符或者列表项目的最大数目。必须大于或等于0。</td></tr>
<tr><td style="text-align: left">minExclusive</td><td style="text-align: left">定义数值的下限。所允许的值必需大于此值。</td></tr>
<tr><td style="text-align: left">minInclusive</td><td style="text-align: left">定义数值的下限。所允许的值必需大于或等于此值。</td></tr>
<tr><td style="text-align: left">minLength</td><td style="text-align: left">定义所允许的字符或者列表项目的最小数目。必须大于或等于0。</td></tr>
<tr><td style="text-align: left">pattern</td><td style="text-align: left">定义可接受的字符的精确序列。</td></tr>
<tr><td style="text-align: left">totalDigits</td><td style="text-align: left">定义所允许的阿拉伯数字的精确位数。必须大于0。</td></tr>
<tr><td style="text-align: left">whiteSpace</td><td style="text-align: left">定义空白字符（换行、回车、空格以及制表符）的处理方式。</td></tr>
</tbody></table>
<h2 id="xsd复合元素"><a class="header" href="#xsd复合元素">XSD复合元素</a></h2>
<p>复合元素指包含其他元素及/或属性的 XML 元素。</p>
<h3 id="四种类型的复合元素"><a class="header" href="#四种类型的复合元素">四种类型的复合元素</a></h3>
<ul>
<li>空元素</li>
<li>包含其他元素的元素</li>
<li>仅包含文本的元素</li>
<li>包含元素和文本的元素</li>
</ul>
<h3 id="定义复合元素"><a class="header" href="#定义复合元素">定义复合元素</a></h3>
<ul>
<li>
<p>直接对&quot;employee&quot;元素进行声明</p>
<pre><code>&lt;xs:element name=&quot;employee&quot;&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
</li>
<li>
<p>&quot;employee&quot; 元素可以使用 type 属性，这个属性的作用是引用要使用的复合类型的名称</p>
</li>
</ul>
<pre><code>&lt;xs:element name=&quot;employee&quot; type=&quot;personinfo&quot;/&gt;

&lt;xs:complexType name=&quot;personinfo&quot;&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</code></pre>
<ul>
<li>
<p>在已有的复合元素之上以某个复合元素为基础，然后添加一些元素</p>
<pre><code>&lt;xs:element name=&quot;employee&quot; type=&quot;fullpersoninfo&quot;/&gt;

&lt;xs:complexType name=&quot;personinfo&quot;&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name=&quot;fullpersoninfo&quot;&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base=&quot;personinfo&quot;&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element name=&quot;address&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt;
        &lt;xs:element name=&quot;country&quot; type=&quot;xs:string&quot;/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;
</code></pre>
</li>
</ul>
<h3 id="复合空元素"><a class="header" href="#复合空元素">复合空元素</a></h3>
<p>一个空的 XML 元素：<code>&lt;product prodid=&quot;1345&quot; /&gt;</code></p>
<pre><code>&lt;xs:element name=&quot;product&quot;&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base=&quot;xs:integer&quot;&gt;
        &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
<pre><code>&lt;xs:element name=&quot;product&quot;&gt;
  &lt;xs:complexType&gt;
    &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
<pre><code>&lt;xs:element name=&quot;product&quot; type=&quot;prodtype&quot;/&gt;

&lt;xs:complexType name=&quot;prodtype&quot;&gt;
  &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;
&lt;/xs:complexType&gt;
</code></pre>
<h3 id="复合类型仅包含元素"><a class="header" href="#复合类型仅包含元素">复合类型仅包含元素</a></h3>
<pre><code>&lt;person&gt;
 &lt;firstname&gt;John&lt;/firstname&gt;
 &lt;lastname&gt;Smith&lt;/lastname&gt;
&lt;/person&gt;
</code></pre>
<pre><code>&lt;xs:element name=&quot;person&quot;&gt;
 &lt;xs:complexType&gt;
  &lt;xs:sequence&gt;
   &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;
   &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;
  &lt;/xs:sequence&gt;
 &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
<pre><code>&lt;xs:element name=&quot;person&quot; type=&quot;persontype&quot;/&gt;

&lt;xs:complexType name=&quot;persontype&quot;&gt;
  &lt;xs:sequence&gt;
    &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;
    &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;
  &lt;/xs:sequence&gt;
&lt;/xs:complexType&gt;
</code></pre>
<h3 id="仅含文本的复合元素"><a class="header" href="#仅含文本的复合元素">仅含文本的复合元素</a></h3>
<pre><code>&lt;xs:element name=&quot;shoesize&quot;&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base=&quot;xs:integer&quot;&gt;
        &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
<pre><code>&lt;xs:element name=&quot;shoesize&quot; type=&quot;shoetype&quot;/&gt;

&lt;xs:complexType name=&quot;shoetype&quot;&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base=&quot;xs:integer&quot;&gt;
      &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;
</code></pre>
<h3 id="带有混合内容的复合类型"><a class="header" href="#带有混合内容的复合类型">带有混合内容的复合类型</a></h3>
<pre><code>&lt;letter&gt;
  Dear Mr.&lt;name&gt;John Smith&lt;/name&gt;.
  Your order &lt;orderid&gt;1032&lt;/orderid&gt;
  will be shipped on &lt;shipdate&gt;2001-07-13&lt;/shipdate&gt;.
&lt;/letter&gt;
</code></pre>
<pre><code>&lt;xs:element name=&quot;letter&quot;&gt;
  &lt;xs:complexType mixed=&quot;true&quot;&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;orderid&quot; type=&quot;xs:positiveInteger&quot;/&gt;
      &lt;xs:element name=&quot;shipdate&quot; type=&quot;xs:date&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
<h2 id="xsd-指示器"><a class="header" href="#xsd-指示器">XSD 指示器</a></h2>
<p>有七种指示器：</p>
<p>Order 指示器</p>
<ul>
<li>
<p>All:规定子元素可以按照任意顺序出现</p>
<pre><code>&lt;xs:element name=&quot;person&quot;&gt;
  &lt;xs:complexType&gt;
    &lt;xs:all&gt;
      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:all&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
</li>
<li>
<p>Choice：只可选一个</p>
<pre><code>&lt;xs:element name=&quot;person&quot;&gt;
  &lt;xs:complexType&gt;
    &lt;xs:choice&gt;
      &lt;xs:element name=&quot;employee&quot; type=&quot;employee&quot;/&gt;
      &lt;xs:element name=&quot;member&quot; type=&quot;member&quot;/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
</li>
<li>
<p>Sequence:按顺序出现</p>
<pre><code>&lt;xs:element name=&quot;person&quot;&gt;
   &lt;xs:complexType&gt;
    &lt;xs:sequence&gt;
      &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt;
      &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;
    &lt;/xs:sequence&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</code></pre>
</li>
</ul>
<p>Occurrence 指示器</p>
<ul>
<li>maxOccurs</li>
<li>minOccurs</li>
</ul>
<p>Group 指示器</p>
<ul>
<li>Group name</li>
<li>attributeGroup name</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<p>YAML 是 &quot;YAML Ain't a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>
<p>YAML 的语法和其他高级语言类似，并且可以简单表达<strong>清单</strong>、<strong>散列表</strong>，<strong>标量等数据形态</strong>。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</p>
<p>YAML 的配置文件后缀为 <strong>.yml</strong>，如：<strong>runoob.yml</strong> 。</p>
<h1 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h1>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>'#'表示注释</li>
</ul>
<h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<p>YAML 支持以下几种数据类型：</p>
<ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
<li>纯量（scalars）：单个的、不可再分的值</li>
</ul>
<h2 id="yaml-对象"><a class="header" href="#yaml-对象">YAML 对象</a></h2>
<p>对象键值对使用冒号结构表示 <strong>key: value</strong>，冒号后面要加一个空格。</p>
<p>也可以使用 <strong>key:{key1: value1, key2: value2, ...}</strong>。</p>
<p>还可以使用缩进表示层级关系；</p>
<pre><code class="language-yaml">key: 
    child-key: value
    child-key2: value2
</code></pre>
<p>较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：</p>
<pre><code>?  
    - complexkey1
    - complexkey2
:
    - complexvalue1
    - complexvalue2
</code></pre>
<p>意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]</p>
<h2 id="yaml-数组"><a class="header" href="#yaml-数组">YAML 数组</a></h2>
<p>以 <strong>-</strong> 开头的行表示构成一个数组：</p>
<pre><code>- A
- B
- C
</code></pre>
<p>YAML 支持多维数组，可以使用行内表示：</p>
<pre><code>key: [value1, value2, ...]
</code></pre>
<p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p>
<pre><code>-
 - A
 - B
 - C
</code></pre>
<p>一个相对复杂的例子：</p>
<pre><code>companies:
    -
        id: 1
        name: company1
        price: 200W
    -
        id: 2
        name: company2
        price: 500W
</code></pre>
<p>意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。</p>
<p>数组也可以使用流式(flow)的方式表示：</p>
<pre><code>companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]
</code></pre>
<h2 id="复合结构"><a class="header" href="#复合结构">复合结构</a></h2>
<p>数组和对象可以构成复合结构，例：</p>
<pre><code>languages:
  - Ruby
  - Perl
  - Python 
websites:
  YAML: yaml.org 
  Ruby: ruby-lang.org 
  Python: python.org 
  Perl: use.perl.org
</code></pre>
<p>转换为json为</p>
<pre><code>{ 
  languages: [ 'Ruby', 'Perl', 'Python'],
  websites: {
    YAML: 'yaml.org',
    Ruby: 'ruby-lang.org',
    Python: 'python.org',
    Perl: 'use.perl.org' 
  } 
}
</code></pre>
<h2 id="纯量"><a class="header" href="#纯量">纯量</a></h2>
<p>纯量是最基本的，不可再分的值，包括：</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<pre><code>boolean: 
    - TRUE  #true,True都可以
    - FALSE  #false，False都可以
float:
    - 3.14
    - 6.8523015e+5  #可以使用科学计数法
int:
    - 123
    - 0b1010_0111_0100_1010_1110    #二进制表示
null:
    nodeName: 'node'
    parent: ~  #使用~表示null
string:
    - 哈哈
    - 'Hello world'  #可以使用双引号或者单引号包裹特殊字符
    - newline
      newline2    #字符串可以拆成多行，每一行会被转化成一个空格
date:
    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd
datetime: 
    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区
</code></pre>
<h3 id="引用"><a class="header" href="#引用">引用</a></h3>
<p><strong>&amp;</strong> 锚点和 ***** 别名，可以用来引用:</p>
<pre><code>defaults: &amp;defaults
  adapter:  postgres
  host:     localhost

development:
  database: myapp_development
  &lt;&lt;: *defaults

test:
  database: myapp_test
  &lt;&lt;: *defaults
</code></pre>
<p>相当于:</p>
<pre><code>defaults:
  adapter:  postgres
  host:     localhost

development:
  database: myapp_development
  adapter:  postgres
  host:     localhost

test:
  database: myapp_test
  adapter:  postgres
  host:     localhost
</code></pre>
<p><strong>&amp;</strong> 用来建立锚点（defaults），<strong>&lt;&lt;</strong> 表示合并到当前数据，***** 用来引用锚点。</p>
<p>下面是另一个例子:</p>
<pre><code>- &amp;showell Steve 
- Clark 
- Brian 
- Oren 
- *showell 
</code></pre>
<p>转为 JavaScript 代码如下:</p>
<pre><code>[ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cfs-bandwidth-control"><a class="header" href="#cfs-bandwidth-control">CFS Bandwidth Control</a></h1>
<p>本文档仅讨论 SCHED_NORMAL 的 CPU 带宽控制。 </p>
<p>CFS 带宽控制是一个 CONFIG_FAIR_GROUP_SCHED 扩展，它允许指定组或层次结构可用的最大 CPU 带宽</p>
<p>组允许的带宽是使用 配额和周期 (quota and period) 指定的。</p>
<p>在每个给定的“周期”（微秒）内，一个组最多只能消耗“配额”微秒的 CPU 时间。</p>
<p>当某个组的 CPU 带宽消耗超过此限制（在该时间段内）时，属于其层次结构的任务将受到限制，并且在下一个时间段之前不允许再次运行。</p>
<p>一个组的未使用运行时间被全局跟踪，在每个周期边界用上述配额单位进行刷新。</p>
<p>当线程消耗此带宽时，它会根据需要传输到 CPU 本地“筒仓”。</p>
<p>在这些更新中的每一个中传输的数量都是可调的，并被描述为“切片”。</p>
<h1 id="management"><a class="header" href="#management">Management</a></h1>
<p>通过 cgroupfs 在 cpu 子系统内管理配额和周期。</p>
<p><code>cpu.cfs_quota_us</code>：一个周期内的总可用运行时间（以微秒为单位） </p>
<p><code>cpu.cfs_period_us</code>：一个周期的长度（以微秒为单位） </p>
<p><code>cpu.stat</code>：导出  throttling  统计信息 [下面进一步解释]</p>
<pre><code>The default values are:
	cpu.cfs_period_us=100ms
	cpu.cfs_quota=-1
</code></pre>
<p>cpu.cfs_quota_us 的值为 -1 表示该组没有任何带宽限制，这样的组被描述为无约束带宽组。</p>
<p>写入任何（有效）正值将制定指定的带宽限制。</p>
<p>配额或周期允许的最小配额为 1 毫秒。 </p>
<p>1s 的周期长度也有一个上限。</p>
<p>当以分层方式使用带宽限制时，存在其他限制，下面将更详细地解释这些限制。</p>
<p>向 cpu.cfs_quota_us 写入任何负值将取消带宽限制并使组再次返回到不受约束的状态。</p>
<p>如果组处于受限状态，则对组带宽规范的任何更新都将导致其不受限制。</p>
<h1 id="system-wide-settings"><a class="header" href="#system-wide-settings">System wide settings</a></h1>
<p>效率运行时间以批处理方式在全局池和 CPU 本地“筒仓”之间传输。</p>
<p>这大大减轻了大型系统的全局统计压力。</p>
<p>这可以通过 procfs 进行调整：/proc/sys/kernel/sched_cfs_bandwidth_slice_us（默认值=5ms）</p>
<p>较大的切片值将减少传输开销，而较小的值允许更细粒度的消费。</p>
<h1 id="statistics"><a class="header" href="#statistics">Statistics</a></h1>
<p>组的带宽统计通过 cpu.stat 中的 3 个字段导出。</p>
<pre><code>cpu.stat:
- nr_periods:已过去的强制执行间隔数。
- nr_throttled:组被节流/限制的次数。
- throttled_time: 组的实体受到限制的总持续时间（以纳秒为单位）。
</code></pre>
<p>该接口是只读的。</p>
<h1 id="层级考虑"><a class="header" href="#层级考虑">层级考虑</a></h1>
<pre><code>[ Where C is the parent's bandwidth, and c_i its children ]
</code></pre>
<p>该接口强制要求始终可以获得单个实体的带宽，即：max(c_i) &lt;= C。但是，明确允许聚合情况下的超额订阅以在层次结构中启用工作节约语义。</p>
<p><strong>组在以下两种情况可能会被限制</strong></p>
<p>a. 它在一段时间内完全消耗了自己的配额
b. 父母的配额在其期限内被完全消耗</p>
<p>即使子级可能还有剩余的运行时，在父级的运行时更新 之前也不允许这样做。</p>
<h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<pre><code>1. Limit a group to 1 CPU worth of runtime.

	If period is 250ms and quota is also 250ms, the group will get
	1 CPU worth of runtime every 250ms.

	# echo 250000 &gt; cpu.cfs_quota_us /* quota = 250ms */
	# echo 250000 &gt; cpu.cfs_period_us /* period = 250ms */

2. Limit a group to 2 CPUs worth of runtime on a multi-CPU machine.

	With 500ms period and 1000ms quota, the group can get 2 CPUs worth of
	runtime every 500ms.

	# echo 1000000 &gt; cpu.cfs_quota_us /* quota = 1000ms */
	# echo 500000 &gt; cpu.cfs_period_us /* period = 500ms */

	The larger period here allows for increased burst capacity.

3. Limit a group to 20% of 1 CPU.

	With 50ms period, 10ms quota will be equivalent to 20% of 1 CPU.

	# echo 10000 &gt; cpu.cfs_quota_us /* quota = 10ms */
	# echo 50000 &gt; cpu.cfs_period_us /* period = 50ms */

	By using a small period here we are ensuring a consistent latency
	response at the expense of burst capacity.
	
通过在这里使用一小段时间，我们以牺牲突发容量为代价确保一致的延迟响应。
</code></pre>
<p><strong>周期越长 响应延时越高，但总的吞吐量越大</strong></p>
<p>翻译自</p>
<p><a href="https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt">CFS BandWithControl</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linuxfor语句总结"><a class="header" href="#linuxfor语句总结">LinuxFor语句总结</a></h1>
<h2 id="第一类数字性循环"><a class="header" href="#第一类数字性循环"><strong>第一类：数字性循环</strong></a></h2>
<h2 id="显示递增"><a class="header" href="#显示递增"><strong>显示递增</strong></a></h2>
<pre><code class="language-sh">#!/bin/bash  
  
for((i=1;i&lt;=10;i++));  
do   
echo $(expr $i \* 3 + 1);  
done  
</code></pre>
<h2 id="seq命令"><a class="header" href="#seq命令">SEQ命令</a></h2>
<pre><code class="language-sh">#!/bin/bash  
  
for i in $(seq 1 10)  
do   
echo $(expr $i \* 3 + 1);  
done   
</code></pre>
<p><strong>选项</strong></p>
<pre><code>Usage: seq [OPTION]... LAST
  or:  seq [OPTION]... FIRST LAST
  or:  seq [OPTION]... FIRST INCREMENT LAST
</code></pre>
<h2 id="首尾范围"><a class="header" href="#首尾范围">首尾范围</a></h2>
<pre><code class="language-sh">#!/bin/bash  
  
for i in {1..10}  
do  
echo $(expr $i \* 3 + 1);  
done  
</code></pre>
<h2 id="awk递增"><a class="header" href="#awk递增">AWK递增</a></h2>
<pre><code>awk 'BEGIN{for(i=1; i&lt;=10; i++) print i}'  
</code></pre>
<h2 id="字符性循环"><a class="header" href="#字符性循环">字符性循环</a></h2>
<p><strong>ls命令</strong></p>
<pre><code>#!/bin/bash  
  
for i in `ls`;  
do   
echo $i is file name\! ;  
done   
</code></pre>
<p><strong>脚本参数</strong></p>
<pre><code class="language-sh">#!/bin/bash  
  
for i in $* ;  
do  
echo $i is input chart\! ;  
done 
</code></pre>
<p><strong>字面量</strong></p>
<pre><code class="language-sh">#!/bin/bash  
  
list=&quot;rootfs usr data data2&quot;  
for i in $list;  
do  
echo $i is appoint ;  
done  
</code></pre>
<h2 id="路径查找"><a class="header" href="#路径查找"><strong>路径查找</strong></a></h2>
<pre><code class="language-sh">#!/bin/bash  
  
for file in /proc/*;  
do  
echo $file is file path \! ;  
done  
</code></pre>
<pre><code class="language-sh">#!/bin/bash  
  
for file in $(ls *.sh)  
do  
echo $file is file path \! ;  
done  
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="确认启用服务器远程开机"><a class="header" href="#确认启用服务器远程开机">确认/启用服务器远程开机</a></h1>
<pre><code>Settings for eth0:

        --- 略 ---

       Supports Wake-on: pumbag

        Wake-on: d

        --- 略 ---
</code></pre>
<p>其他信息不用关注，重要的是上面列出的两项:</p>
<p><strong>Supports Wake-on: pumbag</strong></p>
<ul>
<li>p Wake on phy activity</li>
<li>u Wake on unicast messages</li>
<li>m Wake on multicast messages</li>
<li>b Wake on broadcast messages</li>
<li>a Wake on ARP</li>
<li>g Wake on MagicPacket(tm)</li>
</ul>
<p>wake-on 项值默认为 d，表示禁用wake on lan。需要把wake-on的值设为g以启用 wake on lan</p>
<h1 id="设置wol选项"><a class="header" href="#设置wol选项">设置WOL选项</a></h1>
<p><strong>临时设置</strong></p>
<pre><code>ethtool -s eth0 wol g
</code></pre>
<p><strong>永久设置</strong></p>
<pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0
ETHTOOL_OPTS=&quot;wol g&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell-test-命令"><a class="header" href="#shell-test-命令">Shell test 命令</a></h1>
<blockquote>
<p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
</blockquote>
<h2 id="数值测试"><a class="header" href="#数值测试">数值测试</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">-eq</td><td style="text-align: left">等于则为真</td></tr>
<tr><td style="text-align: left">-ne</td><td style="text-align: left">不等于则为真</td></tr>
<tr><td style="text-align: left">-gt</td><td style="text-align: left">大于则为真</td></tr>
<tr><td style="text-align: left">-ge</td><td style="text-align: left">大于等于则为真</td></tr>
<tr><td style="text-align: left">-lt</td><td style="text-align: left">小于则为真</td></tr>
<tr><td style="text-align: left">-le</td><td style="text-align: left">小于等于则为真</td></tr>
</tbody></table>
<h2 id="实例"><a class="header" href="#实例">实例</a></h2>
<h3 id="实例1"><a class="header" href="#实例1">实例1</a></h3>
<pre><code>num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo '两个数相等！'
else
    echo '两个数不相等！'
fi
</code></pre>
<p>代码中的 <strong>[]</strong> 执行基本的算数运算，如：</p>
<h3 id="实例2"><a class="header" href="#实例2">实例2</a></h3>
<pre><code>#!/bin/bash
a=5
b=6
result=$[a+b]# 注意等号两边不能有空格
echo &quot;result 为： $result&quot;
</code></pre>
<h2 id="字符串测试"><a class="header" href="#字符串测试">字符串测试</a></h2>
<table><thead><tr><th style="text-align: left">参数</th><th style="text-align: left">说明</th></tr></thead><tbody>
<tr><td style="text-align: left">=</td><td style="text-align: left">等于则为真</td></tr>
<tr><td style="text-align: left">!=</td><td style="text-align: left">不相等则为真</td></tr>
<tr><td style="text-align: left">-z 字符串</td><td style="text-align: left">字符串的长度为零则为真</td></tr>
<tr><td style="text-align: left">-n 字符串</td><td style="text-align: left">字符串的长度不为零则为真</td></tr>
</tbody></table>
<h3 id="实例-1"><a class="header" href="#实例-1">实例</a></h3>
<pre><code class="language-sh">num1=&quot;ru1noob&quot;
num2=&quot;runoob&quot;
if test $num1 = $num2
then
    echo '两个字符串相等!'
else
    echo '两个字符串不相等!'
fi
</code></pre>
<h2 id="文件测试"><a class="header" href="#文件测试">文件测试</a></h2>
<table><thead><tr><th>-b filename</th><th>当filename 存在并且是块文件时返回真(返回0)</th></tr></thead><tbody>
<tr><td>-c filename</td><td>当filename 存在并且是字符文件时返回真</td></tr>
<tr><td>-d pathname</td><td>当pathname 存在并且是一个目录时返回真</td></tr>
<tr><td>-e pathname</td><td>当由pathname 指定的文件或目录存在时返回真</td></tr>
<tr><td>-f filename</td><td>当filename 存在并且是正规文件时返回真</td></tr>
<tr><td>-g pathname</td><td>当由pathname 指定的文件或目录存在并且设置了SGID 位时返回真</td></tr>
<tr><td>-h filename</td><td>当filename 存在并且是符号链接文件时返回真 (或 -L filename)</td></tr>
<tr><td>-k pathname</td><td>当由pathname 指定的文件或目录存在并且设置了&quot;粘滞&quot;位时返回真</td></tr>
<tr><td>-p filename</td><td>当filename 存在并且是命名管道时返回真</td></tr>
<tr><td>-r pathname</td><td>当由pathname 指定的文件或目录存在并且可读时返回真</td></tr>
<tr><td>-s filename</td><td>当filename 存在并且文件大小大于0 时返回真</td></tr>
<tr><td>-S filename</td><td>当filename 存在并且是socket 时返回真</td></tr>
<tr><td>-t fd</td><td>当fd 是与终端设备相关联的文件描述符时返回真</td></tr>
<tr><td>-u pathname</td><td>当由pathname 指定的文件或目录存在并且设置了SUID 位时返回真</td></tr>
<tr><td>-w pathname</td><td>当由pathname 指定的文件或目录存在并且可写时返回真</td></tr>
<tr><td>-x pathname</td><td>当由pathname 指定的文件或目录存在并且可执行时返回真</td></tr>
<tr><td>-O pathname</td><td>当由pathname 存在并且被当前进程的有效用户id 的用户拥有时返回真(字母O 大写)</td></tr>
<tr><td>-G pathname</td><td>当由pathname 存在并且属于当前进程的有效用户id 的用户的用户组时返回真</td></tr>
<tr><td>file1 -nt file2</td><td>file1 比file2 新时返回真</td></tr>
<tr><td>file1 -ot file2</td><td>file1 比file2 旧时返回真</td></tr>
<tr><td>f1 -ef f2</td><td>files f1 and f2 are hard links to the same file</td></tr>
</tbody></table>
<pre><code class="language-sh">cd /bin
if test -e ./bash
then
    echo '文件已存在!'
else
    echo '文件不存在!'
fi
</code></pre>
<h2 id="条件组合"><a class="header" href="#条件组合">条件组合</a></h2>
<p>另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： <strong>!</strong> 最高， <strong>-a</strong> 次之， <strong>-o</strong> 最低</p>
<pre><code class="language-sh">cd /bin
if test -e ./notFile -o -e ./bash
then
    echo '至少有一个文件存在!'
else
    echo '两个文件都不存在'
fi
</code></pre>
<h2 id="简写形式"><a class="header" href="#简写形式">简写形式</a></h2>
<pre><code class="language-sh">[ expression ]
</code></pre>
<p>注意<code>[]</code>和<code>expression</code>之间的空格，这两个空格是必须的，否则会导致语法错误。<code>[]</code>的写法更加简洁，比 test 使用频率高。</p>
<h2 id="在-test-中使用变量建议用双引号包围起来"><a class="header" href="#在-test-中使用变量建议用双引号包围起来">在 test 中使用变量建议用双引号包围起来</a></h2>
<p>test 和 [] 都是命令，一个命令本质上对应一个程序或者一个函数。即使是一个程序，它也有入口函数，例如C语言程序的入口函数是 main()，运行C语言程序就从 main() 函数开始，所以也可以将一个程序等效为一个函数，这样我们就不用再区分函数和程序了，直接将一个命令和一个函数对应起来即可。</p>
<p>有了以上认知，就很容易看透命令的本质了：使用一个命令其实就是调用一个函数，命令后面附带的选项和参数最终都会作为实参传递给函数。</p>
<p>假设 test 命令对应的函数是 func()，使用<code>test -z $str1</code>命令时，会先将变量 $str1 替换成字符串：</p>
<ul>
<li>如果 $str1 是一个正常的字符串，比如 abc123，那么替换后的效果就是<code>test -z abc123</code>，调用 func() 函数的形式就是<code>func(&quot;-z abc123&quot;)</code>。test 命令后面附带的所有选项和参数会被看成一个整体，并作为实参传递进函数。</li>
<li>如果 $str1 是一个空字符串，那么替换后的效果就是<code>test -z</code>，调用 func() 函数的形式就是<code>func(&quot;-z &quot;)</code>，这就比较奇怪了，因为<code>-z</code>选项没有和参数成对出现，func() 在分析时就会出错。</li>
</ul>
<p>如果我们给 $str1 变量加上双引号，当 $str1 是空字符串时，<code>test -z &quot;$str1&quot;</code>就会被替换为<code>test -z &quot;&quot;</code>，调用 func() 函数的形式就是<code>func(&quot;-z \&quot;\&quot;&quot;)</code>，很显然，<code>-z</code>选项后面跟的是一个空字符串（<code>\&quot;</code>表示转义字符），这样 func() 在分析时就不会出错了。</p>
<p>所以，当你在 test 命令中使用变量时，我强烈建议将变量用双引号<code>&quot;&quot;</code>包围起来，这样能避免变量为空值时导致的很多奇葩问题</p>
<h1 id="ifelse语句"><a class="header" href="#ifelse语句">ifelse语句</a></h1>
<h2 id="语法格式"><a class="header" href="#语法格式">语法格式</a></h2>
<pre><code class="language-sh">if  condition
then
    statement(s)
fi
</code></pre>
<p><code>condition</code>是判断条件，如果 condition 成立（返回“真”），那么 then 后边的语句将会被执行；如果 condition 不成立（返回“假”），那么不会执行任何语句。</p>
<p><strong>从本质上讲，if 检测的是命令的退出状态</strong>，我们将在下节《<a href="http://c.biancheng.net/view/2735.html">Shell退出状态</a>》中深入讲解。</p>
<p>注意，最后必须以<code>fi</code>来闭合，fi 就是 if 倒过来拼写。也正是有了 fi 来结尾，所以即使有多条语句也不需要用<code>{ }</code>包围起来。</p>
<p>如果你喜欢，也可以将 then 和 if 写在一行：</p>
<pre><code class="language-sh">if condition;  then
  statement(s)
fi


if  condition
then
   statement1
else
   statement2
fi


if  condition1
then
   statement1
elif condition2
then
    statement2
elif condition3
then
    statement3
……
else
   statementn
fi
</code></pre>
<p>请注意 condition 后边的分号<code>;</code>，当 if 和 then 位于同一行的时候，这个分号是必须的，否则会有语法错误。</p>
<h1 id="双括号与条件测试"><a class="header" href="#双括号与条件测试">双括号与条件测试</a></h1>
<blockquote>
<p><strong>使用双括号进行四则运算、逻辑运算等</strong></p>
</blockquote>
<h2 id="比较两个数字的大小"><a class="header" href="#比较两个数字的大小">比较两个数字的大小</a></h2>
<pre><code class="language-sh">#!/bin/bash
read a
read b
if (( $a == $b ))
then
    echo &quot;a和b相等&quot;
fi
</code></pre>
<p>在《<a href="http://c.biancheng.net/view/2480.html">Shell (())</a>》一节中我们讲到，<code>(())</code>是一种数学计算命令，它除了可以进行最基本的加减乘除运算，<strong>还可以进行大于、小于、等于等关系运算，以及与、或、非逻辑运算</strong>。当 a 和 b 相等时，<code>(( $a == $b ))</code>判断条件成立，进入 if，执行 then 后边的 echo 语句。</p>
<h2 id="逻辑运算"><a class="header" href="#逻辑运算">逻辑运算</a></h2>
<pre><code class="language-sh">#!/bin/bash

read age
read iq

if (( $age &gt; 18 &amp;&amp; $iq &lt; 60 ))
then
    echo &quot;你都成年了，智商怎么还不及格！&quot;
    echo &quot;来C语言中文网（http://c.biancheng.net/）学习编程吧，能迅速提高你的智商。&quot;
fi
</code></pre>
<h1 id="-条件测试"><a class="header" href="#-条件测试">[[ ]]条件测试</a></h1>
<blockquote>
<p><code>[[ ]]</code>是 Shell 内置关键字，它和 <a href="http://c.biancheng.net/view/2742.html">test 命令</a>类似，也用来检测某个条件是否成立。</p>
</blockquote>
<p>test 能做到的，[[ ]] 也能做到，而且 [[ ]] 做的更好；test 做不到的，[[ ]] 还能做到。可以认为 [[ ]] 是 <strong>test 的升级版</strong>，对细节进行了优化，并且扩展了一些功能。</p>
<h2 id="语法-2"><a class="header" href="#语法-2">语法</a></h2>
<pre><code class="language-sh">[[ expression ]]
当 [[ ]] 判断 expression 成立时，退出状态为 0，否则为非 0 值。注意[[ ]]和expression之间的空格，这两个空格是必须的，否则会导致语法错误。
</code></pre>
<h2 id="逻辑运算-1"><a class="header" href="#逻辑运算-1">逻辑运算</a></h2>
<p>对多个表达式进行逻辑运算时，可以使用逻辑运算符将多个 test 命令连接起来，例如：</p>
<pre><code class="language-sh">[ -z &quot;$str1&quot; ] || [ -z &quot;$str2&quot; ]
</code></pre>
<p>你也可以借助选项把多个表达式写在一个 test 命令中，例如：</p>
<pre><code class="language-sh">[ -z &quot;$str1&quot; -o -z &quot;$str2&quot; ]
</code></pre>
<p>但是，这两种写法都有点“别扭”，完美的写法是在一个命令中使用逻辑运算符将多个表达式连接起来。我们的这个愿望在 [[ ]] 中实现了，[[ ]] 支持 &amp;&amp;、|| 和 ! 三种逻辑运算符。</p>
<p><strong>使用 [[ ]] 对上面的语句进行改进：</strong></p>
<pre><code class="language-sh">[[ -z $str1 || -z $str2 ]]
</code></pre>
<p>这种写法就比较简洁漂亮了。</p>
<p><strong>注意，[[ ]] 剔除了 test 命令的<code>-o</code>和<code>-a</code>选项，你只能使用 || 和 &amp;&amp;。这意味着，你不能写成下面的形式：</strong></p>
<pre><code class="language-sh">[[ -z $str1 -o -z $str2 ]]
</code></pre>
<p>当然，使用逻辑运算符将多个 [[ ]] 连接起来依然是可以的，因为这是 Shell 本身提供的功能，跟 [[ ]] 或者 test 没有关系，如下所示：</p>
<pre><code class="language-sh">[[ -z $str1 ]] || [[ -z $str2 ]]
</code></pre>
<h2 id="实例-2"><a class="header" href="#实例-2">实例</a></h2>
<h3 id="字符串比较"><a class="header" href="#字符串比较">字符串比较</a></h3>
<pre><code class="language-sh">#!/bin/bash
read str1
read str2
if [[ -z $str1 ]] || [[ -z $str2 ]]  #不需要对变量名加双引号
then
    echo &quot;字符串不能为空&quot;
elif [[ $str1 &lt; $str2 ]]  #不需要也不能对 &lt; 进行转义
then
    echo &quot;str1 &lt; str2&quot;
else
    echo &quot;str1 &gt;= str2&quot;
fi
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-1"><a class="header" href="#概述-1">概述</a></h1>
<p>sed命令应用广泛，使用简单，是快速文本处理的利器</p>
<p><img src="10.Linux/../images/linux_sed.jfif" alt="" /></p>
<h1 id="参数"><a class="header" href="#参数">参数</a></h1>
<p><code>-f</code></p>
<p>参数指定一个sed脚本</p>
<p><code>-n</code></p>
<p>这个参数是--quiet或者--silent的意思。表明忽略执行过程的输出，只输出我们的结果即可。</p>
<p><code>-i</code></p>
<blockquote>
<p>使用此参数后，所有改动将在原文件上执行。你的输出将覆盖原文件。<strong>非常危险</strong>，一定要注意。</p>
</blockquote>
<h1 id="范围"><a class="header" href="#范围">范围</a></h1>
<p>这个范围的指定很有灵性，请看以下示例（请自行替换图中的范围部分）。</p>
<blockquote>
<p><strong>5</strong> 选择第5行。</p>
<p><strong>2,5</strong> 选择2到5行，共4行。</p>
<p><strong>1~2</strong> 选择奇数行。</p>
<p><strong>2~2</strong> 选择偶数行。</p>
<p><strong>2,+3</strong> 和2,5的效果是一样的，共4行。</p>
<p><strong>2,$</strong> 从第二行到文件结尾。</p>
</blockquote>
<p>范围的选择还可以使用正则匹配。请看下面示例。</p>
<p><strong>/sys/,+3</strong> 选择出现sys字样的行，以及后面的三行。</p>
<p><strong>/^sys/,/mem/</strong> 选择以sys开头的行，和出现mem字样行之间的数据。</p>
<pre><code>sed -n '5p' file
sed -n '2,5 p' file
sed -n '1~2 p' file
sed -n '2~2 p' file
sed -n '2,+3p' file
sed -n '2,$ p' file
sed -n '/sys/,+3 p' file
sed -n '/^sys/,/mem/p' file
</code></pre>
<h1 id="操作"><a class="header" href="#操作">操作</a></h1>
<p>最常用的操作就是p，意思就是打印。比如，以下两个命令就是等同的：</p>
<pre><code>cat file 
sed -n 'p' file
</code></pre>
<p>除了打印，还有以下操作，我们来说常用的。</p>
<p><strong>p</strong> 对匹配内容进行打印。</p>
<p><strong>d</strong> 对匹配内容进行删除。这个时候就要去掉-n参数了，想想为什么。</p>
<p><strong>w</strong> 将匹配内容写入到其他地方。</p>
<p>那么我想一次执行多个命令，还不想写sed脚本文件怎么办？那就需要加-e参数。sed的操作单元是行。</p>
<h1 id="替换模式"><a class="header" href="#替换模式">替换模式</a></h1>
<p>以上是sed命令的常用匹配模式，但它还有一个强大的替换模式，意思就是查找替换其中的某些值，并输出结果。使用替换模式很少使用-n参数。</p>
<h2 id="语法格式-1"><a class="header" href="#语法格式-1">语法格式</a></h2>
<p><img src="10.Linux/../images/linux_sed_replace_mode.jfif" alt="" /></p>
<h2 id="参数解析"><a class="header" href="#参数解析">参数解析</a></h2>
<p>替换模式的参数有点多，但第一部分和第五部分都是可以省略的。替换后会将<strong>整个文本</strong>输出出来。</p>
<pre><code>sed 's/a/b/g' file
sed 's/[a,b,c]/&lt;&amp;&gt;/g' file#这个命令我们下面解释
</code></pre>
<p>**&amp;**号，再重复一遍。当它用在替换字符串中的时候，代表的是原始的查找匹配数据。</p>
<blockquote>
<p><strong>[&amp;]</strong> 表明将查找到的数据使用[]包围起来。</p>
<p><strong>“&amp;”</strong> 表明将查找的数据使用””包围起来。</p>
</blockquote>
<p>下面这条命令，将会把文件中的每一行，使用引号包围起来。</p>
<pre><code>sed 's/.*/&quot;&amp;&quot;/' file
</code></pre>
<p>flag 参数</p>
<p><strong>g</strong> 默认只匹配行中第一次出现的内容，加上g，就可以全文替换了。常用。</p>
<p><strong>p</strong> 当使用了-n参数，p将仅输出匹配行内容。</p>
<p><strong>w</strong> 和上面的w模式类似，但是它仅仅输出有变换的行。</p>
<p><strong>i</strong> 这个参数比较重要，表示忽略大小写。</p>
<p><strong>e</strong> 表示将输出的每一行，执行一个命令。不建议使用，可以使用xargs配合完成这种功能。</p>
<p>看两个命令的语法：</p>
<pre><code>sed -n 's/a/b/gipw output.txt' file
sed 's/^/ls -la/e' file
</code></pre>
<p>由于正则的关系，很多字符需要转义。你会在脚本里做些很多\，*之类的处理。你可以使用|^@!四个字符来替换\。</p>
<p>比如，下面五个命令是一样的。</p>
<pre><code>sed '/aaa/s/\/etc/\/usr/g' file
sed '/aaa/s@/etc@/usr@g' file
sed '/aaa/s^/etc^/usr^g' file
sed '/aaa/s|/etc|/usr|g' file
sed '/aaa/s!/etc!/usr!g' file
</code></pre>
<h1 id="example-1"><a class="header" href="#example-1">Example</a></h1>
<p><strong>输出长度不小于50个字符的行</strong></p>
<pre><code>sed -n '/^.{50}/p'
</code></pre>
<p><strong>统计文件中有每个单词出现了多少次</strong></p>
<pre><code>sed 's/ /\n/g' file | sort | uniq -c
</code></pre>
<p><strong>查找目录中的py文件，删掉所有行级注释</strong></p>
<pre><code>find ./ -name &quot;*.py&quot; | xargs sed -i.bak '/^[ ]*#/d'
</code></pre>
<p><strong>查看第5-7行和10-13行</strong></p>
<pre><code>sed -n -e '5,7p' -e '10,13p' file
</code></pre>
<p><strong>仅输出ip地址</strong></p>
<pre><code>ip route show | sed -n '/src/p' | sed -e 's/ */ /g' | cut -d' ' -f9
</code></pre>
<p>Do you want to proceed with the proposed reshard plan</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="工作模式"><a class="header" href="#工作模式">工作模式</a></h1>
<p><img src="10.Linux//images/vi_work_mode.png" alt="" /></p>
<p>1）命令模式：启动vi编辑器后默认进入命令模式，该模式中主要完成如光标移动、字符串查找，以及删除、复制、粘贴文件内容等相关操作</p>
<p>2）输入模式：该模式中主要的操作就是录入文件内容，可以对文本文件正文进行修改、或者添加新的内容。处于输入模式时，vi编辑器的最后一行会出现&quot;-- INSERT --&quot;的状态提示信息</p>
<p>3）末行模式：该模式中可以设置vi编辑环境、保存文件、退出编辑器，以及对文件内容进行查找、替换等操作。处于末行模式时，vi编辑器的最后一行会出现冒号&quot;:&quot;提示符</p>
<h1 id="命令模式的基本操作"><a class="header" href="#命令模式的基本操作">命令模式的基本操作</a></h1>
<h2 id="光标移动"><a class="header" href="#光标移动">光标移动</a></h2>
<p><img src="10.Linux//images/vi_cursor_move.png" alt="" /></p>
<h2 id="复制粘贴删除"><a class="header" href="#复制粘贴删除">复制、粘贴、删除</a></h2>
<p><img src="10.Linux//images/vi_copy_paste_del.png" alt="" /></p>
<h2 id="撤销编辑及保存退出"><a class="header" href="#撤销编辑及保存退出">撤销编辑及保存退出</a></h2>
<p><img src="10.Linux//images/vi_edit_undo_save.png" alt="" /></p>
<h2 id="保存文件及退出vi编辑器"><a class="header" href="#保存文件及退出vi编辑器">保存文件及退出vi编辑器</a></h2>
<p><img src="10.Linux//images/vi_save_exit.png" alt="" /></p>
<h2 id="打开新文件或读入其他文件内容"><a class="header" href="#打开新文件或读入其他文件内容">打开新文件或读入其他文件内容</a></h2>
<h1 id="删除行"><a class="header" href="#删除行">删除行</a></h1>
<pre><code># 1. 删除空行
:g/^$/d

# 2. 删除只包含空白字符（空格/回车/Tab制表符）的行
:g/^\s*$/d

# 3. 删除以 # 或 空格# 或 tab# 开头的行
:g/^\s*#/d

# 4. 如果当前行包含 hello，则删除当前行
:/hello/d

# 5. 删除从第二行到包含 hello 的区间行
:2,/hello/d

# 6. 删除从包含 hello 的行到最后一行区间的行
:/hello/,$d

# 7. 删除所有包含 hello 的行
:g/hello/d

# 8. 删除匹配 hello 且前面只有一个字符的行
:g/.hello/d

# 9. 删除匹配 hello 且以它开头的行
:g/^hello/d

# 10. 删除匹配 hello 且以它结尾的行
:g/hello$/d

# 11. 删除 # 之后所有字符串
%s/\#.*//g
</code></pre>
<h1 id="显示空白行"><a class="header" href="#显示空白行">显示空白行</a></h1>
<p>空白行包括了空格、换行、Tab制表符等内容，在 vim 命令模式下可以通过命令 :set list 显示所有空白字符，&quot;^I&quot; 代表 Tab 制表符，“$” 代表换行符。</p>
<h1 id="全局查找替换命令语法格式"><a class="header" href="#全局查找替换命令语法格式"><strong>全局查找替换命令语法格式</strong></a></h1>
<pre><code>[addr]s/源字符串/目的字符串/[option]

[addr] 表示检索范围，省略时表示当前行。
（1）“1，20” 表示从第1行到20行；
（2）“%”       表示整个文件，同“1,$”；
（3）“. ,$”     表示从当前行到文件尾；

s : 表示替换操作

[option] : 表示操作类型，常见：
（1）g 表示全局替换; 
（2）c 表示进行确认
（3）d 表示进行删除
（4）p 表示替代结果逐行显示（Ctrl + L恢复屏幕）；

注意事项：
（1）省略option时仅对每行第一个匹配串进行替换；
（2）如果在源字符串和目的字符串中出现特殊字符，需要用”\”转义
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-2"><a class="header" href="#概述-2">概述</a></h1>
<p>和其它编程语言类似，Shell 也支持两种分支结构（选择结构），分别是 if else 语句和 case in 语句</p>
<p>当分支较多，并且判断条件比较简单时，使用 case in 语句就比较方便了。</p>
<p><strong>语法</strong></p>
<pre><code class="language-sh">case expression in
    pattern1)
        statement1
        ;;
    pattern2)
        statement2
        ;;
    pattern3)
        statement3
        ;;
    ……
    *)
        statementn
esac
</code></pre>
<pre><code class="language-sh">#!/bin/bash
printf &quot;Input integer number: &quot;
read num
case $num in
    1)
        echo &quot;Monday&quot;
        ;;
    2)
        echo &quot;Tuesday&quot;
        ;;
    3)
        echo &quot;Wednesday&quot;
        ;;
    4)
        echo &quot;Thursday&quot;
        ;;
    5)
        echo &quot;Friday&quot;
        ;;
    6)
        echo &quot;Saturday&quot;
        ;;
    7)
        echo &quot;Sunday&quot;
        ;;
    *)
        echo &quot;error&quot;
esac
</code></pre>
<p>case、in 和 esac 都是 Shell 关键字，expression 表示表达式，pattern 表示匹配模式。</p>
<ul>
<li>expression 既可以是一个变量、一个数字、一个字符串，还可以是一个数学计算表达式，或者是命令的执行结果，只要能够得到 expression 的值就可以。</li>
<li>pattern 可以是一个数字、一个字符串，甚至是一个简单的正则表达式。</li>
</ul>
<p>case 会将 expression 的值与 pattern1、pattern2、pattern3 逐个进行匹配：</p>
<ul>
<li>如果 expression 和某个模式（比如 pattern2）匹配成功，就会执行这模式（比如 pattern2）后面对应的所有语句（该语句可以有一条，也可以有多条），直到遇见双分号<code>;;</code>才停止；然后整个 case 语句就执行完了，程序会跳出整个 case 语句，执行 esac 后面的其它语句。</li>
<li>如果 expression 没有匹配到任何一个模式，那么就执行<code>*)</code>后面的语句（<code>*</code>表示其它所有值），直到遇见双分号<code>;;</code>或者<code>esac</code>才结束。<code>*)</code>相当于多个 if 分支语句中最后的 else 部分。</li>
</ul>
<h1 id="case-in-和正则表达式"><a class="header" href="#case-in-和正则表达式">case in 和正则表达式</a></h1>
<p>case in 的 pattern 部分支持简单的正则表达式，具体来说，可以使用以下几种格式：</p>
<table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody>
<tr><td>*</td><td>表示任意字符串。</td></tr>
<tr><td>[abc]</td><td>表示 a、b、c 三个字符中的任意一个。比如，[15ZH] 表示 1、5、Z、H 四个字符中的任意一个。</td></tr>
<tr><td>[m-n]</td><td>表示从 m 到 n 的任意一个字符。比如，[0-9] 表示任意一个数字，[0-9a-zA-Z] 表示字母或数字。</td></tr>
<tr><td>|</td><td>表示多重选择，类似逻辑运算中的或运算。比如，abc | xyz 表示匹配字符串 &quot;abc&quot; 或者 &quot;xyz&quot;。</td></tr>
</tbody></table>
<p>如果不加以说明，Shell 的值都是字符串，expression 和 pattern 也是按照字符串的方式来匹配的；本节第一段代码看起来是判断数字是否相等，其实是判断字符串是否相等。</p>
<p><strong>正则使用</strong></p>
<pre><code class="language-sh">#!/bin/bash
printf &quot;Input a character: &quot;
read -n 1 char
case $char in
    [a-zA-Z])
        printf &quot;\nletter\n&quot;
        ;;
    [0-9])
        printf &quot;\nDigit\n&quot;
        ;;
    [0-9])
        printf &quot;\nDigit\n&quot;
        ;;
    [,.?!])
        printf &quot;\nPunctuation\n&quot;
        ;;
    *)
        printf &quot;\nerror\n&quot;
esac
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-cgroups-简介"><a class="header" href="#linux-cgroups-简介">linux cgroups 简介</a></h1>
<p>cgroups(Control Groups) 是 linux 内核提供的一种机制</p>
<p><strong>这种机制可以根据需求把一系列系统任务及其子任务整合(或分隔)到按资源划分等级的不同组内，从而为系统资源管理提供一个统一的框架</strong></p>
<p>简单说，cgroups 可以限制、记录任务组所使用的物理资源。</p>
<p>本质上来说，cgroups 是内核附加在程序上的一系列钩子(hook)</p>
<p>通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</p>
<h1 id="为什么要了解-cgroups"><a class="header" href="#为什么要了解-cgroups">为什么要了解 cgroups</a></h1>
<p>在以容器技术为代表的虚拟化技术大行其道的时代了解 cgroups 技术是非常必要的！</p>
<p><strong>比如我们可以很方便的限制某个容器可以使用的 CPU、内存等资源</strong>，这究竟是如何实现的呢？</p>
<p>通过了解 cgroups 技术，我们可以窥探到 linux 系统中整个资源限制系统的脉络。从而帮助我们更好的理解和使用 linux 系统。</p>
<h1 id="cgroups-的四大功能"><a class="header" href="#cgroups-的四大功能">cgroups 的四大功能</a></h1>
<p>实现 cgroups 的主要目的是为不同用户层面的资源管理提供一个统一化的接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups 提供了四大功能：</p>
<ul>
<li>资源限制</li>
</ul>
<p>cgroups 可以对任务是要的资源总额进行限制。比如设定任务运行时使用的内存上限，一旦超出就发 OOM。</p>
<ul>
<li>进程调度优先级</li>
</ul>
<p>通过分配的 CPU 时间片数量和磁盘 IO 带宽，实际上就等同于控制了任务运行的优先级。</p>
<ul>
<li>资源统计</li>
</ul>
<p>cgoups 可以统计系统的资源使用量，比如 CPU 使用时长、内存用量等。这个功能非常适合当前云端产品按使用量计费的方式。</p>
<ul>
<li>任务控制</li>
</ul>
<p>cgroups 可以对任务执行挂起、恢复等操作。</p>
<h1 id="相关概念"><a class="header" href="#相关概念">相关概念</a></h1>
<h2 id="task任务"><a class="header" href="#task任务"><strong>Task(任务)</strong></a></h2>
<p>在 linux 系统中，内核本身的调度和管理并不对进程和线程进行区分，只是根据 clone 时传入的参数的不同来从概念上区分进程和线程。这里使用 task 来表示系统的一个进程或线程。</p>
<h2 id="cgroup控制组"><a class="header" href="#cgroup控制组"><strong>Cgroup(控制组)</strong></a></h2>
<blockquote>
<p>在这个控制组里 定义了多种 资源控制</p>
</blockquote>
<p>cgroups 中的资源控制以 cgroup 为单位实现。Cgroup 表示按某种资源控制标准划分而成的任务组，包含一个或多个子系统。一个任务可以加入某个 cgroup，也可以从某个 cgroup 迁移到另一个 cgroup。</p>
<h2 id="subsystem子系统"><a class="header" href="#subsystem子系统"><strong>Subsystem(子系统)</strong></a></h2>
<p>cgroups 中的子系统就是一个<strong>资源调度控制器</strong>(又叫 controllers)。</p>
<p>比如 CPU 子系统可以控制 CPU 的时间分配，内存子系统可以限制内存的使用量。</p>
<p><strong>cat /proc/cgroups</strong></p>
<table><thead><tr><th>subsys_name</th><th>description</th><th>hierarchy</th><th>num_cgroups</th><th>enabled</th></tr></thead><tbody>
<tr><td>cpuset</td><td>给 cgroup 中的任务分配独立的 CPU(多处理器系统) 和内存节点</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>cpu</td><td>限制 CPU 时间片的分配，与 cpuacct 挂载在同一目录</td><td>2</td><td>1</td><td>1</td></tr>
<tr><td>cpuacct</td><td>生成 cgroup 中的任务占用 CPU 资源的报告，与 cpu 挂载在同一目录</td><td>3</td><td>1</td><td>1</td></tr>
<tr><td>blkio</td><td>对块设备的 IO 进行限制</td><td>4</td><td>1</td><td>1</td></tr>
<tr><td>memory</td><td>对 cgroup 中的任务的可用内存进行限制，并自动生成资源占用报告</td><td>5</td><td>1</td><td>1</td></tr>
<tr><td>devices</td><td>允许或禁止 cgroup 中的任务访问设备</td><td>6</td><td>1</td><td>1</td></tr>
<tr><td>freezer</td><td>暂停/恢复 cgroup 中的任务</td><td>7</td><td>1</td><td>1</td></tr>
<tr><td>net_cls</td><td>使用等级识别符（classid）标记网络数据包，这让 Linux 流量控制器（tc 指令）可以识别来自特定 cgroup 任务的数据包，并进行网络限制。</td><td>8</td><td>1</td><td>1</td></tr>
<tr><td>perf_event</td><td>允许使用 perf 工具来监控 cgroup。</td><td>9</td><td>1</td><td>1</td></tr>
<tr><td>net_prio</td><td>允许基于 cgroup 设置网络流量(netowork traffic)的优先级。</td><td>10</td><td>1</td><td>1</td></tr>
<tr><td>hugetlb</td><td>限制使用的内存页数量。</td><td>11</td><td>1</td><td>1</td></tr>
<tr><td>pids</td><td>限制任务的数量。</td><td>12</td><td>1</td><td>1</td></tr>
<tr><td>rdma</td><td></td><td>13</td><td>1</td><td>1</td></tr>
</tbody></table>
<p>层级有一系列 cgroup 以一个树状结构排列而成，</p>
<p>每个层级通过绑定对应的子系统进行资源控制。</p>
<p>层级中的 cgroup 节点可以包含零个或多个子节点，子节点继承父节点挂载的子系统。</p>
<p>一个操作系统中可以有多个层级</p>
<h1 id="cgroups-的文件系统接口"><a class="header" href="#cgroups-的文件系统接口">cgroups 的文件系统接口</a></h1>
<p>cgroups 以文件的方式提供应用接口，我们可以通过 mount 命令来查看 cgroups 默认的挂载点：</p>
<p><code>cat /sys/fs/cgroup</code></p>
<pre><code>tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755)
cgroup2 on /sys/fs/cgroup/unified type cgroup2 (rw,nosuid,nodev,noexec,relatime,nsdelegate)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/cpu type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)
cgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/net_cls type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)
cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)
</code></pre>
<p><strong>第一行说明</strong></p>
<ul>
<li>
<p><strong>/sys/fs/cgroup</strong> 目录下的文件 都是存在于内存中的临时文件。</p>
</li>
<li>
<p>在使用 systemd 系统的操作系统中，/sys/fs/cgroup 目录都是由 systemd 在系统启动的过程中挂载的，并且挂载为只读的类型</p>
</li>
</ul>
<p><strong>以 memory为例</strong></p>
<pre><code class="language-sh">ls  /sys/fs/cgroup/memory
</code></pre>
<pre><code>cgroup.clone_children       memory.kmem.max_usage_in_bytes      memory.memsw.failcnt             memory.stat
cgroup.event_control        memory.kmem.tcp.failcnt             memory.memsw.limit_in_bytes      memory.swappiness
cgroup.procs                memory.kmem.tcp.limit_in_bytes      memory.memsw.max_usage_in_bytes  memory.usage_in_bytes
cgroup.sane_behavior        memory.kmem.tcp.max_usage_in_bytes  memory.memsw.usage_in_bytes      memory.use_hierarchy
memory.failcnt              memory.kmem.tcp.usage_in_bytes      memory.move_charge_at_immigrate  notify_on_release
memory.force_empty          memory.kmem.usage_in_bytes          memory.oom_control               release_agent
memory.kmem.failcnt         memory.limit_in_bytes               memory.pressure_level            tasks
memory.kmem.limit_in_bytes  memory.max_usage_in_bytes           memory.soft_limit_in_bytes
</code></pre>
<p>这些文件就是 cgroups 的 memory 子系统中的根级设置。</p>
<p>比如 memory.limit_in_bytes 中的数字用来限制进程的最大可用内存，</p>
<p>memory.swappiness 中保存着使用 swap 的权重等等。</p>
<h1 id="查看进程所属的-cgroups"><a class="header" href="#查看进程所属的-cgroups">查看进程所属的 cgroups</a></h1>
<pre><code class="language-sh">可以通过 /proc/[pid]/cgroup 来查看指定进程属于哪些 cgroup：
</code></pre>
<p><strong>以docker为例</strong></p>
<pre><code class="language-sh">cat /proc/$(cat /var/run/docker.pid)/cgroup
</code></pre>
<pre><code>13:rdma:/
12:pids:/
11:hugetlb:/
10:net_prio:/
9:perf_event:/
8:net_cls:/
7:freezer:/
6:devices:/
5:memory:/
4:blkio:/
3:cpuacct:/
2:cpu:/
1:cpuset:/
0::/
</code></pre>
<p>每一行包含用冒号隔开的<strong>三列</strong>，他们的含义分别是：</p>
<ul>
<li>cgroup 树的 ID， 和 /proc/cgroups 文件中的 ID 一一对应。</li>
<li>和 cgroup 树绑定的所有 subsystem，多个 subsystem 之间用逗号隔开</li>
<li>进程在 cgroup 树中的路径，即进程所属的 cgroup，这个路径是相对于挂载点的相对路径</li>
</ul>
<p>既然 cgroups 是以这些文件作为 API 的，那么我就可以通过创建或者是修改这些文件的内容来应用 cgroups。具体该怎么做呢？比如我们怎么才能限制某个进程可以使用的资源呢？</p>
<h1 id="cgroups-工具"><a class="header" href="#cgroups-工具">cgroups 工具</a></h1>
<pre><code class="language-sh">sudo apt install cgroup-tools
</code></pre>
<h1 id="demo限制进程可用的-cpu"><a class="header" href="#demo限制进程可用的-cpu">demo：限制进程可用的 CPU</a></h1>
<pre><code class="language-sh">$ cd  /sys/fs/cgroup/cpu
$ sudo mkdir nick_cpu
</code></pre>
<p>此操作会自动 在 <code>/sys/fs/cgroup/cpu/nick_cpu/</code> 新建以下文件</p>
<pre><code>cgroup.clone_children  cpu.cfs_period_us  cpu.rt_period_us   cpu.shares  notify_on_release
cgroup.procs           cpu.cfs_quota_us   cpu.rt_runtime_us  cpu.stat    tasks
</code></pre>
<p><strong>限制只能使用 1/10的CPU</strong></p>
<pre><code>$ sudo su
$ echo 100000 &gt; nick_cpu/cpu.cfs_period_us
$ echo 10000 &gt; nick_cpu/cpu.cfs_quota_us
</code></pre>
<p><strong>CPU密集程序</strong></p>
<pre><code class="language-sh">void main()
{
    unsigned int i, end;

    end = 1024 * 1024 * 1024;
    for(i = 0; i &lt; end; )
    {
        i ++;
    }
}
</code></pre>
<p><strong>编译</strong></p>
<pre><code>$ gcc cputime.c -o cputime
$ sudo su
$ time ./cputime
$ time cgexec -g cpu:nick_cpu ./cputime
</code></pre>
<p>time 命令可以为我们报告程序执行消耗的时间，</p>
<p>其中的 real 就是我们真实感受到的时间。</p>
<p>使用 cgexec 能够把我们添加的 cgroup 配置 nick_cpu 应用到运行 cputime 程序的进程上。 </p>
<pre><code class="language-sh">$ time ./cputime
real    0m0.479s
user    0m0.478s
sys     0m0.000s
$time cgexec -g cpu:nick_cpu ./cputime

real    0m4.788s
user    0m0.483s
sys     0m0.000s
</code></pre>
<p><strong>上图显示：实际执行要 0.4s，资源限制之后 要4.7s</strong></p>
<p>当修改成</p>
<pre><code class="language-sh">#周期100ms,占用额度100ms
$ echo 100000 &gt; nick_cpu/cpu.cfs_period_us
$ echo 100000 &gt; nick_cpu/cpu.cfs_quota_us
</code></pre>
<pre><code>$time cgexec -g cpu:nick_cpu ./cputime

real    0m0.472s
user    0m0.470s
sys     0m0.000s
</code></pre>
<h1 id="demo限制进程可用的内存"><a class="header" href="#demo限制进程可用的内存">demo：限制进程可用的内存</a></h1>
<pre><code>
cd /sys/fs/cgroup/memory 
sudo mkdir nick_memory
#下面的设置把进程的可用内存限制在最大 300M，并且不使用 swap：
# 物理内存 + SWAP &lt;= 300 MB；1024*1024*300 = 314572800s
echo 314572800 &gt; nick_memory/memory.limit_in_bytes
echo 0 &gt; nick_memory/memory.swappiness

</code></pre>
<p>然后创建一个不断分配内存的程序，它分五次分配内存，每次申请 100M：</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

#define CHUNK_SIZE 1024 * 1024 * 100

void main()
{
    char *p;
    int i;

    for(i = 0; i &lt; 5; i ++)
    {
        p = malloc(sizeof(char) * CHUNK_SIZE);
        if(p == NULL)
        {
            printf(&quot;fail to malloc!&quot;);
            return ;
        }
        // memset() 函数用来将指定内存的前 n 个字节设置为特定的值
        memset(p, 0, CHUNK_SIZE);
        printf(&quot;malloc memory %d MB\n&quot;, (i + 1) * 100);
    }
}
</code></pre>
<pre><code>gcc nick_memory.c  -o nick_mem
</code></pre>
<pre><code>$./nick_mem
malloc memory 100 MB
malloc memory 200 MB
malloc memory 300 MB
malloc memory 400 MB
malloc memory 500 MB
</code></pre>
<pre><code> cgexec -g memory:nick_memory ./nick_mem
 malloc memory 100 MB
malloc memory 200 MB
Killed
</code></pre>
<p>由于内存不足且禁止使用 swap，所以被限制资源的进程在申请内存时被强制杀死了。</p>
<p>下面再使用 stress 程序测试一个类似的场景(通过 stress 程序申请 500M 的内存)：</p>
<pre><code>sudo cgexec -g memory:nick_memory stress --vm 1 --vm-bytes 500000000 --vm-keep --verbose
</code></pre>
<p>stress 程序能够提供比较详细的信息，进程被杀掉的方式是收到了 SIGKILL(signal 9) 信号。</p>
<p>实际应用中往往要同时限制多种的资源，比如既限制 CPU 资源又限制内存资源。使用 cgexec 实现这样的用例其实很简单，直接指定多个 -g 选项就可以了：</p>
<pre><code>$ cgexec -g cpu:nick_cpu -g memory:nick_memory ./cpumem
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-3"><a class="header" href="#概述-3">概述</a></h1>
<p><a href="http://curl.haxx.se/">curl</a>是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在&quot;标准输出&quot;（stdout）上面。</p>
<h1 id="查看网页源码"><a class="header" href="#查看网页源码"><strong>查看网页源码</strong></a></h1>
<p>直接在curl命令后加上网址，就可以看到网页源码。我们以网址www.sina.com为例</p>
<pre><code>curl www.sina.com
</code></pre>
<p><strong>如果要把这个网页保存下来，可以使用<code>-o</code>参数</strong></p>
<pre><code>curl -o [文件名] www.sina.com
</code></pre>
<h1 id="响应重定向"><a class="header" href="#响应重定向"><strong>响应重定向</strong></a></h1>
<p>有的网址是自动跳转的。使用<code>-L</code>参数，curl就会跳转到新的网址。</p>
<pre><code>curl -L www.sina.com
</code></pre>
<h1 id="显示头信息"><a class="header" href="#显示头信息"><strong>显示头信息</strong></a></h1>
<p><code>-i</code>参数可以显示http response的头信息，连同网页代码一起。</p>
<pre><code>curl -i www.sina.com
</code></pre>
<p><code>-I</code>参数则是只显示http response的头信息。</p>
<h1 id="显示通信过程"><a class="header" href="#显示通信过程"><strong>显示通信过程</strong></a></h1>
<p><code>-v</code>参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。</p>
<p>更详细的</p>
<pre><code> curl --trace output.txt www.sina.com
 curl --trace-ascii output.txt www.sina.com
</code></pre>
<h1 id="发送表单信息"><a class="header" href="#发送表单信息"><strong>发送表单信息</strong></a></h1>
<p><strong>GET方法</strong></p>
<pre><code>curl example.com/form.cgi?data=xxx
</code></pre>
<p><strong>POST方法</strong></p>
<p>必须把数据和网址分开，curl就要用到--data参数。</p>
<pre><code class="language-sh">curl -X POST --data &quot;data=xxx&quot; example.com/form.cgi
curl -X POST--data-urlencode &quot;date=April 1&quot; example.com/form.cgi

</code></pre>
<h1 id="post-请求的数据体"><a class="header" href="#post-请求的数据体">POST 请求的数据体</a></h1>
<pre><code>curl -d 'login=emma' -d 'password=123' -X POST  https://google.com/login
</code></pre>
<p><code>-d</code>参数可以读取本地文本文件的数据，向服务器发送。</p>
<pre><code>curl -d '@data.txt' https://google.com/login
</code></pre>
<p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p>
<pre><code>$ curl --data-urlencode 'comment=hello world' https://google.com/login
</code></pre>
<h1 id="http动词"><a class="header" href="#http动词"><strong>HTTP动词</strong></a></h1>
<p>curl默认的HTTP动词是GET，使用<code>-X</code>参数可以支持其他动词。</p>
<pre><code>curl -X POST www.example.com
curl -X DELETE www.example.com
</code></pre>
<h1 id="文件上传"><a class="header" href="#文件上传">文件上传</a></h1>
<pre><code class="language-html">　　&lt;form method=&quot;POST&quot; enctype='multipart/form-data' action=&quot;upload.cgi&quot;&gt;
　　　　&lt;input type=file name=upload&gt;
　　　　&lt;input type=submit name=press value=&quot;OK&quot;&gt;
　　&lt;/form&gt;
</code></pre>
<pre><code>curl --form upload=@localfilename --form press=OK [URL]
</code></pre>
<h1 id="referer字段"><a class="header" href="#referer字段"><strong>Referer字段</strong></a></h1>
<blockquote>
<p>-e</p>
</blockquote>
<p>提供一个referer字段，表示你是从哪里跳转过来的。</p>
<pre><code class="language-sh">curl --referer http://www.example.com
</code></pre>
<h1 id="user-agent字段"><a class="header" href="#user-agent字段"><strong>User Agent字段</strong></a></h1>
<p>或者 <em>-A</em></p>
<p>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。</p>
<pre><code>$ curl --user-agent &quot;[User Agent]&quot; [URL]
</code></pre>
<h1 id="cookie"><a class="header" href="#cookie"><strong>cookie</strong></a></h1>
<p>使用<code>--cookie</code>参数，可以让curl发送cookie。</p>
<pre><code>$ curl --cookie &quot;name=xxx&quot; www.example.com
</code></pre>
<p>至于具体的cookie的值，可以从http response头信息的<code>Set-Cookie</code>字段中得到。</p>
<p><code>-c cookie-file</code>可以保存服务器返回的cookie到文件，<code>-b cookie-file</code>可以使用这个文件作为cookie信息，进行后续的请求。</p>
<pre><code class="language-sh">$ curl -c cookies http://example.com
$ curl -b cookies http://example.com
</code></pre>
<h1 id="增加头信息"><a class="header" href="#增加头信息"><strong>增加头信息</strong></a></h1>
<blockquote>
<p>-H</p>
</blockquote>
<pre><code>curl --header &quot;Content-Type:application/json&quot;
</code></pre>
<h1 id="http认证"><a class="header" href="#http认证"><strong>HTTP认证</strong></a></h1>
<pre><code>curl --user name:password example.com
</code></pre>
<h1 id="上传二进制"><a class="header" href="#上传二进制">上传二进制</a></h1>
<p>上面命令会给 HTTP 请求加上标头<code>Content-Type: multipart/form-data</code>，然后将文件<code>photo.png</code>作为<code>file</code>字段上传。</p>
<pre><code> curl -F 'file=@photo.png' https://google.com/profile
</code></pre>
<p><code>-F</code>参数可以指定 MIME 类型。</p>
<pre><code>$ curl -F 'file=@photo.png;type=image/png' https://google.com/profile
</code></pre>
<p><strong>指定文件名</strong></p>
<pre><code>$ curl -F 'file=@photo.png;filename=me.png' https://google.com/profile
</code></pre>
<h1 id="构造url查询字符串"><a class="header" href="#构造url查询字符串">构造URL查询字符串</a></h1>
<pre><code>$ curl -G -d 'q=kitties' -d 'count=20' https://google.com/search
</code></pre>
<p>上面命令会发出一个 GET 请求，实际请求的 URL 为<code>https://google.com/search?q=kitties&amp;count=20</code>。如果省略<code>-G</code>，会发出一个 POST 请求。</p>
<p>如果数据需要 URL 编码，可以结合<code>--data--urlencode</code>参数。</p>
<pre><code class="language-sh">$ curl -G --data-urlencode 'comment=hello world' https://www.example.com
</code></pre>
<h1 id="跳过-ssl-检测"><a class="header" href="#跳过-ssl-检测">跳过 SSL 检测</a></h1>
<p>-k</p>
<pre><code class="language-sh">$ curl -k https://www.example.com
</code></pre>
<h1 id="限制-http-请求和回应的带宽"><a class="header" href="#限制-http-请求和回应的带宽">限制 HTTP 请求和回应的带宽</a></h1>
<p><strong>模拟慢网速的环境</strong></p>
<pre><code class="language-sh">$ curl --limit-rate 200k https://google.com
</code></pre>
<h1 id="将服务器的回应保存成文件"><a class="header" href="#将服务器的回应保存成文件">将服务器的回应保存成文件</a></h1>
<p>并将 URL 的最后部分当作文件名。</p>
<pre><code class="language-sh">curl -o example.html https://www.example.com
</code></pre>
<h1 id="设置服务器认证的用户名和密码"><a class="header" href="#设置服务器认证的用户名和密码">设置服务器认证的用户名和密码</a></h1>
<pre><code class="language-sh">$ curl -u 'bob:12345' https://google.com/login
</code></pre>
<h1 id="指定-http-请求的代理"><a class="header" href="#指定-http-请求的代理">指定 HTTP 请求的代理。</a></h1>
<blockquote>
<p>-x</p>
</blockquote>
<pre><code class="language-sh">$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-2"><a class="header" href="#简介-2">简介</a></h1>
<p>dd，是 device driver 的缩写，它可以称得上是“Linux 世界中的搬运工”，它用来读取设备、文件中的内容，并原封不动地复制到指定位置。</p>
<h1 id="语法-3"><a class="header" href="#语法-3">语法</a></h1>
<p><strong>dd [OPERAND]...</strong></p>
<p><strong>dd OPTION</strong></p>
<p>copy一个文件 并 根据 操作 转换 与格式化</p>
<table><thead><tr><th>OPERAND</th><th>说明</th><th>英文</th></tr></thead><tbody>
<tr><td>bs=BYTES</td><td>一次读取和写入的 字节数</td><td>read and write up to BYTES bytes at a time</td></tr>
<tr><td>cbs=BYTES</td><td>一次转换的字节个数</td><td>convert BYTES bytes at a time</td></tr>
<tr><td>conv=CONVS</td><td>转换标志</td><td>convert the file as per the comma separated symbol list</td></tr>
<tr><td>count=N</td><td>仅复制 N 个输入块</td><td>copy only N input blocks</td></tr>
<tr><td>ibs=BYTES</td><td>一次最多读取 BYTES 个字节（默认值：512）</td><td>read up to BYTES bytes at a time (default: 512)</td></tr>
<tr><td>if=FILE</td><td>从文件读数据</td><td>read from FILE instead of stdin</td></tr>
<tr><td>iflag=FLAGS</td><td>输入标志，按照逗号分隔的符号列表读取</td><td>read as per the comma separated symbol list</td></tr>
<tr><td>obs=BYTES</td><td>一次最多写入 BYTES 个字节（默认值：512）</td><td>write BYTES bytes at a time (default: 512)</td></tr>
<tr><td>of=FILE</td><td>写入文件</td><td>write to FILE instead of stdout</td></tr>
<tr><td>oflag=FLAGS</td><td>输出标志</td><td>write as per the comma separated symbol list</td></tr>
<tr><td>seek=N</td><td>在输出开始时跳过 N 个 obs 大小的块</td><td>skip N obs-sized blocks at start of output</td></tr>
<tr><td>skip=N</td><td>在输入开始时跳过 N 个 ibs 大小的块</td><td>skip N ibs-sized blocks at start of input</td></tr>
<tr><td>status=LEVEL</td><td>要打印到 stderr 的信息级别；</td><td>'none' suppresses everything but error messages,<br /> 'noxfer' suppresses the final transfer statistics,<br />'progress' shows periodic transfer statistics</td></tr>
</tbody></table>
<h1 id="单位"><a class="header" href="#单位">单位</a></h1>
<p>N 和 BYTES 后面可以跟以下乘法后缀：</p>
<pre><code>c =1, w =2, b =512, kB =1000, K =1024, MB =1000*1000, M =1024*1024, xM =M
GB =1000*1000*1000, G =1024*1024*1024, and so on for T, P, E, Z, Y.
</code></pre>
<h1 id="转换标志"><a class="header" href="#转换标志">转换标志</a></h1>
<pre><code>ascii     from EBCDIC to ASCII
ebcdic    from ASCII to EBCDIC
ibm       from ASCII to alternate EBCDIC
block     pad newline-terminated records with spaces to cbs-size
unblock   replace trailing spaces in cbs-size records with newline
lcase     change upper case to lower case
ucase     change lower case to upper case
sparse    try to seek rather than write the output for NUL input blocks
swab      swap every pair of input bytes
sync      pad every input block with NULs to ibs-size; when used
            with block or unblock, pad with spaces rather than NULs

excl      fail if the output file already exists
nocreat   do not create the output file
notrunc   do not truncate the output file
noerror   continue after read errors
fdatasync  physically write output file data before finishing
fsync     likewise, but also write metadata


</code></pre>
<h1 id="输入输出标志"><a class="header" href="#输入输出标志">输入输出标志</a></h1>
<pre><code>append    append mode (makes sense only for output; conv=notrunc suggested)
direct    use direct I/O for data
directory  fail unless a directory
dsync     use synchronized I/O for data
sync      likewise, but also for metadata
fullblock  accumulate full blocks of input (iflag only)
nonblock  use non-blocking I/O
noatime   do not update access time
nocache   discard cached data
noctty    do not assign controlling terminal from file
nofollow  do not follow symlinks
count_bytes  treat 'count=N' as a byte count (iflag only)
skip_bytes  treat 'skip=N' as a byte count (iflag only)
seek_bytes  treat 'seek=N' as a byte count (oflag only)


</code></pre>
<h1 id="发送-usr信号"><a class="header" href="#发送-usr信号">发送 USR信号</a></h1>
<p>Sending a USR1 signal to a running 'dd' process makes it</p>
<p>print I/O statistics to standard error and then resume copying.</p>
<pre><code>$ dd if=/dev/zero of=/dev/null&amp; pid=$!
$ kill -USR1 $pid; sleep 1; kill $pid
</code></pre>
<pre><code>18335302+0 records in
18335302+0 records out
9387674624 bytes (9.4 GB) copied, 34.6279 seconds, 271 MB/s
</code></pre>
<h1 id="使用案例"><a class="header" href="#使用案例">使用案例</a></h1>
<h2 id="备份磁盘并恢复"><a class="header" href="#备份磁盘并恢复">备份磁盘并恢复</a></h2>
<pre><code class="language-sh"># 这个命令将 sda 盘备份到指定文件 /root/sda.img 中去，其中用到了如下两个选项：
#if=文件名：指定输入文件名或者设备名，如果省略“if=文件名”，则表示从标准输入读取。
#of=文件名：指定输出文件名或者设备名，如果省略“of=文件名”，则表示写到标准输出。
dd if=/dev/sda of=/root/sda.img
</code></pre>
<p>通过上面的 dd 命令，我们得到了 sda.img 文件，它就是已经备份好了的磁盘映像文件，里面存储着 /dev/sda 整块硬盘的内容。</p>
<p>假如 /dev/sda 硬盘真的出现了故障，我们就可以将曾经备份的 sda.img 复制到另一台电脑上，并将其恢复到指定的 sdb 盘中去。</p>
<pre><code class="language-sh"> dd if=/root/sda.img of=/dev/sdb
</code></pre>
<h2 id="备份时进行压缩"><a class="header" href="#备份时进行压缩">备份时进行压缩</a></h2>
<pre><code class="language-sh">dd if=/dev/sda | gzip &gt; /root/sda.img.gz
dd if=/dev/sda | bzip2 &gt; disk.img.bz2
bzip2 -dc /root/sda.img.gz | dd of=/dev/sdc
</code></pre>
<h2 id="备份磁盘的-mbr"><a class="header" href="#备份磁盘的-mbr">备份磁盘的 MBR</a></h2>
<p>MBR，是 Master Boot Record，即硬盘的主引导记录，MBR 一旦损坏，分区表也就被破坏，数据大量丢失，系统就再也无法正常引导了</p>
<pre><code class="language-sh">dd if=/dev/sda of=/root/sda_mbr.img count=1 bs=512
dd if=/root/sda_mbr.img of=/dev/sda
</code></pre>
<h2 id="使用-devzero-和-devnull-来测试磁盘"><a class="header" href="#使用-devzero-和-devnull-来测试磁盘">使用 /dev/zero 和 /dev/null 来测试磁盘</a></h2>
<ul>
<li>/dev/null，也叫空设备，小名“无底洞”。任何写入它的数据都会被无情抛弃。</li>
<li>/dev/zero，可以产生连续不断的 null 的流（二进制的零流），用于向设备或文件写入 null 数据，一般用它来对设备或文件进行初始化。</li>
<li>/dev/urandom  它是“随机数设备”，它的本领就是可以生成理论意义上的随机数。</li>
</ul>
<pre><code>dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file
dd if=/root/1Gb.file bs=64k | dd of=/dev/null
time dd if=/dev/zero bs=1024 count=1000000 of=/root/1Gb.file
time dd if=/dev/zero bs=2048 count=500000 of=/root/1Gb.file
time dd if=/dev/zero bs=4096 count=250000 of=/root/1Gb.file


dd if=/dev/urandom of=/dev/sda
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h3 id="diff-patch"><a class="header" href="#diff-patch">Diff Patch</a></h3>
<p>diff 和 patch。diff 和 patch 是一对工具，使用这对工具可以获取更新文件与历史文件的差异，并将更新应用到历史文件上。在数学上说，diff就是对两个集合的差运算，patch就是对两个集合的和运算。</p>
<h3 id="diff"><a class="header" href="#diff">Diff</a></h3>
<pre><code>DIFF(1) 			  User Commands 			 DIFF(1)

NAME
       diff - compare files line by line

SYNOPSIS
       diff [OPTION]... FILES

DESCRIPTION
       Compare files line by line.

       -i  --ignore-case //忽略大小写
	      Ignore case differences in file contents.

       --ignore-file-name-case //忽略文件名
	      Ignore case when comparing file names.

       --no-ignore-file-name-case //不忽略
	      Consider case when comparing file names.

       -E  --ignore-tab-expansion //忽略TAB
	      Ignore changes due to tab expansion.

       -b  --ignore-space-change //忽略空格
	      Ignore changes in the amount of white space.

       -w  --ignore-all-space //忽略所有空格
	      Ignore all white space.

       -B  --ignore-blank-lines //忽略空行
	      Ignore changes whose lines are all blank.

       -I RE  --ignore-matching-lines=RE //忽略匹配的 RE
	      Ignore changes whose lines all match RE.

       --strip-trailing-cr 
	      Strip trailing carriage return on input.

       -a  --text
	      Treat all files as text.

       -c  -C NUM  --context[=NUM] 输出复制的上下文 默认三行
	      Output NUM (default 3) lines of copied context.

       -u  -U NUM  --unified[=NUM] 输出统一的上下文
	      Output NUM (default 3) lines of unified context.

       --label LABEL
	      Use LABEL instead of file name.

       -p  --show-c-function
	      Show which C function each change is in.

       -F RE  --show-function-line=RE
	      Show the most recent line matching RE.

       -q  --brief
	      Output only whether files differ.

       -e  --ed 输出为ed脚本
	      Output an ed script.

       --normal 输出为 normal diff
	      Output a normal diff.

       -n  --rcs //输出为RCS 格式
	      Output an RCS format diff.

       -y  --side-by-side //输出两栏
	      Output in two columns.

       -W NUM  --width=NUM
	      Output at most NUM (default 130) print columns.

       --left-column
	      Output only the left column of common lines.

       --suppress-common-lines
	      Do not output common lines.

       -D NAME	--ifdef=NAME
	      Output merged file to show `#ifdef NAME' diffs.

       --GTYPE-group-format=GFMT
	      Similar, but format GTYPE input groups with GFMT.

       --line-format=LFMT
	      Similar, but format all input lines with LFMT.

       --LTYPE-line-format=LFMT
	      Similar, but format LTYPE input lines with LFMT.

       LTYPE is `old', `new', or `unchanged'.
	      GTYPE is LTYPE or `changed'.

	      GFMT may contain:

       %&lt;     lines from FILE1 //来自文件1

       %&gt;     lines from FILE2 //来自文件2

       %=     lines common to FILE1 and FILE2 //公共的

       %[-][WIDTH][.[PREC]]{doxX}LETTER
	      printf-style spec for LETTER

	      LETTERs are as follows for new group, lower case for old group:

       F      first line number

       L      last line number

       N      number of lines = L-F+1

       E      F-1

       M      L+1

	      LFMT may contain:

       %L     contents of line

       %l     contents of line, excluding any trailing newline

       %[-][WIDTH][.[PREC]]{doxX}n
	      printf-style spec for input line number

	      Either GFMT or LFMT may contain:

       %%     %

       %c'C'  the single character C

       %c'\OOO'
	      the character with octal code OOO

       -l  --paginate
	      Pass the output through `pr' to paginate it.

       -t  --expand-tabs
	      Expand tabs to spaces in output.

       -T  --initial-tab
	      Make tabs line up by prepending a tab.

       -r  --recursive
	      Recursively compare any subdirectories found.

       -N  --new-file
	      Treat absent files as empty.

       --unidirectional-new-file
	      Treat absent first files as empty.

       -s  --report-identical-files
	      Report when two files are the same.

       -x PAT  --exclude=PAT
	      Exclude files that match PAT.

       -X FILE	--exclude-from=FILE
	      Exclude files that match any pattern in FILE.

       -S FILE	--starting-file=FILE
	      Start with FILE when comparing directories.

       --from-file=FILE1
	      Compare FILE1 to all operands.  FILE1 can be a directory.

       --to-file=FILE2
	      Compare all operands to FILE2.  FILE2 can be a directory.

       --horizon-lines=NUM
	      Keep NUM lines of the common prefix and suffix.

       -d  --minimal
	      Try hard to find a smaller set of changes.

       --speed-large-files
	      Assume large files and many scattered small changes.

       -v  --version
	      Output version info.

       --help Output this help.

       FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'.
       If --from-file or --to-file is given, there are no restrictions on FILES.
       If a FILE is `-', read standard input.

AUTHOR
       Written by Paul Eggert, Mike Haertel, David Hayes, Richard Stallman, and
       Len Tower.

REPORTING BUGS
       Report bugs to &lt;bug-gnu-utils@gnu.org&gt;.

COPYRIGHT
       Copyright © 2002 Free Software Foundation, Inc.

       This program comes with NO WARRANTY, to the extent permitted by law.  You
       may redistribute copies of this program under the terms of the GNU
       General Public License.	For more information about these matters, see
       the file named COPYING.

SEE ALSO
       The full documentation for diff is maintained as a Texinfo manual.  If
       the info and diff programs are properly installed at your site, the
       command

	      info diff

       should give you access to the complete manual.



diffutils 2.8.1 		   April 2002				 DIFF(1)

</code></pre>
<h2 id="patch"><a class="header" href="#patch">Patch</a></h2>
<pre><code>PATCH(1)		     General Commands Manual			PATCH(1)



NAME
       patch - apply a diff file to an original

SYNOPSIS
       patch [options] [originalfile [patchfile]]

       but usually just

       patch -pnum &lt;patchfile

DESCRIPTION
       patch takes a patch file patchfile containing a difference listing
       produced by the diff program and applies those differences to one or more
       original files, producing patched versions.  Normally the patched
       versions are put in place of the originals.  Backups can be made; see the
       -b or --backup option.  The names of the files to be patched are usually
       taken from the patch file, but if there's just one file to be patched it
       can specified on the command line as originalfile.

       Upon startup, patch attempts to determine the type of the diff listing,
       unless overruled by a -c (--context), -e (--ed), -n (--normal), or -u
       (--unified) option.  Context diffs (old-style, new-style, and unified)
       and normal diffs are applied by the patch program itself, while ed diffs
       are simply fed to the ed(1) editor via a pipe.

       patch tries to skip any leading garbage, apply the diff, and then skip
       any trailing garbage.  Thus you could feed an article or message
       containing a diff listing to patch, and it should work.	If the entire
       diff is indented by a consistent amount, or if a context diff contains
       lines ending in CRLF or is encapsulated one or more times by prepending
       &quot;- &quot; to lines starting with &quot;-&quot; as specified by Internet RFC 934, this is
       taken into account.  After removing indenting or encapsulation, lines
       beginning with # are ignored, as they are considered to be comments.

       With context diffs, and to a lesser extent with normal diffs, patch can
       detect when the line numbers mentioned in the patch are incorrect, and
       attempts to find the correct place to apply each hunk of the patch.  As a
       first guess, it takes the line number mentioned for the hunk, plus or
       minus any offset used in applying the previous hunk.  If that is not the
       correct place, patch scans both forwards and backwards for a set of lines
       matching the context given in the hunk.	First patch looks for a place
       where all lines of the context match.  If no such place is found, and
       it's a context diff, and the maximum fuzz factor is set to 1 or more,
       then another scan takes place ignoring the first and last line of
       context.  If that fails, and the maximum fuzz factor is set to 2 or more,
       the first two and last two lines of context are ignored, and another scan
       is made.  (The default maximum fuzz factor is 2.)  If patch cannot find a
       place to install that hunk of the patch, it puts the hunk out to a reject
       file, which normally is the name of the output file plus a .rej suffix,
       or # if .rej would generate a file name that is too long (if even
       appending the single character # makes the file name too long, then #
       replaces the file name's last character).  (The rejected hunk comes out
       in ordinary context diff form regardless of the input patch's form.  If
       the input was a normal diff, many of the contexts are simply null.)  The
       line numbers on the hunks in the reject file may be different than in the
       patch file: they reflect the approximate location patch thinks the failed
       hunks belong in the new file rather than the old one.

       As each hunk is completed, you are told if the hunk failed, and if so
       which line (in the new file) patch thought the hunk should go on.  If the
       hunk is installed at a different line from the line number specified in
       the diff you are told the offset.  A single large offset may indicate
       that a hunk was installed in the wrong place.  You are also told if a
       fuzz factor was used to make the match, in which case you should also be
       slightly suspicious.  If the --verbose option is given, you are also told
       about hunks that match exactly.

       If no original file origfile is specified on the command line, patch
       tries to figure out from the leading garbage what the name of the file to
       edit is, using the following rules.

       First, patch takes an ordered list of candidate file names as follows:

	• If the header is that of a context diff, patch takes the old and new
	  file names in the header.  A name is ignored if it does not have
	  enough slashes to satisfy the -pnum or --strip=num option.  The name
	  /dev/null is also ignored.

	• If there is an Index: line in the leading garbage and if either the
	  old and new names are both absent or if patch is conforming to POSIX,
	  patch takes the name in the Index: line.

	• For the purpose of the following rules, the candidate file names are
	  considered to be in the order (old, new, index), regardless of the
	  order that they appear in the header.

       Then patch selects a file name from the candidate list as follows:

	• If some of the named files exist, patch selects the first name if
	  conforming to POSIX, and the best name otherwise.

	• If patch is not ignoring RCS, ClearCase, Perforce, and SCCS (see the
	  -g num or --get=num option), and no named files exist but an RCS,
	  ClearCase, Perforce, or SCCS master is found, patch selects the first
	  named file with an RCS, ClearCase, Perforce, or SCCS master.

	• If no named files exist, no RCS, ClearCase, Perforce, or SCCS master
	  was found, some names are given, patch is not conforming to POSIX, and
	  the patch appears to create a file, patch selects the best name
	  requiring the creation of the fewest directories.

	• If no file name results from the above heuristics, you are asked for
	  the name of the file to patch, and patch selects that name.

       To determine the best of a nonempty list of file names, patch first takes
       all the names with the fewest path name components; of those, it then
       takes all the names with the shortest basename; of those, it then takes
       all the shortest names; finally, it takes the first remaining name.

       Additionally, if the leading garbage contains a Prereq: line, patch takes
       the first word from the prerequisites line (normally a version number)
       and checks the original file to see if that word can be found.  If not,
       patch asks for confirmation before proceeding.

       The upshot of all this is that you should be able to say, while in a news
       interface, something like the following:

	  | patch -d /usr/src/local/blurfl

       and patch a file in the blurfl directory directly from the article
       containing the patch.

       If the patch file contains more than one patch, patch tries to apply each
       of them as if they came from separate patch files.  This means, among
       other things, that it is assumed that the name of the file to patch must
       be determined for each diff listing, and that the garbage before each
       diff listing contains interesting things such as file names and revision
       level, as mentioned previously.

OPTIONS
       -b  or  --backup
	  Make backup files.  That is, when patching a file, rename or copy the
	  original instead of removing it.  When backing up a file that does not
	  exist, an empty, unreadable backup file is created as a placeholder to
	  represent the nonexistent file.  See the -V or --version-control
	  option for details about how backup file names are determined.

       --backup-if-mismatch
	  Back up a file if the patch does not match the file exactly and if
	  backups are not otherwise requested.	This is the default unless patch
	  is conforming to POSIX.

       --no-backup-if-mismatch
	  Do not back up a file if the patch does not match the file exactly and
	  if backups are not otherwise requested.  This is the default if patch
	  is conforming to POSIX.

       -B pref	or  --prefix=pref
	  Prefix pref to a file name when generating its simple backup file
	  name.  For example, with -B /junk/ the simple backup file name for
	  src/patch/util.c is /junk/src/patch/util.c.

       --binary
	  Read and write all files in binary mode, except for standard output
	  and /dev/tty.  This option has no effect on POSIX-conforming systems.
	  On systems like DOS where this option makes a difference, the patch
	  should be generated by diff -a --binary.

       -c  or  --context
	  Interpret the patch file as a ordinary context diff.

       -d dir  or  --directory=dir
	  Change to the directory dir immediately, before doing anything else.

       -D define  or  --ifdef=define
	  Use the #ifdef ... #endif construct to mark changes, with define as
	  the differentiating symbol.

       --dry-run
	  Print the results of applying the patches without actually changing
	  any files.

       -e  or  --ed
	  Interpret the patch file as an ed script.

       -E  or  --remove-empty-files
	  Remove output files that are empty after the patches have been
	  applied.  Normally this option is unnecessary, since patch can examine
	  the time stamps on the header to determine whether a file should exist
	  after patching.  However, if the input is not a context diff or if
	  patch is conforming to POSIX, patch does not remove empty patched
	  files unless this option is given.  When patch removes a file, it also
	  attempts to remove any empty ancestor directories.

       -f  or  --force
	  Assume that the user knows exactly what he or she is doing, and do not
	  ask any questions.  Skip patches whose headers do not say which file
	  is to be patched; patch files even though they have the wrong version
	  for the Prereq: line in the patch; and assume that patches are not
	  reversed even if they look like they are.  This option does not
	  suppress commentary; use -s for that.

       -F num  or  --fuzz=num
	  Set the maximum fuzz factor.	This option only applies to diffs that
	  have context, and causes patch to ignore up to that many lines in
	  looking for places to install a hunk.  Note that a larger fuzz factor
	  increases the odds of a faulty patch.  The default fuzz factor is 2,
	  and it may not be set to more than the number of lines of context in
	  the context diff, ordinarily 3.

       -g num  or  --get=num
	  This option controls patch's actions when a file is under RCS or SCCS
	  control, and does not exist or is read-only and matches the default
	  version, or when a file is under ClearCase or Perforce control and
	  does not exist.  If num is positive, patch gets (or checks out) the
	  file from the revision control system; if zero, patch ignores RCS,
	  ClearCase, Perforce, and SCCS and does not get the file; and if
	  negative, patch asks the user whether to get the file.  The default
	  value of this option is given by the value of the PATCH_GET
	  environment variable if it is set; if not, the default value is zero
	  if patch is conforming to POSIX, negative otherwise.

       --help
	  Print a summary of options and exit.

       -i patchfile  or  --input=patchfile
	  Read the patch from patchfile.  If patchfile is -, read from standard
	  input, the default.

       -l  or  --ignore-whitespace
	  Match patterns loosely, in case tabs or spaces have been munged in
	  your files.  Any sequence of one or more blanks in the patch file
	  matches any sequence in the original file, and sequences of blanks at
	  the ends of lines are ignored.  Normal characters must still match
	  exactly.  Each line of the context must still match a line in the
	  original file.

       -n  or  --normal
	  Interpret the patch file as a normal diff.

       -N  or  --forward
	  Ignore patches that seem to be reversed or already applied.  See also
	  -R.

       -o outfile  or  --output=outfile
	  Send output to outfile instead of patching files in place.  Do not use
	  this option if outfile is one of the files to be patched.

       -pnum  or  --strip=num
	  Strip the smallest prefix containing num leading slashes from each
	  file name found in the patch file.  A sequence of one or more adjacent
	  slashes is counted as a single slash.  This controls how file names
	  found in the patch file are treated, in case you keep your files in a
	  different directory than the person who sent out the patch.  For
	  example, supposing the file name in the patch file was

	     /u/howard/src/blurfl/blurfl.c

	  setting -p0 gives the entire file name unmodified, -p1 gives

	     u/howard/src/blurfl/blurfl.c

	  without the leading slash, -p4 gives

	     blurfl/blurfl.c

	  and not specifying -p at all just gives you blurfl.c.  Whatever you
	  end up with is looked for either in the current directory, or the
	  directory specified by the -d option.

       --posix
	  Conform more strictly to the POSIX standard, as follows.

	   • Take the first existing file from the list (old, new, index) when
	     intuiting file names from diff headers.

	   • Do not remove files that are empty after patching.

	   • Do not ask whether to get files from RCS, ClearCase, Perforce, or
	     SCCS.

	   • Require that all options precede the files in the command line.

	   • Do not backup files when there is a mismatch.

       --quoting-style=word
	  Use style word to quote output names.  The word should be one of the
	  following:

	  literal
		 Output names as-is.

	  shell  Quote names for the shell if they contain shell metacharacters
		 or would cause ambiguous output.

	  shell-always
		 Quote names for the shell, even if they would normally not
		 require quoting.

	  c	 Quote names as for a C language string.

	  escape Quote as with c except omit the surrounding double-quote
		 characters.

	  You can specify the default value of the --quoting-style option with
	  the environment variable QUOTING_STYLE.  If that environment variable
	  is not set, the default value is shell.

       -r rejectfile  or  --reject-file=rejectfile
	  Put rejects into rejectfile instead of the default .rej file.

       -R  or  --reverse
	  Assume that this patch was created with the old and new files swapped.
	  (Yes, I'm afraid that does happen occasionally, human nature being
	  what it is.)	patch attempts to swap each hunk around before applying
	  it.  Rejects come out in the swapped format.	The -R option does not
	  work with ed diff scripts because there is too little information to
	  reconstruct the reverse operation.

	  If the first hunk of a patch fails, patch reverses the hunk to see if
	  it can be applied that way.  If it can, you are asked if you want to
	  have the -R option set.  If it can't, the patch continues to be
	  applied normally.  (Note: this method cannot detect a reversed patch
	  if it is a normal diff and if the first command is an append (i.e. it
	  should have been a delete) since appends always succeed, due to the
	  fact that a null context matches anywhere.  Luckily, most patches add
	  or change lines rather than delete them, so most reversed normal diffs
	  begin with a delete, which fails, triggering the heuristic.)

       -s  or  --silent  or  --quiet
	  Work silently, unless an error occurs.

       -t  or  --batch
	  Suppress questions like -f, but make some different assumptions: skip
	  patches whose headers do not contain file names (the same as -f); skip
	  patches for which the file has the wrong version for the Prereq: line
	  in the patch; and assume that patches are reversed if they look like
	  they are.

       -T  or  --set-time
	  Set the modification and access times of patched files from time
	  stamps given in context diff headers, assuming that the context diff
	  headers use local time.  This option is not recommended, because
	  patches using local time cannot easily be used by people in other time
	  zones, and because local time stamps are ambiguous when local clocks
	  move backwards during daylight-saving time adjustments.  Instead of
	  using this option, generate patches with UTC and use the -Z or
	  --set-utc option instead.

       -u  or  --unified
	  Interpret the patch file as a unified context diff.

       -v  or  --version
	  Print out patch's revision header and patch level, and exit.

       -V method  or  --version-control=method
	  Use method to determine backup file names.  The method can also be
	  given by the PATCH_VERSION_CONTROL (or, if that's not set, the
	  VERSION_CONTROL) environment variable, which is overridden by this
	  option.  The method does not affect whether backup files are made; it
	  affects only the names of any backup files that are made.

	  The value of method is like the GNU Emacs `version-control' variable;
	  patch also recognizes synonyms that are more descriptive.  The valid
	  values for method are (unique abbreviations are accepted):

	  existing  or	nil
	     Make numbered backups of files that already have them, otherwise
	     simple backups.  This is the default.

	  numbered  or	t
	     Make numbered backups.  The numbered backup file name for F is
	     F.~N~ where N is the version number.

	  simple  or  never
	     Make simple backups.  The -B or --prefix, -Y or --basename-prefix,
	     and -z or --suffix options specify the simple backup file name.  If
	     none of these options are given, then a simple backup suffix is
	     used; it is the value of the SIMPLE_BACKUP_SUFFIX environment
	     variable if set, and is .orig otherwise.

	  With numbered or simple backups, if the backup file name is too long,
	  the backup suffix ~ is used instead; if even appending ~ would make
	  the name too long, then ~ replaces the last character of the file
	  name.

       --verbose
	  Output extra information about the work being done.

       -x num  or  --debug=num
	  Set internal debugging flags of interest only to patch patchers.

       -Y pref	or  --basename-prefix=pref
	  Prefix pref to the basename of a file name when generating its simple
	  backup file name.  For example, with -Y .del/ the simple backup file
	  name for src/patch/util.c is src/patch/.del/util.c.

       -z suffix  or  --suffix=suffix
	  Use suffix as the simple backup suffix.  For example, with -z - the
	  simple backup file name for src/patch/util.c is src/patch/util.c-.
	  The backup suffix may also be specified by the SIMPLE_BACKUP_SUFFIX
	  environment variable, which is overridden by this option.

       -Z  or  --set-utc
	  Set the modification and access times of patched files from time
	  stamps given in context diff headers, assuming that the context diff
	  headers use Coordinated Universal Time (UTC, often known as GMT).
	  Also see the -T or --set-time option.

	  The -Z or --set-utc and -T or --set-time options normally refrain from
	  setting a file's time if the file's original time does not match the
	  time given in the patch header, or if its contents do not match the
	  patch exactly.  However, if the -f or --force option is given, the
	  file time is set regardless.

	  Due to the limitations of diff output format, these options cannot
	  update the times of files whose contents have not changed.  Also, if
	  you use these options, you should remove (e.g. with make clean) all
	  files that depend on the patched files, so that later invocations of
	  make do not get confused by the patched files' times.

ENVIRONMENT
       PATCH_GET
	  This specifies whether patch gets missing or read-only files from RCS,
	  ClearCase, Perforce, or SCCS by default; see the -g or --get option.

       POSIXLY_CORRECT
	  If set, patch conforms more strictly to the POSIX standard by default:
	  see the --posix option.

       QUOTING_STYLE
	  Default value of the --quoting-style option.

       SIMPLE_BACKUP_SUFFIX
	  Extension to use for simple backup file names instead of .orig.

       TMPDIR, TMP, TEMP
	  Directory to put temporary files in; patch uses the first environment
	  variable in this list that is set.  If none are set, the default is
	  system-dependent; it is normally /tmp on Unix hosts.

       VERSION_CONTROL or PATCH_VERSION_CONTROL
	  Selects version control style; see the -v or --version-control option.

FILES
       $TMPDIR/p∗
	  temporary files

       /dev/tty
	  controlling terminal; used to get answers to questions asked of the
	  user

SEE ALSO
       diff(1), ed(1)

       Marshall T. Rose and Einar A. Stefferud, Proposed Standard for Message
       Encapsulation, Internet RFC 934 &lt;URL:ftp://ftp.isi.edu/in-
       notes/rfc934.txt&gt; (1985-01).

NOTES FOR PATCH SENDERS
       There are several things you should bear in mind if you are going to be
       sending out patches.

       Create your patch systematically.  A good method is the command
       diff -Naur old_new where old and new identify the old and new
       directories.  The names old and new should not contain any slashes.  The
       diff command's headers should have dates and times in Universal Time
       using traditional Unix format, so that patch recipients can use the -Z or
       --set-utc option.  Here is an example command, using Bourne shell syntax:

	  LC_ALL=C TZ=UTC0 diff -Naur gcc-2.7 gcc-2.8

       Tell your recipients how to apply the patch by telling them which
       directory to cd to, and which patch options to use.  The option string
       -Np1 is recommended.  Test your procedure by pretending to be a recipient
       and applying your patch to a copy of the original files.

       You can save people a lot of grief by keeping a patchlevel.h file which
       is patched to increment the patch level as the first diff in the patch
       file you send out.  If you put a Prereq: line in with the patch, it won't
       let them apply patches out of order without some warning.

       You can create a file by sending out a diff that compares /dev/null or an
       empty file dated the Epoch (1970-01-01 00:00:00 UTC) to the file you want
       to create.  This only works if the file you want to create doesn't exist
       already in the target directory.  Conversely, you can remove a file by
       sending out a context diff that compares the file to be deleted with an
       empty file dated the Epoch.  The file will be removed unless patch is
       conforming to POSIX and the -E or --remove-empty-files option is not
       given.  An easy way to generate patches that create and remove files is
       to use GNU diff's -N or --new-file option.

       If the recipient is supposed to use the -pN option, do not send output
       that looks like this:

	  diff -Naur v2.0.29/prog/README prog/README
	  --- v2.0.29/prog/README   Mon Mar 10 15:13:12 1997
	  +++ prog/README   Mon Mar 17 14:58:22 1997

       because the two file names have different numbers of slashes, and
       different versions of patch interpret the file names differently.  To
       avoid confusion, send output that looks like this instead:

	  diff -Naur v2.0.29/prog/README v2.0.30/prog/README
	  --- v2.0.29/prog/README   Mon Mar 10 15:13:12 1997
	  +++ v2.0.30/prog/README   Mon Mar 17 14:58:22 1997


       Avoid sending patches that compare backup file names like README.orig,
       since this might confuse patch into patching a backup file instead of the
       real file.  Instead, send patches that compare the same base file names
       in different directories, e.g. old/README and new/README.

       Take care not to send out reversed patches, since it makes people wonder
       whether they already applied the patch.

       Try not to have your patch modify derived files (e.g. the file configure
       where there is a line configure: configure.in in your makefile), since
       the recipient should be able to regenerate the derived files anyway.  If
       you must send diffs of derived files, generate the diffs using UTC, have
       the recipients apply the patch with the -Z or --set-utc option, and have
       them remove any unpatched files that depend on patched files (e.g. with
       make clean).

       While you may be able to get away with putting 582 diff listings into one
       file, it may be wiser to group related patches into separate files in
       case something goes haywire.

DIAGNOSTICS
       Diagnostics generally indicate that patch couldn't parse your patch file.

       If the --verbose option is given, the message Hmm... indicates that there
       is unprocessed text in the patch file and that patch is attempting to
       intuit whether there is a patch in that text and, if so, what kind of
       patch it is.

       patch's exit status is 0 if all hunks are applied successfully, 1 if some
       hunks cannot be applied, and 2 if there is more serious trouble.  When
       applying a set of patches in a loop it behooves you to check this exit
       status so you don't apply a later patch to a partially patched file.

CAVEATS
       Context diffs cannot reliably represent the creation or deletion of empty
       files, empty directories, or special files such as symbolic links.  Nor
       can they represent changes to file metadata like ownership, permissions,
       or whether one file is a hard link to another.  If changes like these are
       also required, separate instructions (e.g. a shell script) to accomplish
       them should accompany the patch.

       patch cannot tell if the line numbers are off in an ed script, and can
       detect bad line numbers in a normal diff only when it finds a change or
       deletion.  A context diff using fuzz factor 3 may have the same problem.
       Until a suitable interactive interface is added, you should probably do a
       context diff in these cases to see if the changes made sense.  Of course,
       compiling without errors is a pretty good indication that the patch
       worked, but not always.

       patch usually produces the correct results, even when it has to do a lot
       of guessing.  However, the results are guaranteed to be correct only when
       the patch is applied to exactly the same version of the file that the
       patch was generated from.

COMPATIBILITY ISSUES
       The POSIX standard specifies behavior that differs from patch's
       traditional behavior.  You should be aware of these differences if you
       must interoperate with patch versions 2.1 and earlier, which do not
       conform to POSIX.

	• In traditional patch, the -p option's operand was optional, and a bare
	  -p was equivalent to -p0.  The -p option now requires an operand, and
	  -p 0 is now equivalent to -p0.  For maximum compatibility, use options
	  like -p0 and -p1.

	  Also, traditional patch simply counted slashes when stripping path
	  prefixes; patch now counts pathname components.  That is, a sequence
	  of one or more adjacent slashes now counts as a single slash.  For
	  maximum portability, avoid sending patches containing // in file
	  names.

	• In traditional patch, backups were enabled by default.  This behavior
	  is now enabled with the -b or --backup option.

	  Conversely, in POSIX patch, backups are never made, even when there is
	  a mismatch.  In GNU patch, this behavior is enabled with the
	  --no-backup-if-mismatch option, or by conforming to POSIX with the
	  --posix option or by setting the POSIXLY_CORRECT environment variable.

	  The -b_suffix option of traditional patch is equivalent to the
	  -b -z_suffix options of GNU patch.

	• Traditional patch used a complicated (and incompletely documented)
	  method to intuit the name of the file to be patched from the patch
	  header.  This method did not conform to POSIX, and had a few gotchas.
	  Now patch uses a different, equally complicated (but better
	  documented) method that is optionally POSIX-conforming; we hope it has
	  fewer gotchas.  The two methods are compatible if the file names in
	  the context diff header and the Index: line are all identical after
	  prefix-stripping.  Your patch is normally compatible if each header's
	  file names all contain the same number of slashes.

	• When traditional patch asked the user a question, it sent the question
	  to standard error and looked for an answer from the first file in the
	  following list that was a terminal: standard error, standard output,
	  /dev/tty, and standard input.  Now patch sends questions to standard
	  output and gets answers from /dev/tty.  Defaults for some answers have
	  been changed so that patch never goes into an infinite loop when using
	  default answers.

	• Traditional patch exited with a status value that counted the number
	  of bad hunks, or with status 1 if there was real trouble.  Now patch
	  exits with status 1 if some hunks failed, or with 2 if there was real
	  trouble.

	• Limit yourself to the following options when sending instructions
	  meant to be executed by anyone running GNU patch, traditional patch,
	  or a patch that conforms to POSIX.  Spaces are significant in the
	  following list, and operands are required.

	     -c
	     -d dir
	     -D define
	     -e
	     -l
	     -n
	     -N
	     -o outfile
	     -pnum
	     -R
	     -r rejectfile

BUGS
       Please report bugs via email to &lt;bug-patch@gnu.org&gt;.

       patch could be smarter about partial matches, excessively deviant offsets
       and swapped code, but that would take an extra pass.

       If code has been duplicated (for instance with #ifdef OLDCODE ... #else
       ... #endif), patch is incapable of patching both versions, and, if it
       works at all, will likely patch the wrong one, and tell you that it
       succeeded to boot.

       If you apply a patch you've already applied, patch thinks it is a
       reversed patch, and offers to un-apply the patch.  This could be
       construed as a feature.

COPYING
       Copyright (C) 1984, 1985, 1986, 1988 Larry Wall.
       Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
       1999, 2000, 2001, 2002 Free Software Foundation, Inc.

       Permission is granted to make and distribute verbatim copies of this
       manual provided the copyright notice and this permission notice are
       preserved on all copies.

       Permission is granted to copy and distribute modified versions of this
       manual under the conditions for verbatim copying, provided that the
       entire resulting derived work is distributed under the terms of a
       permission notice identical to this one.

       Permission is granted to copy and distribute translations of this manual
       into another language, under the above conditions for modified versions,
       except that this permission notice may be included in translations
       approved by the copyright holders instead of in the original English.

AUTHORS
       Larry Wall wrote the original version of patch.	Paul Eggert removed
       patch's arbitrary limits; added support for binary files, setting file
       times, and deleting files; and made it conform better to POSIX.	Other
       contributors include Wayne Davison, who added unidiff support, and David
       MacKenzie, who added configuration and backup support.



GNU				   2003/05/08				PATCH(1)

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="按文件名称查找"><a class="header" href="#按文件名称查找">按文件名称查找</a></h1>
<p><strong>查找当前目录下所有 go 文件</strong></p>
<pre><code> find . -name &quot;*.go&quot;
</code></pre>
<p><strong>在 etc 目录下，查找大写字母开头的 txt 文件</strong></p>
<pre><code>find /etc -name &quot;[A-Z]*.txt&quot; -print
</code></pre>
<p><strong>在当前目录下查找不是 out 开头的 txt 文件</strong></p>
<pre><code>find . -name &quot;out*&quot; -prune -o -name &quot;*.txt&quot; -print
</code></pre>
<p><strong>在当前目录除 git 子目录外查找 txt 文件</strong></p>
<pre><code>find . -path &quot;./git&quot; -prune -o -name &quot;*.txt&quot; -print
</code></pre>
<p><strong>找出某个文件的所有硬链接，ls 命令 -i 选项可以查看文件的 inode 号</strong></p>
<pre><code>$ ls -i 1.txt
138956 1.txt
$ find . -num 138956
</code></pre>
<p>这里补充一个小技巧，搜索文件时使用 -iname 参数可以忽略文件名称大小写</p>
<h1 id="按文件类型查找"><a class="header" href="#按文件类型查找"><strong>按文件类型查找</strong></a></h1>
<p><strong>在当前目录下，查找软连接文件</strong></p>
<pre><code>find . -type l -print
</code></pre>
<p><strong>在当前目录下，查找 log 结尾的普通文件，f 表示普通文件类型</strong></p>
<pre><code> find . -type f -name &quot;*.log&quot;
</code></pre>
<h1 id="按文件大小查找"><a class="header" href="#按文件大小查找"><strong>按文件大小查找</strong></a></h1>
<p><strong>查找小于 64k 的文件</strong></p>
<pre><code>find . -size -64k -print
</code></pre>
<p><strong>查找大小超过 200M 的文件</strong></p>
<pre><code>find . -size +200M -type f -print
</code></pre>
<h1 id="按时间查找"><a class="header" href="#按时间查找"><strong>按时间查找</strong></a></h1>
<p><strong>查找 2 天内被修改过的文件</strong></p>
<pre><code>$ find . -mtime -2 -type f -print
</code></pre>
<p><strong>查找 2 天前被更改过的文件，-mtime 表示内容修改时间</strong></p>
<pre><code>find . -mtime +2 -type f -print
</code></pre>
<p><strong>查找一天内被访问的文件，-atime 表示访问时间</strong></p>
<pre><code> find . -atime -1 -type f -print
</code></pre>
<p><strong>查找一天内状态被改变的文件，-ctime 表示元数据被变化时间</strong></p>
<pre><code>find . -ctime -1 -type f -print
</code></pre>
<p><strong>查找比 chopin.txt 新的文件</strong></p>
<pre><code>$ find . -newer &quot;chopin.txt&quot; -type f -print
$ find . ! -newer &quot;chopin.txt&quot; -type f -print # 旧
</code></pre>
<h1 id="根据权限查找"><a class="header" href="#根据权限查找"><strong>根据权限查找</strong></a></h1>
<p><strong>查找当前目录权限为 644 的文件</strong></p>
<pre><code>find . -type f -perm 644
</code></pre>
<p><strong>查找 etc 目录下至少有一个用户有写权限的文件</strong></p>
<pre><code>find /etc -type f -perm /222
</code></pre>
<p><strong>查找 etc 目录下所有用户都有执行权限的文件</strong></p>
<pre><code> find /etc -perm -111 -ls
</code></pre>
<h1 id="组合条件"><a class="header" href="#组合条件"><strong>组合条件</strong></a></h1>
<p><strong>查找当前目录下属于 chopin 用户的普通文件，-a 可以省略</strong></p>
<pre><code> find . -type f -a -user chopin -print
</code></pre>
<p><strong>查找当前目录下大于 2M 或 2 天前被修过的文件</strong></p>
<pre><code>find . -size +2M -o -mtime +2 -print
</code></pre>
<p><strong>查找当前目录下不是普通文件</strong></p>
<pre><code>$ find . -not -type f
$ find . ! -type f
</code></pre>
<p><strong>查找非空文件</strong></p>
<pre><code>$ find . ! -empty
</code></pre>
<h1 id="处理动作"><a class="header" href="#处理动作"><strong>处理动作</strong></a></h1>
<p><strong>-print 默认为打印，可省略</strong></p>
<pre><code>$ find . -name &quot;*.log&quot; -print
$ find . -name &quot;*.log&quot; # 等价
</code></pre>
<p><strong>-ls 以 ls 长文件的格式形式输出</strong></p>
<pre><code>$ find . -name &quot;*.txt&quot; -ls
138957      4 -rw-r--r--   1 root     root           16 Jan 24 23:20 ./a.txt
138959      4 -rw-r--r--   1 root     root          172 Jan 24 13:06 ./T.txt
138956      4 -rw-r--r--   1 root     root           27 Jan 24 23:28 ./1.txt
</code></pre>
<p><strong>-delete 删除查找到的文件</strong></p>
<pre><code>$ find . -size +100M -delete
</code></pre>
<p><strong>-exec 将查找到的文件传递给 command 命令</strong></p>
<pre><code>$ find . -name &quot;*.txt&quot; -exec ls -lh {} \;
-rw-r--r-- 1 root root 16 Jan 24 23:20 ./a.txt
-rw-r--r-- 1 root root 172 Jan 24 13:06 ./T.txt
-rw-r--r-- 1 root root 27 Jan 24 23:28 ./1.txt
</code></pre>
<p>-ok 与 -exec 功能一样，只是操作时会提示用户确认，仅此而已。当然，在生产环境上，我们还是推荐使用 ok</p>
<h1 id="经典案例"><a class="header" href="#经典案例"><strong>经典案例</strong></a></h1>
<p>如果存在一个名称乱码的文件，想要删除它，该怎么办？即使我们复制乱码名称到命令行，很有可能终端不能正确识别。不用担心，下边来展示下 find 是如何优雅的解决问题的。</p>
<pre><code>$ ls  -i
138957 a.txt  138959 T.txt  132395 ڹ��.txt

$ find . -inum 132395 -exec rm {} \;
</code></pre>
<h1 id="总结归纳"><a class="header" href="#总结归纳">总结归纳</a></h1>
<h2 id="命令格式"><a class="header" href="#命令格式"><strong>命令格式</strong></a></h2>
<p><code>find path -option [-exec ...]</code></p>
<h2 id="不同维度查找"><a class="header" href="#不同维度查找">不同维度查找</a></h2>
<h3 id="按文件名查找"><a class="header" href="#按文件名查找"><strong>按文件名查找</strong></a></h3>
<ul>
<li>-name：按照文件名称查找，准确匹配；</li>
<li>-iname：不区分文件名的大小写；</li>
<li>-inode：按照文件 inode 号查找；</li>
</ul>
<h3 id="按照文件类型查找"><a class="header" href="#按照文件类型查找"><strong>按照文件类型查找</strong></a></h3>
<p>按照文件类型查找，可以使用 -type 选项，具体支持的文件类型如下：</p>
<ul>
<li>f：普通文件</li>
<li>d：目录文件</li>
<li>l：链接文件</li>
<li>s：套接字文件</li>
<li>p：管道文件</li>
<li>b：块设备文件，比如：磁盘</li>
<li>c：字符设备文件，比如：键盘、鼠标、网卡</li>
</ul>
<h3 id="按照文件从属关系查找"><a class="header" href="#按照文件从属关系查找"><strong>按照文件从属关系查找</strong></a></h3>
<ul>
<li>-user：以用户名查找</li>
<li>-group：以组名查找</li>
<li>-uid：以用户 ID 查找</li>
<li>-gid：以组 ID 查找</li>
<li>-nouser：查找没有属主的文件</li>
<li>-nogroup：查找没有属组的文件</li>
</ul>
<h3 id="按照文件大小查找"><a class="header" href="#按照文件大小查找"><strong>按照文件大小查找</strong></a></h3>
<p>按照文件大小查找功能十分常用，用 -size 选项，选项后边指定大小 1024M，表示大小的格式有如下几种：</p>
<ul>
<li>-5M：查找小于 5M 的文件</li>
<li>+5M：查找大于 5M 的文件</li>
<li>5M：查找大小为 5M 的文件</li>
</ul>
<p>单位支持的有 c（字节）、k、M、G 等，需要注意的是默认单位并不是字节，而是 b（块），大小为 512 字节。</p>
<h3 id="按照时间查找"><a class="header" href="#按照时间查找"><strong>按照时间查找</strong></a></h3>
<p>按照时间查找的功能对系统管理员来说，十分常用，find 支持如下几种时间类型：</p>
<ul>
<li>atime：以访问时间查找</li>
<li>mtime：以数据修改时间查找</li>
<li>ctime：以元数据修改时间查找</li>
<li>newer：以文件为条件，判断比它新的文件</li>
</ul>
<p>按时间查找时，使用格式如下：</p>
<ul>
<li>-atime -5：表示 5 天内访问过的文件；</li>
<li>-atime +5：表示 6 天前访问过的文件；</li>
<li>-atime 5：表示前 5-6 那一天访问的文件；</li>
</ul>
<p><strong>示例图</strong></p>
<p><img src="10.Linux//images/linux_find_time.png" alt="" /></p>
<h3 id="按照权限查找"><a class="header" href="#按照权限查找"><strong>按照权限查找</strong></a></h3>
<p>按权限查找是通过 -perm 选项，可以按照如下方式使用：</p>
<ul>
<li>-perm 644：精确权限查找</li>
<li>-perm /666：任何一类用户中的任何一位符合条件即满足</li>
<li>-perm -222：每一类用户的每一位同时符合条件即满足</li>
</ul>
<h2 id="组合条件-1"><a class="header" href="#组合条件-1"><strong>组合条件</strong></a></h2>
<p>find 可以使用多个条件的组合，支持 -a、-o、-not 或 !，比较简单，不再详细描述其含义。</p>
<h2 id="处理动作-1"><a class="header" href="#处理动作-1"><strong>处理动作</strong></a></h2>
<p>find 根据各种条件查找后，支持执行相关的处理动作，可以让我们的更方便和灵活，而不只是打印出来。</p>
<ul>
<li>-print：打印，默认动作，可省略</li>
<li>-ls：以 ls 长文件格式输出</li>
<li>-delete：删除查找到的文件</li>
<li>-exec：查找到的文件传递给任何 Linux 命令</li>
<li>-ok：与 exec 功能相同，区别是需要用户确认每次的操作</li>
</ul>
<h2 id="警告"><a class="header" href="#警告">警告</a></h2>
<p>这里需要提一下，find 搜索文件时通过扫描磁盘来进行的，尽可能不要大范围的搜索文件，尤其是在 / 目录下搜索，会长时间消耗服务器的 cpu 资源。<strong>如果是生产环境的机器，执行前要考虑是否会对业务造成影响。</strong></p>
<h2 id="扩展-locate"><a class="header" href="#扩展-locate">扩展 locate</a></h2>
<p>这里推荐另一个 Linux 文件查找神器 locate，类似于 win 平台下的 everything。它基于索引表进行查询，查询速度非常快，基本不占用 cpu 资源。</p>
<p>使用方法非常简单</p>
<pre><code>$ locate file.txt
$ locate /etc/httpd
</code></pre>
<p>需要注意，如果是当天新创建的文件，通过 locate 默认是查不到的，因为它的数据库默认是每天自动更新一次。如果希望查询到当天创建的新文件，需要执行 updatedb 即可。</p>
<p>查找速度快是 locate 的优势，但它的缺点也非常明显：</p>
<ul>
<li>模糊查询</li>
<li>查找匹配模式单一</li>
<li>查询的名称匹配路径命令</li>
<li>索引表的建立会占用磁盘空间</li>
<li>非实时查询，当天数据可能查不到</li>
</ul>
<p><a href="https://www.toutiao.com/i6924165936706535948/">文档链接</a></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="10.Linux/../images/iptables_process.png" alt="img" /></p>
<p><img src="10.Linux/../images/tables_and_chain.png" alt="img" /></p>
<ol>
<li>filter表——三个链：INPUT、FORWARD、OUTPUT
作用：过滤数据包 内核模块：iptables_filter.</li>
<li>Nat表——三个链：PREROUTING、POSTROUTING、OUTPUT
作用：用于网络地址转换（IP、端口） 内核模块：iptable_nat</li>
<li>Mangle表——五个链：PREROUTING、POSTROUTING、INPUT、OUTPUT、FORWARD
作用：修改数据包的服务类型、TTL、并且可以配置路由实现QOS内核模块：iptable_mangle(别看这个表这么麻烦，咱们设置策略时几乎都不会用到它)</li>
<li>Raw表——两个链：OUTPUT、PREROUTING
作用：决定数据包是否被状态跟踪机制处理 内核模块：iptable_raw
(这个是REHL4没有的，不过不用怕，用的不多)</li>
</ol>
<p><strong>规则链：</strong></p>
<ol>
<li>INPUT——进来的数据包应用此规则链中的策略</li>
<li>OUTPUT——外出的数据包应用此规则链中的策略</li>
<li>FORWARD——转发数据包时应用此规则链中的策略</li>
<li>PREROUTING——对数据包作路由选择前应用此链中的规则
（记住！所有的数据包进来的时侯都先由这个链处理）</li>
<li>POSTROUTING——对数据包作路由选择后应用此链中的规则
（所有的数据包出来的时侯都先由这个链处理）</li>
</ol>
<h2 id="常用命令"><a class="header" href="#常用命令">常用命令：</a></h2>
<pre><code>-A 追加规则--&gt;iptables -A INPUT
-D 删除规则--&gt;iptables -D INPUT 1(编号)
-R 修改规则--&gt;iptables -R INPUT 1 -s 192.168.12.0 -j DROP 取代现行规则，顺序不变(1是位置)
-I 插入规则--&gt;iptables -I INPUT 1 --dport 80 -j ACCEPT 插入一条规则，原本位置上的规则将会往后移动一个顺位
-L 查看规则--&gt;iptables -L INPUT 列出规则链中的所有规则
-N 新的规则--&gt;iptables -N allowed 定义新的规则
</code></pre>
<p>通用参数：</p>
<pre><code>-p 协议 例：iptables -A INPUT -p tcp
-s源地址 例：iptables -A INPUT -s 192.168.1.1
-d目的地址 例：iptables -A INPUT -d 192.168.12.1
-sport源端口 例:iptables -A INPUT -p tcp --sport 22
-dport目的端口 例:iptables -A INPUT -p tcp --dport 22
-i指定入口网卡 例:iptables -A INPUT -i eth0
-o指定出口网卡 例:iptables -A FORWARD -o eth0

</code></pre>
<p><strong>-j 指定要进行的处理动作</strong>
常用的ACTION：</p>
<pre><code>DROP：丢弃
REJECT：明示拒绝
ACCEPT：接受
SNAT基于原地址的转换
</code></pre>
<p><strong>source--指定原地址</strong>
比如我们现在要将所有192.168.10.0网段的IP在经过的时候全都转换成172.16.100.1这个假设出来的外网地址：</p>
<pre><code>iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j SNAT --to-source 172.16.100.1(外网有效ip)
</code></pre>
<p>这样，只要是来自本地网络的试图通过网卡访问网络的，都会被统统转换成172.16.100.1这个IP.
<strong>MASQUERADE(动态伪装）</strong>--</p>
<p>家用带宽获取的外网ip，就是用到了动态伪装</p>
<pre><code>iptables -t nat -A POSTROUTING -s 192.168.10.0/24 -j MASQUERADE
</code></pre>
<p><strong>DNAT目标地址转换</strong>
<strong>destination-指定目标地址</strong></p>
<pre><code>iptables -t nat -A PREROUTING -d 192.168.10.18 -p tcp --dport 80 -j DNAT --to-destination 172.16.100.2
10.18访问80端口转换到100.2上
</code></pre>
<p>MASQUERADE：源地址伪装
REDIRECT：重定向：主要用于实现端口重定向
MARK：打防火墙标记的
RETURN：返回 在自定义链执行完毕后使用返回，来返回原规则链。</p>
<p>匹配(match)
每个iptables规则都包含一组匹配以及一个目标，iptables匹配指的是数据包必须匹配的条件，只有当
数据包满足所有的匹配条件时，iptables才能根据由该规则的目标所指定的动作来处理该数据包
匹配都在iptable的命令行中指定</p>
<pre><code>source--匹配源ip地址或网络
destination (-d)--匹配目标ip地址或网络
protocol (-p)--匹配ip值
in-interface (-i)--流入接口(例如，eth0)
out-interface (-o)--流出接口
state--匹配一组连接状态
string--匹配应用层数据字节序列
comment--在内核内存中为一个规则关联多达256个字节的注释数据
</code></pre>
<p><strong>目标(target)</strong>
iptables支持一组目标，用于数据包匹配一条规则时触发一个动作</p>
<pre><code>ACCEPT--允许数据包通过
DROP--丢弃数据包，不对该数据包做进一步的处理，对接收栈而言，就好像该数据包从来没有被接收一样
LOG--将数据包信息记录到syslog
REJECT--丢弃数据包，同时发送适当的响应报文(针对TCP连接的TCP重要数据包或针对UDP数据包的ICMP端口不可达消息)
RETURN--在调用链中继续处理数据包
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h2>
<h3 id="获取五条数据"><a class="header" href="#获取五条数据">获取五条数据</a></h3>
<pre><code>curl 'https://api.github.com/repos/stedolan/jq/commits?per_page=5'
</code></pre>
<h3 id="格式化"><a class="header" href="#格式化">格式化</a></h3>
<pre><code>curl 'https://api.github.com/repos/stedolan/jq/commits?per_page=5' | jq '.'
</code></pre>
<h3 id="取数据组中的第一个数据"><a class="header" href="#取数据组中的第一个数据">取数据组中的第一个数据</a></h3>
<pre><code>curl 'https://api.github.com/repos/stedolan/jq/commits?per_page=5' | jq '.[0]'
</code></pre>
<h3 id="取第一条数据的messagename"><a class="header" href="#取第一条数据的messagename">取第一条数据的message、name</a></h3>
<pre><code class="language-java">curl 'https://api.github.com/repos/stedolan/jq/commits?per_page=5' | jq '.[0] | {message: .commit.message, name: .commit.committer.name}'
</code></pre>
<p><strong>取所有的</strong></p>
<pre><code>jq '.[] | {message: .commit.message, name: .commit.committer.name}'
</code></pre>
<h2 id="嵌套数组访问"><a class="header" href="#嵌套数组访问">嵌套数组访问</a></h2>
<pre><code>jq '[.[] | {message: .commit.message, name: .commit.committer.name, parents: [.parents[].html_url]}]'
</code></pre>
<h2 id="basic-filters"><a class="header" href="#basic-filters">Basic filters</a></h2>
<h3 id="identity-"><a class="header" href="#identity-">Identity: <code>.</code></a></h3>
<p>绝对最简单的过滤器是。。这是一个过滤器，它接受它的输入，并以不变的方式产生它作为输出。也就是说，这是身份运算符。</p>
<h3 id="object-identifier-index-foo-foobar"><a class="header" href="#object-identifier-index-foo-foobar">Object Identifier-Index: <code>.foo</code>, <code>.foo.bar</code></a></h3>
<p>https://stedolan.github.io/jq/manual/#Builtinoperatorsandfunctions</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本使用"><a class="header" href="#基本使用">基本使用</a></h1>
<p><code>lsof -i:port</code></p>
<h1 id="扩展接口"><a class="header" href="#扩展接口">扩展接口</a></h1>
<p>-a 列出打开文件存在的进程</p>
<p>-c&lt;进程名&gt; 列出指定进程所打开的文件</p>
<p>-g 列出GID号进程详情</p>
<p>-d&lt;文件号&gt; 列出占用该文件号的进程</p>
<p>+d&lt;目录&gt; 列出目录下被打开的文件</p>
<p>+D&lt;目录&gt; 递归列出目录下被打开的文件</p>
<p>-n&lt;目录&gt; 列出使用NFS的文件</p>
<p>-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</p>
<p>-p&lt;进程号&gt; 列出指定进程号所打开的文件</p>
<p>-u 列出UID号进程详情</p>
<p>-h 显示帮助信息</p>
<p>-v 显示版本信息</p>
<h1 id="表头含义"><a class="header" href="#表头含义">表头含义</a></h1>
<p>COMMAND：进程的名称 PID：进程标识符</p>
<p>USER：进程所有者</p>
<p>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等 TYPE：文件类型，如DIR、REG等</p>
<p>DEVICE：指定磁盘的名称</p>
<p>SIZE：文件的大小</p>
<p>NODE：索引节点（文件在磁盘上的标识）</p>
<p>NAME：打开文件的确切名称</p>
<h1 id="示例-1"><a class="header" href="#示例-1">示例</a></h1>
<pre><code>#查看所有进程的文件打开数
lsof |wc -l
#查看整个系统目前使用的文件句柄数
cat /proc/sys/fs/file-nr
#查看某个进程的的文件句柄数
lsof -p pid|wc -l
查看某个目录，文件被什么进程占用
lsof path(file)
</code></pre>
<pre><code class="language-shell">#!/bin/sh 
set -x 
echo &quot;&quot;&gt;total_handler 
psid=`ps -ef|grep $1|head -1|awk '{print $2}'` 
count=0 
while [ $count -lt 3000 ] 
do 
 lsof -p $psid|wc -l &gt;&gt; total_handler 
 sleep 10 
 count=`expr $count + 1` 
done
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-3"><a class="header" href="#简介-3">简介</a></h1>
<p>report a sn</p>
<p>apshot of the current processes</p>
<p>这个版本的 ps接受 不同类别的选项</p>
<ol>
<li>UNIX options：前置短横杠</li>
<li>BSD options：没有前置短横杠</li>
<li>GNU long options：双前置短横杠</li>
</ol>
<ul>
<li>不同类别的选项可以 结合使用、但是会有冲突</li>
<li>ps -aux 已经过时 不要再使用</li>
</ul>
<p><strong>默认行为</strong></p>
<ul>
<li>过滤 当前用户的euid、以及所关联的终端</li>
<li>展示 PID、终端名 tname、累积CPU时间[DD-]hh:mm:ss，time、executable name (ucmd)</li>
<li>默认不排序</li>
</ul>
<p><strong>BSD-style options</strong>的行为</p>
<ul>
<li>展示 process state (stat=STAT)</li>
<li>展示 command args (args=COMMAND)而不是 executable name</li>
<li>通过 PS_FORMAT 覆盖</li>
<li>BSD-style options 会 包含 其他终端的 属于你的进程，它包含 除了 其他用户的进程、或者不在<em>terminal</em>的进程</li>
<li>These effects are not considered when options are described as being &quot;identical&quot; below, so -M will be
considered identical to Z and so on</li>
</ul>
<p><strong>example</strong></p>
<pre><code>   To see every process on the system using standard syntax:
      ps -e
      ps -ef
      ps -eF
      ps -ely

   To see every process on the system using BSD syntax:
      ps ax
      ps axu

   To print a process tree:
      ps -ejH
      ps axjf

   To get info about threads:
      ps -eLf
      ps axms

   To get security info:
      ps -eo euser,ruser,suser,fuser,f,comm,label
      ps axZ
      ps -eM

   To see every process running as root (real &amp; effective ID) in
   user format:
      ps -U root -u root u

   To see every process with a user-defined format:
      ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm
      ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm
      ps -Ao pid,tt,user,fname,tmout,f,wchan

   Print only the process IDs of syslogd:
      ps -C syslogd -o pid=

   Print only the name of PID 42:
      ps -q 42 -o comm=
</code></pre>
<h2 id="简单的进程筛选"><a class="header" href="#简单的进程筛选">简单的进程筛选</a></h2>
<blockquote>
<p>SIMPLE PROCESS SELECTION</p>
</blockquote>
<pre><code>         top
       a      Lift the BSD-style &quot;only yourself&quot; restriction, which is
              imposed upon the set of all processes when some BSD-style
              (without &quot;-&quot;) options are used or when the ps personality
              setting is BSD-like.  The set of processes selected in
              this manner is in addition to the set of processes
              selected by other means.  An alternate description is that
              this option causes ps to list all processes with a
              terminal (tty), or to list all processes when used
              together with the x option.

       -A     Select all processes.  Identical to -e.

       -a     Select all processes except both session leaders (see
              getsid(2)) and processes not associated with a terminal.

       -d     Select all processes except session leaders.

       --deselect
              Select all processes except those that fulfill the
              specified conditions (negates the selection).  Identical
              to -N.

       -e     Select all processes.  Identical to -A.

       g      Really all, even session leaders.  This flag is obsolete
              and may be discontinued in a future release.  It is
              normally implied by the a flag, and is only useful when
              operating in the sunos4 personality.

       -N     Select all processes except those that fulfill the
              specified conditions (negates the selection).  Identical
              to --deselect.

       T      Select all processes associated with this terminal.
              Identical to the t option without any argument.

       r      Restrict the selection to only running processes.

       x      Lift the BSD-style &quot;must have a tty&quot; restriction, which is
              imposed upon the set of all processes when some BSD-style
              (without &quot;-&quot;) options are used or when the ps personality
              setting is BSD-like.  The set of processes selected in
              this manner is in addition to the set of processes
              selected by other means.  An alternate description is that
              this option causes ps to list all processes owned by you
              (same EUID as ps), or to list all processes when used
              together with the a option.
              
PROCESS SELECTION BY LIST         top
       These options accept a single argument in the form of a
       blank-separated or comma-separated list.  They can be used
       multiple times.  For example: ps -p &quot;1 2&quot; -p 3,4

       -123   Identical to --pid 123.

       123    Identical to --pid 123.

       -C cmdlist
              Select by command name.  This selects the processes whose
              executable name is given in cmdlist.  NOTE: The command
              name is not the same as the command line. Previous
              versions of procps and the kernel truncated this command
              name to 15 characters. This limitation is no longer
              present in both. If you depended on matching only 15
              characters, you may no longer get a match.

       -G grplist
              Select by real group ID (RGID) or name.  This selects the
              processes whose real group name or ID is in the grplist
              list.  The real group ID identifies the group of the user
              who created the process, see getgid(2).

       -g grplist
              Select by session OR by effective group name.  Selection
              by session is specified by many standards, but selection
              by effective group is the logical behavior that several
              other operating systems use.  This ps will select by
              session when the list is completely numeric (as sessions
              are).  Group ID numbers will work only when some group
              names are also specified.  See the -s and --group options.

       --Group grplist
              Select by real group ID (RGID) or name.  Identical to -G.

       --group grplist
              Select by effective group ID (EGID) or name.  This selects
              the processes whose effective group name or ID is in
              grplist.  The effective group ID describes the group whose
              file access permissions are used by the process (see
              getegid(2)).  The -g option is often an alternative to
              --group.

       p pidlist
              Select by process ID.  Identical to -p and --pid.

       -p pidlist
              Select by PID.  This selects the processes whose process
              ID numbers appear in pidlist.  Identical to p and --pid.

       --pid pidlist
              Select by process ID.  Identical to -p and p.

       --ppid pidlist
              Select by parent process ID.  This selects the processes
              with a parent process ID in pidlist.  That is, it selects
              processes that are children of those listed in pidlist.

       q pidlist
              Select by process ID (quick mode).  Identical to -q and
              --quick-pid.

       -q pidlist
              Select by PID (quick mode).  This selects the processes
              whose process ID numbers appear in pidlist.  With this
              option ps reads the necessary info only for the pids
              listed in the pidlist and doesn't apply additional
              filtering rules.  The order of pids is unsorted and
              preserved.  No additional selection options, sorting and
              forest type listings are allowed in this mode.  Identical
              to q and --quick-pid.

       --quick-pid pidlist
              Select by process ID (quick mode).  Identical to -q and q.

       -s sesslist
              Select by session ID.  This selects the processes with a
              session ID specified in sesslist.

       --sid sesslist
              Select by session ID.  Identical to -s.

       t ttylist
              Select by tty.  Nearly identical to -t and --tty, but can
              also be used with an empty ttylist to indicate the
              terminal associated with ps.  Using the T option is
              considered cleaner than using t with an empty ttylist.

       -t ttylist
              Select by tty.  This selects the processes associated with
              the terminals given in ttylist.  Terminals (ttys, or
              screens for text output) can be specified in several
              forms: /dev/ttyS1, ttyS1, S1.  A plain &quot;-&quot; may be used to
              select processes not attached to any terminal.

       --tty ttylist
              Select by terminal.  Identical to -t and t.

       U userlist
              Select by effective user ID (EUID) or name.  This selects
              the processes whose effective user name or ID is in
              userlist.  The effective user ID describes the user whose
              file access permissions are used by the process (see
              geteuid(2)).  Identical to -u and --user.

       -U userlist
              Select by real user ID (RUID) or name.  It selects the
              processes whose real user name or ID is in the userlist
              list.  The real user ID identifies the user who created
              the process, see getuid(2).

       -u userlist
              Select by effective user ID (EUID) or name.  This selects
              the processes whose effective user name or ID is in
              userlist.

              The effective user ID describes the user whose file access
              permissions are used by the process (see geteuid(2)).
              Identical to U and --user.

       --User userlist
              Select by real user ID (RUID) or name.  Identical to -U.

       --user userlist
              Select by effective user ID (EUID) or name.  Identical to
              -u and U.
OUTPUT FORMAT CONTROL         top
       These options are used to choose the information displayed by ps.
       The output may differ by personality.

       -c     Show different scheduler information for the -l option.

       --context
              Display security context format (for SELinux).

       -f     Do full-format listing.  This option can be combined with
              many other UNIX-style options to add additional columns.
              It also causes the command arguments to be printed.  When
              used with -L, the NLWP (number of threads) and LWP (thread
              ID) columns will be added.  See the c option, the format
              keyword args, and the format keyword comm.

       -F     Extra full format.  See the -f option, which -F implies.

       --format format
              user-defined format.  Identical to -o and o.

       j      BSD job control format.

       -j     Jobs format.

       l      Display BSD long format.

       -l     Long format.  The -y option is often useful with this.

       -M     Add a column of security data.  Identical to Z (for
              SELinux).

       O format
              is preloaded o (overloaded).  The BSD O option can act
              like -O (user-defined output format with some common
              fields predefined) or can be used to specify sort order.
              Heuristics are used to determine the behavior of this
              option.  To ensure that the desired behavior is obtained
              (sorting or formatting), specify the option in some other
              way (e.g.  with -O or --sort).  When used as a formatting
              option, it is identical to -O, with the BSD personality.

       -O format
              Like -o, but preloaded with some default columns.
              Identical to -o pid,format,state,tname,time,command or
              -o pid,format,tname,time,cmd, see -o below.

       o format
              Specify user-defined format.  Identical to -o and
              --format.

       -o format
              User-defined format.  format is a single argument in the
              form of a blank-separated or comma-separated list, which
              offers a way to specify individual output columns.  The
              recognized keywords are described in the STANDARD FORMAT
              SPECIFIERS section below.  Headers may be renamed (ps -o
              pid,ruser=RealUser -o comm=Command) as desired.  If all
              column headers are empty (ps -o pid= -o comm=) then the
              header line will not be output.  Column width will
              increase as needed for wide headers; this may be used to
              widen up columns such as WCHAN (ps -o pid,wchan=WIDE-
              WCHAN-COLUMN -o comm).  Explicit width control (ps opid,
              wchan:42,cmd) is offered too.  The behavior of ps -o
              pid=X,comm=Y varies with personality; output may be one
              column named &quot;X,comm=Y&quot; or two columns named &quot;X&quot; and &quot;Y&quot;.
              Use multiple -o options when in doubt.  Use the PS_FORMAT
              environment variable to specify a default as desired;
              DefSysV and DefBSD are macros that may be used to choose
              the default UNIX or BSD columns.

       s      Display signal format.

       u      Display user-oriented format.

       v      Display virtual memory format.

       X      Register format.

       -y     Do not show flags; show rss in place of addr.  This option
              can only be used with -l.

       Z      Add a column of security data.  Identical to -M (for
              SELinux).
OUTPUT MODIFIERS         top
       c      Show the true command name.  This is derived from the name
              of the executable file, rather than from the argv value.
              Command arguments and any modifications to them are thus
              not shown.  This option effectively turns the args format
              keyword into the comm format keyword; it is useful with
              the -f format option and with the various BSD-style format
              options, which all normally display the command arguments.
              See the -f option, the format keyword args, and the format
              keyword comm.

       --cols n
              Set screen width.

       --columns n
              Set screen width.

       --cumulative
              Include some dead child process data (as a sum with the
              parent).

       e      Show the environment after the command.

       f      ASCII art process hierarchy (forest).

       --forest
              ASCII art process tree.

       h      No header.  (or, one header per screen in the BSD
              personality).  The h option is problematic.  Standard BSD
              ps uses this option to print a header on each page of
              output, but older Linux ps uses this option to totally
              disable the header.  This version of ps follows the Linux
              usage of not printing the header unless the BSD
              personality has been selected, in which case it prints a
              header on each page of output.  Regardless of the current
              personality, you can use the long options --headers and
              --no-headers to enable printing headers each page or
              disable headers entirely, respectively.

       -H     Show process hierarchy (forest).

       --headers
              Repeat header lines, one per page of output.

       k spec Specify sorting order.  Sorting syntax is
              [+|-]key[,[+|-]key[,...]].  Choose a multi-letter key from
              the STANDARD FORMAT SPECIFIERS section.  The &quot;+&quot; is
              optional since default direction is increasing numerical
              or lexicographic order.  Identical to --sort.

                      Examples:
                      ps jaxkuid,-ppid,+pid
                      ps axk comm o comm,args
                      ps kstart_time -ef

       --lines n
              Set screen height.

       n      Numeric output for WCHAN and USER (including all types of
              UID and GID).

       --no-headers
              Print no header line at all.  --no-heading is an alias for
              this option.

       O order
              Sorting order (overloaded).  The BSD O option can act like
              -O (user-defined output format with some common fields
              predefined) or can be used to specify sort order.
              Heuristics are used to determine the behavior of this
              option.  To ensure that the desired behavior is obtained
              (sorting or formatting), specify the option in some other
              way (e.g.  with -O or --sort).

              For sorting, obsolete BSD O option syntax is
              O[+|-]k1[,[+|-]k2[,...]].  It orders the processes listing
              according to the multilevel sort specified by the sequence
              of one-letter short keys k1,k2, ... described in the
              OBSOLETE SORT KEYS section below.  The &quot;+&quot; is currently
              optional, merely re-iterating the default direction on a
              key, but may help to distinguish an O sort from an O
              format.  The &quot;-&quot; reverses direction only on the key it
              precedes.

       --rows n
              Set screen height.

       S      Sum up some information, such as CPU usage, from dead
              child processes into their parent.  This is useful for
              examining a system where a parent process repeatedly forks
              off short-lived children to do work.

       --sort spec
              Specify sorting order.  Sorting syntax is
              [+|-]key[,[+|-]key[,...]].  Choose a multi-letter key from
              the STANDARD FORMAT SPECIFIERS section.  The &quot;+&quot; is
              optional since default direction is increasing numerical
              or lexicographic order.  Identical to k.  For example: ps
              jax --sort=uid,-ppid,+pid

       w      Wide output.  Use this option twice for unlimited width.

       -w     Wide output.  Use this option twice for unlimited width.

       --width n
              Set screen width.
THREAD DISPLAY         top
       H      Show threads as if they were processes.

       -L     Show threads, possibly with LWP and NLWP columns.

       m      Show threads after processes.

       -m     Show threads after processes.

       -T     Show threads, possibly with SPID column.
OTHER INFORMATION         top
       --help section
              Print a help message.  The section argument can be one of
              simple, list, output, threads, misc, or all.  The argument
              can be shortened to one of the underlined letters as in:
              s|l|o|t|m|a.

       --info Print debugging info.

       L      List all format specifiers.

       V      Print the procps-ng version.

       -V     Print the procps-ng version.

       --version
              Print the procps-ng version.
NOTES         top
       This ps works by reading the virtual files in /proc.  This ps
       does not need to be setuid kmem or have any privileges to run.
       Do not give this ps any special permissions.

       CPU usage is currently expressed as the percentage of time spent
       running during the entire lifetime of a process.  This is not
       ideal, and it does not conform to the standards that ps otherwise
       conforms to.  CPU usage is unlikely to add up to exactly 100%.

       The SIZE and RSS fields don't count some parts of a process
       including the page tables, kernel stack, struct thread_info, and
       struct task_struct.  This is usually at least 20 KiB of memory
       that is always resident.  SIZE is the virtual size of the process
       (code+data+stack).

       Processes marked &lt;defunct&gt; are dead processes (so-called
       &quot;zombies&quot;) that remain because their parent has not destroyed
       them properly.  These processes will be destroyed by init(8) if
       the parent process exits.

       If the length of the username is greater than the length of the
       display column, the username will be truncated.  See the -o and
       -O formatting options to customize length.

       Commands options such as ps -aux are not recommended as it is a
       confusion of two different standards.  According to the POSIX and
       UNIX standards, the above command asks to display all processes
       with a TTY (generally the commands users are running) plus all
       processes owned by a user named x.  If that user doesn't exist,
       then ps will assume you really meant ps aux.
PROCESS FLAGS         top
       The sum of these values is displayed in the &quot;F&quot; column, which is
       provided by the flags output specifier:

               1    forked but didn't exec
               4    used super-user privileges
PROCESS STATE CODES         top
       Here are the different values that the s, stat and state output
       specifiers (header &quot;STAT&quot; or &quot;S&quot;) will display to describe the
       state of a process:

               D    uninterruptible sleep (usually IO)
               I    Idle kernel thread
               R    running or runnable (on run queue)
               S    interruptible sleep (waiting for an event to
                    complete)
               T    stopped by job control signal
               t    stopped by debugger during the tracing
               W    paging (not valid since the 2.6.xx kernel)
               X    dead (should never be seen)
               Z    defunct (&quot;zombie&quot;) process, terminated but not
                    reaped by its parent

       For BSD formats and when the stat keyword is used, additional
       characters may be displayed:

               &lt;    high-priority (not nice to other users)
               N    low-priority (nice to other users)
               L    has pages locked into memory (for real-time and
                    custom IO)
               s    is a session leader
               l    is multi-threaded (using CLONE_THREAD, like NPTL
                    pthreads do)
               +    is in the foreground process group
OBSOLETE SORT KEYS         top
       These keys are used by the BSD O option (when it is used for
       sorting).  The GNU --sort option doesn't use these keys, but the
       specifiers described below in the STANDARD FORMAT SPECIFIERS
       section.  Note that the values used in sorting are the internal
       values ps uses and not the &quot;cooked&quot; values used in some of the
       output format fields (e.g.  sorting on tty will sort into device
       number, not according to the terminal name displayed).  Pipe ps
       output into the sort(1) command if you want to sort the cooked
       values.

       KEY   LONG         DESCRIPTION
       c     cmd          simple name of executable
       C     pcpu         cpu utilization
       f     flags        flags as in long format F field
       g     pgrp         process group ID
       G     tpgid        controlling tty process group ID
       j     cutime       cumulative user time
       J     cstime       cumulative system time
       k     utime        user time
       m     min_flt      number of minor page faults
       M     maj_flt      number of major page faults
       n     cmin_flt     cumulative minor page faults
       N     cmaj_flt     cumulative major page faults
       o     session      session ID
       p     pid          process ID
       P     ppid         parent process ID
       r     rss          resident set size
       R     resident     resident pages
       s     size         memory size in kilobytes
       S     share        amount of shared pages
       t     tty          the device number of the controlling tty
       T     start_time   time process was started

       U     uid          user ID number
       u     user         user name
       v     vsize        total VM size in KiB
       y     priority     kernel scheduling priority
AIX FORMAT DESCRIPTORS         top
       This ps supports AIX format descriptors, which work somewhat like
       the formatting codes of printf(1) and printf(3).  For example,
       the normal default output can be produced with this: ps -eo &quot;%p
       %y %x %c&quot;.  The NORMAL codes are described in the next section.

       CODE   NORMAL   HEADER
       %C     pcpu     %CPU
       %G     group    GROUP
       %P     ppid     PPID
       %U     user     USER
       %a     args     COMMAND
       %c     comm     COMMAND
       %g     rgroup   RGROUP
       %n     nice     NI
       %p     pid      PID
       %r     pgid     PGID
       %t     etime    ELAPSED
       %u     ruser    RUSER
       %x     time     TIME
       %y     tty      TTY
       %z     vsz      VSZ
STANDARD FORMAT SPECIFIERS         top
       Here are the different keywords that may be used to control the
       output format (e.g., with option -o) or to sort the selected
       processes with the GNU-style --sort option.

       For example: ps -eo pid,user,args --sort user

       This version of ps tries to recognize most of the keywords used
       in other implementations of ps.

       The following user-defined format specifiers may contain spaces:
       args, cmd, comm, command, fname, ucmd, ucomm, lstart, bsdstart,
       start.

       Some keywords may not be available for sorting.

       CODE        HEADER    DESCRIPTION

       %cpu        %CPU      cpu utilization of the process in &quot;##.#&quot;
                             format.  Currently, it is the CPU time used
                             divided by the time the process has been
                             running (cputime/realtime ratio), expressed
                             as a percentage.  It will not add up to
                             100% unless you are lucky.  (alias pcpu).

       %mem        %MEM      ratio of the process's resident set size
                             to the physical memory on the machine,
                             expressed as a percentage.  (alias pmem).

       args        COMMAND   command with all its arguments as a string.
                             Modifications to the arguments may be
                             shown.  The output in this column may
                             contain spaces.  A process marked &lt;defunct&gt;
                             is partly dead, waiting to be fully
                             destroyed by its parent.  Sometimes the
                             process args will be unavailable; when this
                             happens, ps will instead print the
                             executable name in brackets.  (alias cmd,
                             command).  See also the comm format
                             keyword, the -f option, and the c option.
                             When specified last, this column will
                             extend to the edge of the display.  If ps
                             can not determine display width, as when
                             output is redirected (piped) into a file or
                             another command, the output width is
                             undefined (it may be 80, unlimited,
                             determined by the TERM variable, and so
                             on).  The COLUMNS environment variable or
                             --cols option may be used to exactly
                             determine the width in this case.  The w or
                             -w option may be also be used to adjust
                             width.

       blocked     BLOCKED   mask of the blocked signals, see signal(7).
                             According to the width of the field, a 32
                             or 64-bit mask in hexadecimal format is
                             displayed.  (alias sig_block, sigmask).

       bsdstart    START     time the command started.  If the process
                             was started less than 24 hours ago, the
                             output format is &quot; HH:MM&quot;, else it is &quot;
                             Mmm:SS&quot; (where Mmm is the three letters of
                             the month).  See also lstart, start,
                             start_time, and stime.

       bsdtime     TIME      accumulated cpu time, user + system.  The
                             display format is usually &quot;MMM:SS&quot;, but can
                             be shifted to the right if the process used
                             more than 999 minutes of cpu time.

       c           C         processor utilization.  Currently, this is
                             the integer value of the percent usage over
                             the lifetime of the process.  (see %cpu).

       caught      CAUGHT    mask of the caught signals, see signal(7).
                             According to the width of the field, a 32
                             or 64 bits mask in hexadecimal format is
                             displayed.  (alias sig_catch, sigcatch).

       cgname      CGNAME    display name of control groups to which the
                             process belongs.

       cgroup      CGROUP    display control groups to which the process
                             belongs.

       class       CLS       scheduling class of the process.  (alias
                             policy, cls).  Field's possible values are:

                                      -   not reported
                                      TS  SCHED_OTHER
                                      FF  SCHED_FIFO
                                      RR  SCHED_RR
                                      B   SCHED_BATCH
                                      ISO SCHED_ISO
                                      IDL SCHED_IDLE
                                      DLN SCHED_DEADLINE
                                      ?   unknown value

       cls         CLS       scheduling class of the process.  (alias
                             policy, cls).  Field's possible values are:

                                      -   not reported
                                      TS  SCHED_OTHER
                                      FF  SCHED_FIFO
                                      RR  SCHED_RR
                                      B   SCHED_BATCH
                                      ISO SCHED_ISO
                                      IDL SCHED_IDLE
                                      DLN SCHED_DEADLINE
                                      ?   unknown value

       cmd         CMD       see args.  (alias args, command).

       comm        COMMAND   command name (only the executable name).
                             Modifications to the command name will not
                             be shown.  A process marked &lt;defunct&gt; is
                             partly dead, waiting to be fully destroyed
                             by its parent.  The output in this column
                             may contain spaces.  (alias ucmd, ucomm).
                             See also the args format keyword, the -f
                             option, and the c option.
                             When specified last, this column will
                             extend to the edge of the display.  If ps
                             can not determine display width, as when
                             output is redirected (piped) into a file or
                             another command, the output width is
                             undefined (it may be 80, unlimited,
                             determined by the TERM variable, and so
                             on).  The COLUMNS environment variable or
                             --cols option may be used to exactly
                             determine the width in this case.  The
                             w or -w option may be also be used to
                             adjust width.

       command     COMMAND   See args.  (alias args, command).

       cp          CP        per-mill (tenths of a percent) CPU usage.
                             (see %cpu).

       cputime     TIME      cumulative CPU time, &quot;[DD-]hh:mm:ss&quot;
                             format.  (alias time).

       cputimes    TIME      cumulative CPU time in seconds (alias
                             times).

       drs         DRS       data resident set size, the amount of
                             physical memory devoted to other than
                             executable code.

       egid        EGID      effective group ID number of the process as
                             a decimal integer.  (alias gid).

       egroup      EGROUP    effective group ID of the process.  This
                             will be the textual group ID, if it can be
                             obtained and the field width permits, or a
                             decimal representation otherwise.  (alias
                             group).

       eip         EIP       instruction pointer.

       esp         ESP       stack pointer.

       etime       ELAPSED   elapsed time since the process was started,
                             in the form [[DD-]hh:]mm:ss.

       etimes      ELAPSED   elapsed time since the process was started,
                             in seconds.

       euid        EUID      effective user ID (alias uid).

       euser       EUSER     effective user name.  This will be the
                             textual user ID, if it can be obtained and
                             the field width permits, or a decimal
                             representation otherwise.  The n option can
                             be used to force the decimal
                             representation.  (alias uname, user).

       exe         EXE       path to the executable. Useful if path
                             cannot be printed via cmd, comm or args
                             format options.

       f           F         flags associated with the process, see the
                             PROCESS FLAGS section.  (alias flag,
                             flags).

       fgid        FGID      filesystem access group ID.  (alias fsgid).

       fgroup      FGROUP    filesystem access group ID.  This will be
                             the textual group ID, if it can be obtained
                             and the field width permits, or a decimal
                             representation otherwise.  (alias fsgroup).

       flag        F         see f.  (alias f, flags).

       flags       F         see f.  (alias f, flag).

       fname       COMMAND   first 8 bytes of the base name of the
                             process's executable file.  The output in
                             this column may contain spaces.

       fuid        FUID      filesystem access user ID.  (alias fsuid).

       fuser       FUSER     filesystem access user ID.  This will be
                             the textual user ID, if it can be obtained
                             and the field width permits, or a decimal
                             representation otherwise.

       gid         GID       see egid.  (alias egid).

       group       GROUP     see egroup.  (alias egroup).

       ignored     IGNORED   mask of the ignored signals, see signal(7).
                             According to the width of the field, a 32
                             or 64 bits mask in hexadecimal format is
                             displayed.  (alias sig_ignore, sigignore).

       ipcns       IPCNS     Unique inode number describing the
                             namespace the process belongs to.  See
                             namespaces(7).

       label       LABEL     security label, most commonly used for
                             SELinux context data.  This is for the
                             Mandatory Access Control (&quot;MAC&quot;) found on
                             high-security systems.

       lstart      STARTED   time the command started.  See also
                             bsdstart, start, start_time, and stime.

       lsession    SESSION   displays the login session identifier of a
                             process, if systemd support has been
                             included.

       luid        LUID      displays Login ID associated with a
                             process.

       lwp         LWP       light weight process (thread) ID of the
                             dispatchable entity (alias spid, tid).  See
                             tid for additional information.

       lxc         LXC       The name of the lxc container within which
                             a task is running.  If a process is not
                             running inside a container, a dash ('-')
                             will be shown.

       machine     MACHINE   displays the machine name for processes
                             assigned to VM or container, if systemd
                             support has been included.

       maj_flt     MAJFLT    The number of major page faults that have
                             occurred with this process.

       min_flt     MINFLT    The number of minor page faults that have
                             occurred with this process.

       mntns       MNTNS     Unique inode number describing the
                             namespace the process belongs to.  See
                             namespaces(7).

       netns       NETNS     Unique inode number describing the
                             namespace the process belongs to.  See
                             namespaces(7).

       ni          NI        nice value.  This ranges from 19 (nicest)
                             to -20 (not nice to others), see nice(1).
                             (alias nice).

       nice        NI        see ni.(alias ni).

       nlwp        NLWP      number of lwps (threads) in the process.
                             (alias thcount).

       numa        NUMA      The node associated with the most recently
                             used processor.  A -1 means that NUMA
                             information is unavailable.

       nwchan      WCHAN     address of the kernel function where the
                             process is sleeping (use wchan if you want
                             the kernel function name).  Running tasks
                             will display a dash ('-') in this column.

       ouid        OWNER     displays the Unix user identifier of the
                             owner of the session of a process, if
                             systemd support has been included.

       pcpu        %CPU      see %cpu.  (alias %cpu).

       pending     PENDING   mask of the pending signals.  See
                             signal(7).  Signals pending on the process
                             are distinct from signals pending on
                             individual threads.  Use the m option or
                             the -m option to see both.  According to
                             the width of the field, a 32 or 64 bits
                             mask in hexadecimal format is displayed.
                             (alias sig).

       pgid        PGID      process group ID or, equivalently, the
                             process ID of the process group leader.
                             (alias pgrp).

       pgrp        PGRP      see pgid.  (alias pgid).

       pid         PID       a number representing the process ID (alias
                             tgid).

       pidns       PIDNS     Unique inode number describing the
                             namespace the process belongs to.  See
                             namespaces(7).

       pmem        %MEM      see %mem.  (alias %mem).

       policy      POL       scheduling class of the process.  (alias
                             class, cls).  Possible values are:

                                      -   not reported
                                      TS  SCHED_OTHER
                                      FF  SCHED_FIFO
                                      RR  SCHED_RR
                                      B   SCHED_BATCH
                                      ISO SCHED_ISO
                                      IDL SCHED_IDLE
                                      DLN SCHED_DEADLINE
                                      ?   unknown value

       ppid        PPID      parent process ID.

       pri         PRI       priority of the process.  Higher number
                             means lower priority.

       psr         PSR       processor that process is currently
                             assigned to.

       rgid        RGID      real group ID.

       rgroup      RGROUP    real group name.  This will be the textual
                             group ID, if it can be obtained and the
                             field width permits, or a decimal
                             representation otherwise.

       rss         RSS       resident set size, the non-swapped physical
                             memory that a task has used (in kilobytes).
                             (alias rssize, rsz).

       rssize      RSS       see rss.  (alias rss, rsz).

       rsz         RSZ       see rss.  (alias rss, rssize).

       rtprio      RTPRIO    realtime priority.

       ruid        RUID      real user ID.

       ruser       RUSER     real user ID.  This will be the textual
                             user ID, if it can be obtained and the
                             field width permits, or a decimal
                             representation otherwise.

       s           S         minimal state display (one character).  See
                             section PROCESS STATE CODES for the
                             different values.  See also stat if you
                             want additional information displayed.
                             (alias state).

       sched       SCH       scheduling policy of the process.  The
                             policies SCHED_OTHER (SCHED_NORMAL),
                             SCHED_FIFO, SCHED_RR, SCHED_BATCH,
                             SCHED_ISO, SCHED_IDLE and SCHED_DEADLINE
                             are respectively displayed as 0, 1, 2, 3,
                             4, 5 and 6.

       seat        SEAT      displays the identifier associated with all
                             hardware devices assigned to a specific
                             workplace, if systemd support has been
                             included.

       sess        SESS      session ID or, equivalently, the process ID
                             of the session leader.  (alias session,
                             sid).

       sgi_p       P         processor that the process is currently
                             executing on.  Displays &quot;*&quot; if the process
                             is not currently running or runnable.

       sgid        SGID      saved group ID.  (alias svgid).

       sgroup      SGROUP    saved group name.  This will be the textual
                             group ID, if it can be obtained and the
                             field width permits, or a decimal
                             representation otherwise.

       sid         SID       see sess.  (alias sess, session).

       sig         PENDING   see pending.  (alias pending, sig_pend).

       sigcatch    CAUGHT    see caught.  (alias caught, sig_catch).

       sigignore   IGNORED   see ignored.  (alias ignored, sig_ignore).

       sigmask     BLOCKED   see blocked.  (alias blocked, sig_block).

       size        SIZE      approximate amount of swap space that would
                             be required if the process were to dirty
                             all writable pages and then be swapped out.
                             This number is very rough!

       slice       SLICE     displays the slice unit which a process
                             belongs to, if systemd support has been
                             included.

       spid        SPID      see lwp.  (alias lwp, tid).

       stackp      STACKP    address of the bottom (start) of stack for
                             the process.

       start       STARTED   time the command started.  If the process
                             was started less than 24 hours ago, the
                             output format is &quot;HH:MM:SS&quot;, else it is
                             &quot;  Mmm dd&quot; (where Mmm is a three-letter
                             month name).  See also lstart, bsdstart,
                             start_time, and stime.

       start_time  START     starting time or date of the process.  Only
                             the year will be displayed if the process
                             was not started the same year ps was
                             invoked, or &quot;MmmDD&quot; if it was not started
                             the same day, or &quot;HH:MM&quot; otherwise.  See
                             also bsdstart, start, lstart, and stime.

       stat        STAT      multi-character process state.  See section
                             PROCESS STATE CODES for the different
                             values meaning.  See also s and state if
                             you just want the first character
                             displayed.

       state       S         see s. (alias s).

       stime       STIME     see start_time. (alias start_time).

       suid        SUID      saved user ID.  (alias svuid).

       supgid      SUPGID    group ids of supplementary groups, if any.
                             See getgroups(2).

       supgrp      SUPGRP    group names of supplementary groups, if
                             any.  See getgroups(2).

       suser       SUSER     saved user name.  This will be the textual
                             user ID, if it can be obtained and the
                             field width permits, or a decimal
                             representation otherwise.  (alias svuser).

       svgid       SVGID     see sgid.  (alias sgid).

       svuid       SVUID     see suid.  (alias suid).

       sz          SZ        size in physical pages of the core image of
                             the process.  This includes text, data, and
                             stack space.  Device mappings are currently
                             excluded; this is subject to change.  See
                             vsz and rss.

       tgid        TGID      a number representing the thread group to
                             which a task belongs (alias pid).  It is
                             the process ID of the thread group leader.

       thcount     THCNT     see nlwp.  (alias nlwp).  number of kernel
                             threads owned by the process.

       tid         TID       the unique number representing a
                             dispatchable entity (alias lwp, spid).
                             This value may also appear as: a process ID
                             (pid); a process group ID (pgrp); a session
                             ID for the session leader (sid); a thread
                             group ID for the thread group leader
                             (tgid); and a tty process group ID for the
                             process group leader (tpgid).

       time        TIME      cumulative CPU time, &quot;[DD-]HH:MM:SS&quot;
                             format.  (alias cputime).

       times       TIME      cumulative CPU time in seconds (alias
                             cputimes).

       tname       TTY       controlling tty (terminal).  (alias tt,
                             tty).

       tpgid       TPGID     ID of the foreground process group on the
                             tty (terminal) that the process is
                             connected to, or -1 if the process is not
                             connected to a tty.

       trs         TRS       text resident set size, the amount of
                             physical memory devoted to executable code.

       tt          TT        controlling tty (terminal).  (alias tname,
                             tty).

       tty         TT        controlling tty (terminal).  (alias tname,
                             tt).

       ucmd        CMD       see comm.  (alias comm, ucomm).

       ucomm       COMMAND   see comm.  (alias comm, ucmd).

       uid         UID       see euid.  (alias euid).

       uname       USER      see euser.  (alias euser, user).

       unit        UNIT      displays unit which a process belongs to,
                             if systemd support has been included.

       user        USER      see euser.  (alias euser, uname).

       userns      USERNS    Unique inode number describing the
                             namespace the process belongs to.  See
                             namespaces(7).

       utsns       UTSNS     Unique inode number describing the
                             namespace the process belongs to.  See
                             namespaces(7).

       uunit       UUNIT     displays user unit which a process belongs
                             to, if systemd support has been included.

       vsize       VSZ       see vsz.  (alias vsz).

       vsz         VSZ       virtual memory size of the process in KiB
                             (1024-byte units).  Device mappings are
                             currently excluded; this is subject to
                             change.  (alias vsize).

       wchan       WCHAN     name of the kernel function in which the
                             process is sleeping, a &quot;-&quot; if the process
                             is running, or a &quot;*&quot; if the process is
                             multi-threaded and ps is not displaying
                             threads.
ENVIRONMENT VARIABLES         top
       The following environment variables could affect ps:

       COLUMNS
          Override default display width.

       LINES
          Override default display height.

       PS_PERSONALITY
          Set to one of posix, old, linux, bsd, sun, digital... (see
          section PERSONALITY below).

       CMD_ENV
          Set to one of posix, old, linux, bsd, sun, digital... (see
          section PERSONALITY below).

       I_WANT_A_BROKEN_PS
          Force obsolete command line interpretation.

       LC_TIME
          Date format.

       PS_COLORS
          Not currently supported.

       PS_FORMAT
          Default output format override.  You may set this to a format
          string of the type used for the -o option.  The DefSysV and
          DefBSD values are particularly useful.

       POSIXLY_CORRECT
          Don't find excuses to ignore bad &quot;features&quot;.

       POSIX2
          When set to &quot;on&quot;, acts as POSIXLY_CORRECT.

       UNIX95
          Don't find excuses to ignore bad &quot;features&quot;.

       _XPG
          Cancel CMD_ENV=irix non-standard behavior.

       In general, it is a bad idea to set these variables.  The one
       exception is CMD_ENV or PS_PERSONALITY, which could be set to
       Linux for normal systems.  Without that setting, ps follows the
       useless and bad parts of the Unix98 standard.
PERSONALITY         top
       390        like the OS/390 OpenEdition ps
       aix        like AIX ps
       bsd        like FreeBSD ps (totally non-standard)
       compaq     like Digital Unix ps
       debian     like the old Debian ps
       digital    like Tru64 (was Digital Unix, was OSF/1) ps
       gnu        like the old Debian ps
       hp         like HP-UX ps
       hpux       like HP-UX ps
       irix       like Irix ps
       linux      ***** recommended *****
       old        like the original Linux ps (totally non-standard)
       os390      like OS/390 Open Edition ps
       posix      standard
       s390       like OS/390 Open Edition ps
       sco        like SCO ps
       sgi        like Irix ps
       solaris2   like Solaris 2+ (SunOS 5) ps
       sunos4     like SunOS 4 (Solaris 1) ps (totally non-standard)
       svr4       standard
       sysv       standard
       tru64      like Tru64 (was Digital Unix, was OSF/1) ps
       unix       standard
       unix95     standard
       unix98     standard
SEE ALSO         top
       pgrep(1), pstree(1), top(1), proc(5).
STANDARDS         top
       This ps conforms to:

       1   Version 2 of the Single Unix Specification
       2   The Open Group Technical Standard Base Specifications,
           Issue 6
       3   IEEE Std 1003.1, 2004 Edition
       4   X/Open System Interfaces Extension [UP XSI]
       5   ISO/IEC 9945:2003
AUTHOR         top
       ps was originally written by Branko Lankester ⟨lankeste@fwi.uva.
       nl⟩.  Michael K. Johnson ⟨johnsonm@redhat.com⟩ re-wrote it
       significantly to use the proc filesystem, changing a few things
       in the process.  Michael Shields ⟨mjshield@nyx.cs.du.edu⟩ added
       the pid-list feature.  Charles Blake ⟨cblake@bbn.com⟩ added
       multi-level sorting, the dirent-style library, the device
       name-to-number mmaped database, the approximate binary search
       directly on System.map, and many code and documentation cleanups.
       David Mossberger-Tang wrote the generic BFD support for psupdate.
       Albert Cahalan ⟨albert@users.sf.net⟩ rewrote ps for full Unix98
       and BSD support, along with some ugly hacks for obsolete and
       foreign syntax.

       Please send bug reports to ⟨procps@freelists.org⟩.  No
       subscription is required or suggested.
COLOPHON         top
       This page is part of the procps-ng (/proc filesystem utilities)
       project.  Information about the project can be found at 
       ⟨https://gitlab.com/procps-ng/procps⟩.  If you have a bug report
       for this manual page, see
       ⟨https://gitlab.com/procps-ng/procps/blob/master/Documentation/bugs.md⟩.
       This page was obtained from the project's upstream Git repository
       ⟨https://gitlab.com/procps-ng/procps.git⟩ on 2021-08-27.  (At
       that time, the date of the most recent commit that was found in
       the repository was 2021-08-24.)  If you discover any rendering
       problems in this HTML version of the page, or you believe there
       is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is not part of the original manual page), send a mail to
       man-pages@man7.org

procps-ng                      2020-06-04                          PS(1)
Pages that refer to this page: free(1),  fuser(1),  htop(1),  killall(1),  pgrep(1),  pidstat(1),  pmap(1),  pslog(1),  pstree(1),  pwdx(1),  slabtop(1),  systemd(1),  systemd-cgls(1),  systemd-firstboot(1),  systemd-nspawn(1),  tcpdump(1),  tload(1),  top(1),  uptime(1),  w(1),  proc(5),  credentials(7),  pid_namespaces(7),  pthreads(7),  sched(7),  lsof(8),  systemd-machined.service(8),  tcpdump(8),  vmstat(8)

HTML rendering created 2021-08-27 by Michael Kerrisk, author of The Linux Programming Interface, maintainer of the Linux man-pages project.

For details of in-depth Linux/UNIX system programming training courses that I teach, look here.

Hosting by jambit GmbH.

Cover of TLPI

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-4"><a class="header" href="#简介-4">简介</a></h1>
<p>read 是 <a href="http://c.biancheng.net/view/1136.html">Shell 内置命令</a>，用来从标准输入中读取数据并赋值给变量。如果没有进行重定向，默认就是从键盘读取用户输入的数据；如果进行了重定向，那么可以从文件中读取数据</p>
<p><strong>语法</strong></p>
<pre><code class="language-sh">read [-options] [variables]
</code></pre>
<p><code>options</code>表示选项，如下表所示；<code>variables</code>表示用来存储数据的变量，可以有一个，也可以有多个。</p>
<p><code>options</code>和<code>variables</code>都是可选的，如果没有提供变量名，那么读取的数据将存放到环境变量 REPLY 中。</p>
<h1 id="选项"><a class="header" href="#选项">选项</a></h1>
<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody>
<tr><td>-a array</td><td>把读取的数据赋值给数组 array，从下标 0 开始。</td></tr>
<tr><td>-d delimiter</td><td>用字符串 delimiter 指定读取结束的位置，而不是一个换行符（读取到的数据不包括 delimiter）。</td></tr>
<tr><td>-e</td><td>在获取用户输入的时候，对功能键进行编码转换，不会直接显式功能键对应的字符。</td></tr>
<tr><td>-n num</td><td>读取 num 个字符，而不是整行字符。</td></tr>
<tr><td>-p prompt</td><td>显示提示信息，提示内容为 prompt。</td></tr>
<tr><td>-r</td><td>原样读取（Raw mode），不把反斜杠字符解释为转义字符。</td></tr>
<tr><td>-s</td><td>静默模式（Silent mode），不会在屏幕上显示输入的字符。当输入密码和其它确认信息的时候，这是很有必要的。</td></tr>
<tr><td>-t seconds</td><td>设置超时时间，单位为秒。如果用户没有在指定时间内输入完成，那么 read 将会返回一个非 0 的退出状态，表示读取失败。</td></tr>
<tr><td>-u fd</td><td>使用文件描述符 fd 作为输入源，而不是标准输入，类似于重定向。</td></tr>
</tbody></table>
<h1 id="示例-2"><a class="header" href="#示例-2">示例</a></h1>
<h2 id="多个变量"><a class="header" href="#多个变量">多个变量</a></h2>
<pre><code class="language-sh">#!/bin/bash
read -p &quot;Enter some information &gt; &quot; name url age
echo &quot;网站名字：$name&quot;
echo &quot;网址：$url&quot;
echo &quot;年龄：$age&quot;
</code></pre>
<h2 id="只读取一个字符"><a class="header" href="#只读取一个字符">只读取一个字符</a></h2>
<pre><code class="language-sh">#!/bin/bash
read -n 1 -p &quot;Enter a char &gt; &quot; char
printf &quot;\n&quot;  #换行
echo $char
</code></pre>
<h2 id="在指定时间内输入密码"><a class="header" href="#在指定时间内输入密码">在指定时间内输入密码</a></h2>
<pre><code class="language-sh">#!/bin/bash
if
    read -t 20 -sp &quot;Enter password in 20 seconds(once) &gt; &quot; pass1 &amp;&amp; printf &quot;\n&quot; &amp;&amp;  #第一次输入密码
    read -t 20 -sp &quot;Enter password in 20 seconds(again)&gt; &quot; pass2 &amp;&amp; printf &quot;\n&quot; &amp;&amp;  #第二次输入密码
    [ $pass1 == $pass2 ]  #判断两次输入的密码是否相等
then
    echo &quot;Valid password&quot;
else
    echo &quot;Invalid password&quot;
fi
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念-2"><a class="header" href="#概念-2">概念</a></h1>
<p>scp是secure copy的简写， 是 linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。scp 是加密的，rcp 是不加密的，scp 是 rcp 的加强版。</p>
<p>因为scp传输是加密的,可能会稍微影响一下速度。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p>
<h1 id="语法-4"><a class="header" href="#语法-4"><strong>语法</strong></a></h1>
<pre><code>scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]
[-l limit] [-o ssh_option] [-P port] [-S program]
[[user@]host1:]file1 [...] [[user@]host2:]file2
</code></pre>
<p><strong>简易写法</strong></p>
<pre><code>scp [可选参数] file_source... file_target 
</code></pre>
<h2 id="参数说明"><a class="header" href="#参数说明"><strong>参数说明：</strong></a></h2>
<pre><code class="language-text">-1： 强制scp命令使用协议ssh1
-2： 强制scp命令使用协议ssh2
-4： 强制scp命令只使用IPv4寻址
-6： 强制scp命令只使用IPv6寻址
-B： 使用批处理模式（传输过程中不询问传输口令或短语）
-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）
-p： 保留原文件的修改时间，访问时间和访问权限。
-q： 不显示传输进度条。
-r： 递归复制整个目录。
-v： 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。
-c cipher：        以cipher将数据传输进行加密，这个选项将直接传递给ssh。
-F ssh_config：    指定一个替代的ssh配置文件，此参数直接传递给ssh。
-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。
-l limit：         限定用户所能使用的带宽，以Kbit/s为单位。
-o ssh_option：    如果习惯于使用ssh_config(5)中的参数传递方式，
-P port：          注意是大写的P, port是指定数据传输用到的端口号
-S program：       指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。
</code></pre>
<h1 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h1>
<p><strong>复制目录时 最低级目录可以存在和不存在</strong></p>
<pre><code class="language-sh">#如果 存在c目录，则 拷贝的 目标路径为   /d/c/b
scp /a/b  /d/c/
#如果 不存在目录c 则拷贝的 目录路径为 /d/c
</code></pre>
<p><strong>只复制文件时目录必须先存在</strong></p>
<pre><code>#复制文件但不复制目录
scp /a/b* /d/c/d
#复制目录
scp -r /a/b* /d/c/d
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-5"><a class="header" href="#简介-5">简介</a></h1>
<p>select in 循环用来增强交互性，它可以显示出带编号的菜单，用户输入不同的编号就可以选择不同的菜单，并执行不同的功能。</p>
<p>select in 是 Shell 独有的一种循环，非常适合终端（Terminal）这样的交互场景</p>
<pre><code class="language-sh">select variable in value_list
do
    statements
done
</code></pre>
<h1 id="example-2"><a class="header" href="#example-2">Example</a></h1>
<pre><code class="language-sh">#!/bin/bash
echo &quot;What is your favourite OS?&quot;
select name in &quot;Linux&quot; &quot;Windows&quot; &quot;Mac OS&quot; &quot;UNIX&quot; &quot;Android&quot;
do
    echo $name
done
echo &quot;You have selected $name&quot;
</code></pre>
<h1 id="详解"><a class="header" href="#详解">详解</a></h1>
<p><code>#?</code>用来提示用户输入菜单编号；<code>^D</code>表示按下 Ctrl+D 组合键，它的作用是结束 select in 循环。</p>
<p>运行到 select 语句后，取值列表 value_list 中的内容会以菜单的形式显示出来，用户输入菜单编号，就表示选中了某个值，这个值就会赋给变量 variable，然后再执行循环体中的 statements（do 和 done 之间的部分）。</p>
<p>每次循环时 select 都会要求用户输入菜单编号，并使用环境变量 PS3 的值作为提示符，PS3 的默认值为<code>#?</code>，修改 PS3 的值就可以修改提示符。</p>
<p>如果用户输入的菜单编号不在范围之内，例如上面我们输入的 9，那么就会给 variable 赋一个空值；如果用户输入一个空值（什么也不输入，直接回车），会重新显示一遍菜单。</p>
<p>注意，select 是无限循环（死循环），输入空值，或者输入的值无效，都不会结束循环，只有遇到 break 语句，或者按下 Ctrl+D 组合键才能结束循环。</p>
<h1 id="完整实例"><a class="header" href="#完整实例">完整实例</a></h1>
<p>用户只有输入正确的编号才会结束循环，如果输入错误，会要求重新输入。</p>
<pre><code class="language-sh">#!/bin/bash
echo &quot;What is your favourite OS?&quot;
select name in &quot;Linux&quot; &quot;Windows&quot; &quot;Mac OS&quot; &quot;UNIX&quot; &quot;Android&quot;
do
    case $name in
        &quot;Linux&quot;)
            echo &quot;Linux是一个类UNIX操作系统，它开源免费，运行在各种服务器设备和嵌入式设备。&quot;
            break
            ;;
        &quot;Windows&quot;)
            echo &quot;Windows是微软开发的个人电脑操作系统，它是闭源收费的。&quot;
            break
            ;;
        &quot;Mac OS&quot;)
            echo &quot;Mac OS是苹果公司基于UNIX开发的一款图形界面操作系统，只能运行与苹果提供的硬件之上。&quot;
            break
            ;;
        &quot;UNIX&quot;)
            echo &quot;UNIX是操作系统的开山鼻祖，现在已经逐渐退出历史舞台，只应用在特殊场合。&quot;
            break
            ;;
        &quot;Android&quot;)
            echo &quot;Android是由Google开发的手机操作系统，目前已经占据了70%的市场份额。&quot;
            break
            ;;
        *)
            echo &quot;输入错误，请重新输入&quot;
    esac
done
</code></pre>
<pre><code class="language-sh">select name in &quot;xjq&quot; &quot;xjq2&quot; &quot;xjq3&quot; &quot;xjq4&quot; &quot;xjq5&quot;
do
        if [ ! -z &quot;${name}&quot; ];then
         break;
        fi
        echo please  input a valid  option
done

echo  $name
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-添加service服务"><a class="header" href="#linux-添加service服务">Linux 添加Service服务</a></h1>
<h2 id="服务组成"><a class="header" href="#服务组成">服务组成</a></h2>
<p><code>service httpd restart</code></p>
<p>由三部分组成service(服务)、httpd（程序名）、restart（相关命令）</p>
<h2 id="服务规定"><a class="header" href="#服务规定">服务规定</a></h2>
<p>1、程序是可执行程序
2、位置需放在/etc/init.d/目录下
3、相关命令，这个由程序本身决定（有没有指定）。
3.1 如果是已经有相关命令的，那么文件直接拷贝到/etc/init.d目录下，并给矛可执行权限。
3.2 如果是没有定义，那我们需要写一个脚本。并定义好相关命令。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="set命令"><a class="header" href="#set命令">set命令</a></h1>
<p><strong>set命令</strong>作用主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值。使用set更改shell特性时，符号&quot;+&quot;和&quot;-&quot;的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用<a href="http://man.linuxde.net/declare">declare</a>命令以<code>变量名=值</code>的格式进行定义即可。</p>
<h1 id="语法-5"><a class="header" href="#语法-5">语法</a></h1>
<pre><code>set(选项)(参数)
</code></pre>
<h1 id="选项-1"><a class="header" href="#选项-1">选项</a></h1>
<pre><code>NAME
    set - Set or unset values of shell options and positional parameters.

SYNOPSIS
    set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]

DESCRIPTION
    Set or unset values of shell options and positional parameters.
    
    Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.
    
    Options:
      -a  Mark variables which are modified or created for export.
      -b  Notify of job termination immediately.
      -e  Exit immediately if a command exits with a non-zero status.
      -f  Disable file name generation (globbing).
      -h  Remember the location of commands as they are looked up.
      -k  All assignment arguments are placed in the environment for a
          command, not just those that precede the command name.
      -m  Job control is enabled.
      -n  Read commands but do not execute them.
      -o option-name
          Set the variable corresponding to option-name:
              allexport    same as -a
              braceexpand  same as -B
              emacs        use an emacs-style line editing interface
              errexit      same as -e
              errtrace     same as -E
              functrace    same as -T
              hashall      same as -h
              histexpand   same as -H
              history      enable command history
              ignoreeof    the shell will not exit upon reading EOF
              interactive-comments
                           allow comments to appear in interactive commands
              keyword      same as -k
              monitor      same as -m
              noclobber    same as -C
              noexec       same as -n
              noglob       same as -f
              nolog        currently accepted but ignored
              notify       same as -b
              nounset      same as -u
              onecmd       same as -t
              physical     same as -P
              pipefail     the return value of a pipeline is the status of
                           the last command to exit with a non-zero status,
                           or zero if no command exited with a non-zero status
              posix        change the behavior of bash where the default
                           operation differs from the Posix standard to
                           match the standard
              privileged   same as -p
              verbose      same as -v
              vi           use a vi-style line editing interface
              xtrace       same as -x
      -p  Turned on whenever the real and effective user ids do not match.
          Disables processing of the $ENV file and importing of shell
          functions.  Turning this option off causes the effective uid and
          gid to be set to the real uid and gid.
      -t  Exit after reading and executing one command.
      -u  Treat unset variables as an error when substituting.
      -v  Print shell input lines as they are read.
      -x  Print commands and their arguments as they are executed.
      -B  the shell will perform brace expansion
      -C  If set, disallow existing regular files to be overwritten
          by redirection of output.
      -E  If set, the ERR trap is inherited by shell functions.
      -H  Enable ! style history substitution.  This flag is on
          by default when the shell is interactive.
      -P  If set, do not resolve symbolic links when executing commands
          such as cd which change the current directory.
      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.
      --  Assign any remaining arguments to the positional parameters.
          If there are no remaining arguments, the positional parameters
          are unset. 重置 shell位置参数
      -   Assign any remaining arguments to the positional parameters.
          The -x and -v options are turned off.
    
    Using + rather than - causes these flags to be turned off.  The
    flags can also be used upon invocation of the shell.  The current
    set of flags may be found in $-.  The remaining n ARGs are positional
    parameters and are assigned, in order, to $1, $2, .. $n.  If no
    ARGs are given, all shell variables are printed.
    
    Exit Status:
    Returns success unless an invalid option is given.xxxxxxxxxx -a：标示已修改的变量，以供输出至环境变量。-b：使被中止的后台程序立刻回报执行状态。-C：转向所产生的文件无法覆盖已存在的文件。-d：Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消。-e：若指令传回值不等于0，则立即退出shell。-f：取消使用通配符。-h：自动记录函数的所在位置。-H Shell：可利用&quot;!&quot;加&lt;指令编号&gt;的方式来执行history中记录的指令。-k：指令所给的参数都会被视为此指令的环境变量。-l：记录for循环的变量名称。-m：使用监视模式。-n：只读取指令，而不实际执行。-p：启动优先顺序模式。-P：启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接。-t：执行完随后的指令，即退出shell。-u：当执行时使用到未定义过的变量，则显示错误信息。-v：显示shell所读取的输入值。-x：执行指令后，会先显示该指令及所下的参数。 -o option-name          Set the variable corresponding to option-name:              allexport    same as -a              braceexpand  same as -B              emacs        use an emacs-style line editing interface              errexit      same as -e              errtrace     same as -E              functrace    same as -T              hashall      same as -h              histexpand   same as -H              history      enable command history              ignoreeof    the shell will not exit upon reading EOF              interactive-comments                           allow comments to appear in interactive commands              keyword      same as -k              monitor      same as -m              noclobber    same as -C              noexec       same as -n              noglob       same as -f              nolog        currently accepted but ignored              notify       same as -b              nounset      same as -u              onecmd       same as -t              physical     same as -P              pipefail     the return value of a pipeline is the status of                           the last command to exit with a non-zero status,                           or zero if no command exited with a non-zero status              posix        change the behavior of bash where the default                           operation differs from the Posix standard to                           match the standard              privileged   same as -p              verbose      same as -v              vi           use a vi-style line editing interface              xtrace       same as -xNAME    set - Set or unset values of shell options and positional parameters.SYNOPSIS    set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]DESCRIPTION    Set or unset values of shell options and positional parameters.        Change the value of shell attributes and positional parameters, or    display the names and values of shell variables.        Options:      -a  Mark variables which are modified or created for export.      -b  Notify of job termination immediately.      -e  Exit immediately if a command exits with a non-zero status.      -f  Disable file name generation (globbing).      -h  Remember the location of commands as they are looked up.      -k  All assignment arguments are placed in the environment for a          command, not just those that precede the command name.      -m  Job control is enabled.      -n  Read commands but do not execute them.      -o option-name          Set the variable corresponding to option-name:              allexport    same as -a              braceexpand  same as -B              emacs        use an emacs-style line editing interface              errexit      same as -e              errtrace     same as -E              functrace    same as -T              hashall      same as -h              histexpand   same as -H              history      enable command history              ignoreeof    the shell will not exit upon reading EOF              interactive-comments                           allow comments to appear in interactive commands              keyword      same as -k              monitor      same as -m              noclobber    same as -C              noexec       same as -n              noglob       same as -f              nolog        currently accepted but ignored              notify       same as -b              nounset      same as -u              onecmd       same as -t              physical     same as -P              pipefail     the return value of a pipeline is the status of                           the last command to exit with a non-zero status,                           or zero if no command exited with a non-zero status              posix        change the behavior of bash where the default                           operation differs from the Posix standard to                           match the standard              privileged   same as -p              verbose      same as -v              vi           use a vi-style line editing interface              xtrace       same as -x      -p  Turned on whenever the real and effective user ids do not match.          Disables processing of the $ENV file and importing of shell          functions.  Turning this option off causes the effective uid and          gid to be set to the real uid and gid.      -t  Exit after reading and executing one command.      -u  Treat unset variables as an error when substituting.      -v  Print shell input lines as they are read.      -x  Print commands and their arguments as they are executed.      -B  the shell will perform brace expansion      -C  If set, disallow existing regular files to be overwritten          by redirection of output.      -E  If set, the ERR trap is inherited by shell functions.      -H  Enable ! style history substitution.  This flag is on          by default when the shell is interactive.      -P  If set, do not resolve symbolic links when executing commands          such as cd which change the current directory.      -T  If set, the DEBUG and RETURN traps are inherited by shell functions.      --  Assign any remaining arguments to the positional parameters.          If there are no remaining arguments, the positional parameters          are unset.      -   Assign any remaining arguments to the positional parameters.          The -x and -v options are turned off.        Using + rather than - causes these flags to be turned off.  The    flags can also be used upon invocation of the shell.  The current    set of flags may be found in $-.  The remaining n ARGs are positional    parameters and are assigned, in order, to $1, $2, .. $n.  If no    ARGs are given, all shell variables are printed.        Exit Status:    Returns success unless an invalid option is given.
</code></pre>
<p>使用declare命令定义一个新的环境变量&quot;mylove&quot;，并且将其值设置为&quot;Visual C++&quot;，输入如下命令：</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概述-4"><a class="header" href="#概述-4">概述</a></h1>
<p>字符串（String）就是一系列字符的组合。字符串是 Shell 编程中最常用的数据类型之一（除了数字和字符串，也没有其他类型了）。</p>
<h2 id="三种形式的区别"><a class="header" href="#三种形式的区别">三种形式的区别：</a></h2>
<ol>
<li>由单引号<code>' '</code>包围的字符串：</li>
</ol>
<ul>
<li>任何字符都会原样输出，在其中使用变量是无效的。</li>
<li>字符串中不能出现单引号，即使对单引号进行转义也不行。</li>
</ul>
<ol start="2">
<li>由双引号<code>&quot; &quot;</code>包围的字符串：</li>
</ol>
<ul>
<li>如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。</li>
<li>字符串中可以出现双引号，只要它被转义了就行。</li>
</ul>
<ol start="3">
<li>不被引号包围的字符串</li>
</ol>
<ul>
<li>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号<code>&quot; &quot;</code>包围的字符串一样。</li>
<li><strong>字符串中不能出现空格，否则空格后边的字符串会作为其他变量或者命令解析。</strong></li>
</ul>
<h2 id="获取字符串长度"><a class="header" href="#获取字符串长度">获取字符串长度</a></h2>
<pre><code class="language-sh">${#string_name}
</code></pre>
<h1 id="shell字符串拼接连接合并"><a class="header" href="#shell字符串拼接连接合并">Shell字符串拼接（连接、合并）</a></h1>
<p>在 Shell 中你不需要使用任何运算符，将两个字符串并排放在一起就能实现拼接，非常简单粗暴</p>
<pre><code class="language-sh">#!/bin/bash
name=&quot;Shell&quot;
url=&quot;http://c.biancheng.net/shell/&quot;
str1=$name$url  #中间不能有空格
str2=&quot;$name $url&quot;  #如果被双引号包围，那么中间可以有空格
str3=$name&quot;: &quot;$url  #中间可以出现别的字符串
str4=&quot;$name: $url&quot;  #这样写也可以
str5=&quot;${name}Script: ${url}index.html&quot;  #这个时候需要给变量名加上大括号
echo $str1
echo $str2
echo $str3
echo $str4
echo $str5
</code></pre>
<h1 id="shell字符串截取"><a class="header" href="#shell字符串截取">Shell字符串截取</a></h1>
<h2 id="从指定位置开始截取"><a class="header" href="#从指定位置开始截取">从指定位置开始截取</a></h2>
<ul>
<li>
<p>这种方式需要两个参数：除了指定起始位置，还需要截取长度，才能最终确定要截取的字符串。</p>
</li>
<li>
<p>既然需要指定起始位置，那么就涉及到计数方向的问题，到底是从字符串左边开始计数，还是从字符串右边开始计数。答案是 Shell 同时支持两种计数方式。</p>
</li>
</ul>
<h3 id="从字符串左边开始计数"><a class="header" href="#从字符串左边开始计数">从字符串左边开始计数</a></h3>
<pre><code class="language-sh"># 如果想从字符串的左边开始计数，那么截取字符串的具体格式如下：
${string: start :length}

url=&quot;c.biancheng.net&quot;
echo ${url: 2: 9}

url=&quot;c.biancheng.net&quot;
echo ${url: 2}  #省略 length，截取到字符串末尾
</code></pre>
<h2 id="从右边开始计数"><a class="header" href="#从右边开始计数">从右边开始计数</a></h2>
<pre><code class="language-sh">${string: 0-start :length}
# 同第 1) 种格式相比，第 2) 种格式仅仅多了0-，这是固定的写法，专门用来表示从字符串右边开始计数。
</code></pre>
<p>这里需要强调两点：</p>
<ul>
<li>从左边开始计数时，起始数字是 0（这符合程序员思维）；从右边开始计数时，起始数字是 1（这符合常人思维）。计数方向不同，起始数字也不同。</li>
<li><strong>不管从哪边开始计数，截取方向都是从左到右。</strong></li>
</ul>
<pre><code class="language-sh">url=&quot;c.biancheng.net&quot;
echo ${url: 0-13: 9}
#结果为biancheng。从右边数，b是第 13 个字符。
</code></pre>
<h2 id="从指定字符子字符串开始截取"><a class="header" href="#从指定字符子字符串开始截取">从指定字符（子字符串）开始截取</a></h2>
<p>这种截取方式无法指定字符串长度，只能从指定字符（子字符串）截取到字符串末尾。Shell 可以截取指定字符（子字符串）右边的所有字符，也可以截取左边的所有字符。</p>
<h3 id="使用号可以截取指定字符"><a class="header" href="#使用号可以截取指定字符"><strong>使用<code>#</code>号可以截取指定字符</strong></a></h3>
<p>（或者子字符串）右边的所有字符，具体格式如下：</p>
<pre><code class="language-sh">${string#*chars}
</code></pre>
<p>其中，string 表示要截取的字符，chars 是指定的字符（或者子字符串），<code>*</code>是通配符的一种，表示任意长度的字符串。<code>*chars</code>连起来使用的意思是：忽略左边的所有字符，直到遇见 chars（chars 不会被截取）。</p>
<pre><code class="language-sh">url=&quot;http://c.biancheng.net/index.html&quot;
echo ${url#*:}
</code></pre>
<p>如果希望直到最后一个指定字符（子字符串）再匹配结束，那么可以使用<code>##</code>，具体格式为：</p>
<pre><code class="language-sh">${string##*chars}
</code></pre>
<pre><code class="language-sh">#!/bin/bash
url=&quot;http://c.biancheng.net/index.html&quot;
echo ${url#*/}    #结果为 /c.biancheng.net/index.html
echo ${url##*/}   #结果为 index.html
str=&quot;---aa+++aa@@@&quot;
echo ${str#*aa}   #结果为 +++aa@@@
echo ${str##*aa}  #结果为 @@@
</code></pre>
<h3 id="使用--截取左边字符"><a class="header" href="#使用--截取左边字符">使用 % 截取左边字符</a></h3>
<pre><code class="language-sh">使用%号可以截取指定字符（或者子字符串）左边的所有字符，具体格式如下：
${string%chars*}
</code></pre>
<p>请注意<code>*</code>的位置，因为要截取 chars 左边的字符，而忽略 chars 右边的字符，所以<code>*</code>应该位于 chars 的右侧。其他方面<code>%</code>和<code>#</code>的用法相同，这里不再赘述，仅举例说明：</p>
<pre><code class="language-sh">#!/bin/bash
url=&quot;http://c.biancheng.net/index.html&quot;
echo ${url%/*}  #结果为 http://c.biancheng.net
echo ${url%%/*}  #结果为 http:
str=&quot;---aa+++aa@@@&quot;
echo ${str%aa*}  #结果为 ---aa+++
echo ${str%%aa*}  #结果为 ---
</code></pre>
<h2 id="汇总"><a class="header" href="#汇总">汇总</a></h2>
<p>最后，我们对以上 8 种格式做一个汇总，请看下表：</p>
<table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody>
<tr><td>${string: start :length}</td><td>从 string 字符串的左边第 start 个字符开始，向右截取 length 个字符。</td></tr>
<tr><td>${string: start}</td><td>从 string 字符串的左边第 start 个字符开始截取，直到最后。</td></tr>
<tr><td>${string: 0-start :length}</td><td>从 string 字符串的右边第 start 个字符开始，向右截取 length 个字符。</td></tr>
<tr><td>${string: 0-start}</td><td>从 string 字符串的右边第 start 个字符开始截取，直到最后。</td></tr>
<tr><td>${string#*chars}</td><td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td></tr>
<tr><td>${string##*chars}</td><td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 右边的所有字符。</td></tr>
<tr><td>${string%*chars}</td><td>从 string 字符串第一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。</td></tr>
<tr><td>${string%%*chars}</td><td>从 string 字符串最后一次出现 *chars 的位置开始，截取 *chars 左边的所有字符。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="positional-parameterbash中的位置参数"><a class="header" href="#positional-parameterbash中的位置参数">Positional parameter（bash中的位置参数）</a></h1>
<p>A <strong>positional parameter</strong> is an argument specified on the command line, used to launch the current process in a shell.</p>
<p>Positional parameter values are stored in a special set of variables maintained by the shell</p>
<p><img src="10.Linux//images/shell_positional_parameters.png" alt="" /></p>
<table><thead><tr><th>变量</th><th>值</th><th></th></tr></thead><tbody>
<tr><td>$0</td><td>文件名</td><td></td></tr>
<tr><td>$1</td><td>one</td><td></td></tr>
<tr><td>$2</td><td>two</td><td></td></tr>
<tr><td>$#</td><td>变量个数</td><td></td></tr>
<tr><td>$@</td><td>one two three</td><td></td></tr>
<tr><td>$*</td><td>one tow three</td><td></td></tr>
</tbody></table>
<p>在不加双引号的时候$*和$@是一样，</p>
<p>如果加了双引号了，$*会被翻译成 $1c$2c$3c</p>
<p>where <em>c</em> is the first character of <strong>$IFS</strong>, bash's internal field separator variable. The IFS is used for word splitting, and its default value is &quot;space, tab, or newline&quot; — this is where bash sees the beginning and end of one word.  c是$IFS的第一个字母，bash的internal field separator变量（默认为<space><tab><newline>），内置字段分割变量。（所以c是空格）</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stat命令"><a class="header" href="#stat命令">Stat命令</a></h1>
<p><strong>用法</strong>： <code>stat [OPTION]... FILE...</code></p>
<h1 id="选项-2"><a class="header" href="#选项-2">选项</a></h1>
<p><strong>-L</strong>, --dereference     跟随引用
<strong>-f</strong>, --file-system     展示文件系统状态而不是文件状态
<strong>-c</strong>  --format=FORMAT   使用格式化，对于每一个 FORMAT的后面会应用一个换行</p>
<p>--printf=FORMAT   like --format, 会解析转义符。不会强制应用换行符</p>
<p><strong>-t</strong>, --terse       以简洁的形式打印信息
--help     显示此帮助并退出
--version  输出版本信息并退出</p>
<h1 id="文件状态格式符"><a class="header" href="#文件状态格式符">文件状态格式符</a></h1>
<p>The valid format sequences for files (without --file-system):</p>
<table><thead><tr><th>格式符</th><th>说明</th><th>英文</th></tr></thead><tbody>
<tr><td>%a</td><td>八进制的访问权限</td><td>access rights in octal</td></tr>
<tr><td>%A</td><td>人类可读的访问权限</td><td>access rights in human readable form</td></tr>
<tr><td>%b</td><td>分配的 块</td><td>number of blocks allocated (see %B)</td></tr>
<tr><td>%B</td><td>每个块有多少个字节</td><td>the size in bytes of each block reported by %b</td></tr>
<tr><td>%C</td><td>SELinux security 上下文</td><td>SELinux security context string</td></tr>
<tr><td>%d/%D</td><td>十进制/十六进制的设备号</td><td>device number in decimal/device number in hex</td></tr>
<tr><td>%f</td><td>raw mode in hex</td><td>raw mode in hex</td></tr>
<tr><td>%F</td><td>文件类型</td><td>file type</td></tr>
<tr><td>%g/%G</td><td>拥有者的 群组编号/名称</td><td>group ID of owner/group name of owner</td></tr>
<tr><td>%h</td><td>硬链接的个数</td><td>number of hard links</td></tr>
<tr><td>%i</td><td>i节点的个数</td><td>inode number</td></tr>
<tr><td>%m</td><td>挂载点</td><td>mount point</td></tr>
<tr><td>%n</td><td>文件名</td><td>file name</td></tr>
<tr><td>%N</td><td>文件名 跟随了符号链接</td><td>quoted file name with dereference if symbolic link</td></tr>
<tr><td>%o</td><td></td><td>optimal I/O transfer size hint</td></tr>
<tr><td>%s</td><td>文件大小</td><td>total size, in bytes</td></tr>
<tr><td>%t</td><td>主设备被号</td><td>major device type in hex, for character/block device special files</td></tr>
<tr><td>%T</td><td>次设备号</td><td>minor device type in hex, for character/block device special files</td></tr>
<tr><td>%u/%U</td><td>用户id/用户名</td><td>user ID of owner/user name of owner</td></tr>
<tr><td>%w</td><td>创建时间，可读的，如果未知则是-</td><td>time of file birth, human-readable; - if unknown</td></tr>
<tr><td>%W</td><td>创建时间，从 Epoch 开始的秒数，如果未知则为0</td><td>time of file birth, seconds since Epoch; 0 if unknown</td></tr>
<tr><td>%x</td><td>访问时间，可读，如果未知则是-</td><td>time of last access, human-readable</td></tr>
<tr><td>%X</td><td>访问时间，从 Epoch 开始的秒数</td><td>time of last access, seconds since Epoch</td></tr>
<tr><td>%y</td><td>修改时间，可读</td><td>time of last modification, human-readable</td></tr>
<tr><td>%Y</td><td>修改时间，从 Epoch 开始的秒数</td><td>time of last modification, seconds since Epoch</td></tr>
<tr><td>%z</td><td>文件状态修改时间，人类可读的</td><td>time of last change, human-readable</td></tr>
<tr><td>%Z</td><td>文件状态修改时间，从 Epoch 开始的秒数</td><td>time of last change, seconds since Epoch</td></tr>
</tbody></table>
<p>​</p>
<h1 id="文件系统状态格式符"><a class="header" href="#文件系统状态格式符">文件系统状态格式符</a></h1>
<table><thead><tr><th>格式符</th><th>说明</th><th>英文</th></tr></thead><tbody>
<tr><td>%a</td><td>非超级用户来说。可用的块</td><td>free blocks available to non-superuser</td></tr>
<tr><td>%b</td><td>文件系统总共的块</td><td>total data blocks in file system</td></tr>
<tr><td>%c</td><td>总共i结点的 个数</td><td>total file nodes in file system</td></tr>
<tr><td>%d</td><td>剩余i节点的个数</td><td>free file nodes in file system</td></tr>
<tr><td>%f</td><td>剩余的块个数</td><td>free blocks in file system</td></tr>
<tr><td>%i</td><td>文件系统id 十六进制</td><td>file system ID in hex</td></tr>
<tr><td>%l</td><td>最长的文件名</td><td>maximum length of filenames</td></tr>
<tr><td>%n</td><td>文件名</td><td>file name</td></tr>
<tr><td>%s</td><td>推荐的 用于更快的传输的块大小</td><td>block size (for faster transfers)</td></tr>
<tr><td>%S</td><td>基础的块大小</td><td>fundamental block size (for block counts)</td></tr>
<tr><td>%t</td><td>十六进制的 文件系统类型</td><td>file system type in hex</td></tr>
<tr><td>%T</td><td>文件系统类型，可读的</td><td>file system type in human readable form</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法-6"><a class="header" href="#语法-6">语法</a></h1>
<pre><code>tar [OPTION...] [FILE]...
</code></pre>
<p>DESCRIPTION</p>
<h1 id="简述"><a class="header" href="#简述">简述</a></h1>
<p>​       GNU `tar' saves many files together into a single tape or disk archive, and can restore individual files from the archive.</p>
<p>将多个文件 保存成一个文件，并且可以复原</p>
<p>请注意，本手册页仅包含非常简短的描述（或更像是可能的功能列表），该描述最初是由help2man程序生成的，</p>
<p>tar的完整文档保留为Texinfo手册，如果在您的站点上正确安装了info和tar程序，则可以使用“ info tar”命令来访问完整的手册。</p>
<h1 id="例子"><a class="header" href="#例子">例子</a></h1>
<pre><code class="language-sh"># Create archive.tar from files foo and bar.
tar -cf archive.tar foo bar
# List all files in archive.tar verbosely.
tar -tvf archive.tar
# Extract all files from archive.tar.
tar -xf archive.tar
</code></pre>
<h1 id="操作模式"><a class="header" href="#操作模式">操作模式</a></h1>
<pre><code>-A, --catenate, --concatenate
              append tar files to an archive
-c, --create
          create a new archive

-d, --diff, --compare
          find differences between archive and file system

--delete
          delete from the archive (not on mag tapes!)

-r, --append
          append files to the end of an archive

-t, --list
          list the contents of an archive

--test-label
          test the archive volume label and exit

-u, --update
          only append files newer than copy in archive

-x, --extract, --get
          extract files from an archive
</code></pre>
<h1 id="通用选项"><a class="header" href="#通用选项">通用选项</a></h1>
<pre><code>    -C, --directory=DIR
              change to directory DIR
 	-f, --file=ARCHIVE
          use archive file or device ARCHIVE

   -j, --bzip2
          filter the archive through bzip2

    -J, --xz
          filter the archive through xz

   -p, --preserve-permissions
          extract  information  about  file permissions (default for superuser)

   -v, --verbose
          verbosely list files processed

   -z, --gzip
          filter the archive through gzip
</code></pre>
<h1 id="操作修饰符"><a class="header" href="#操作修饰符">操作修饰符</a></h1>
<pre><code>	--check-device
    	  check device numbers when creating incremental archives (default)
	-g, --listed-incremental=FILE
          handle new GNU-format incremental backup

   -G, --incremental
          handle old GNU-format incremental backup

   --ignore-failed-read
          do not exit with nonzero on unreadable files

   --level=NUMBER
          dump level for created listed-incremental archive

   -n, --seek
          archive is seekable

   --no-check-device
          do not check device numbers when creating incremental archives

   --no-seek
          archive is not seekable

   --occurrence[=NUMBER]
          process only the NUMBERth occurrence of each file in the archive; this option is valid only in conjunction with one of the subcommands --delete, --diff, --extract or --list and when a list of files is given either on the command line or via  the  -T
          option; NUMBER defaults to 1

   --sparse-version=MAJOR[.MINOR]
          set version of the sparse format to use (implies --sparse)

   -S, --sparse
          handle sparse files efficiently
</code></pre>
<h1 id="覆盖控制"><a class="header" href="#覆盖控制">覆盖控制</a></h1>
<pre><code>	-k, --keep-old-files
              don't replace existing files when extracting, treat them as errors
	--keep-newer-files
          don't replace existing files that are newer than their archive copies

   --keep-directory-symlink
          Don't replace existing symlinks to directories when extracting.

   --no-overwrite-dir
          preserve metadata of existing directories

   --overwrite
          overwrite existing files when extracting

   --overwrite-dir
          overwrite metadata of existing directories when extracting (default)

   --recursive-unlink
          empty hierarchies prior to extracting directory

   --remove-files
          remove files after adding them to the archive

   --skip-old-files
          don't replace existing files when extracting, silently skip over them

   -U, --unlink-first
          remove each file prior to extracting over it

   -W, --verify
          attempt to verify the archive after writing it
</code></pre>
<h1 id="重定向输出"><a class="header" href="#重定向输出">重定向输出</a></h1>
<pre><code>--ignore-command-error ignore exit codes of children
--no-ignore-command-error
          treat non-zero exit codes of children as error

   -O, --to-stdout
          extract files to standard output

   --to-command=COMMAND
          pipe extracted files to another program
</code></pre>
<h1 id="处理文件属性"><a class="header" href="#处理文件属性">处理文件属性</a></h1>
<pre><code>      --atime-preserve[=METHOD]
              preserve access times on dumped files, either by restoring the times after reading (METHOD='replace'; default) or by not setting the times in the first place (METHOD='system')
   --delay-directory-restore
          delay setting modification times and permissions of extracted directories until the end of extraction

   --group=NAME
          force NAME as group for added files

   --mode=CHANGES
          force (symbolic) mode CHANGES for added files

   --mtime=DATE-OR-FILE
          set mtime for added files from DATE-OR-FILE

   -m, --touch
          don't extract file modified time

   --no-delay-directory-restore
          cancel the effect of --delay-directory-restore option

   --no-same-owner
          extract files as yourself (default for ordinary users)

   --no-same-permissions
          apply the user's umask when extracting permissions from the archive (default for ordinary users)

   --numeric-owner
          always use numbers for user/group names

   --owner=NAME
          force NAME as owner for added files

   -p, --preserve-permissions, --same-permissions
          extract information about file permissions (default for superuser)

   --preserve
          same as both -p and -s

   --same-owner
          try extracting files with the same ownership as exists in the archive (default for superuser)

   -s, --preserve-order, --same-order
          sort names to extract to match archive
</code></pre>
<h1 id="处理文件扩展属性"><a class="header" href="#处理文件扩展属性">处理文件扩展属性</a></h1>
<pre><code>          --acls Enable the POSIX ACLs support
   --no-acls
          Disable the POSIX ACLs support

   --no-selinux
          Disable the SELinux context support

   --no-xattrs
          Disable extended attributes support

   --selinux
          Enable the SELinux context support

   --xattrs
          Enable extended attributes support

   --xattrs-exclude=MASK
          specify the exclude pattern for xattr keys

   --xattrs-include=MASK
          specify the include pattern for xattr keys
</code></pre>
<h1 id="设备选择和切换"><a class="header" href="#设备选择和切换">设备选择和切换</a></h1>
<pre><code>   -f, --file=ARCHIVE
              use archive file or device ARCHIVE
  --force-local
          archive file is local even if it has a colon

   -F, --info-script=NAME, --new-volume-script=NAME
          run script at end of each tape (implies -M)

   -L, --tape-length=NUMBER
          change tape after writing NUMBER x 1024 bytes

   -M, --multi-volume
          create/list/extract multi-volume archive

   --rmt-command=COMMAND
          use given rmt COMMAND instead of rmt

   --rsh-command=COMMAND
          use remote COMMAND instead of rsh

   --volno-file=FILE
          use/update the volume number in FILE
</code></pre>
<h1 id="块设备"><a class="header" href="#块设备">块设备</a></h1>
<pre><code>  -b, --blocking-factor=BLOCKS
              BLOCKS x 512 bytes per record
-B, --read-full-records
          reblock as we read (for 4.2BSD pipes)

   -i, --ignore-zeros
          ignore zeroed blocks in archive (means EOF)

   --record-size=NUMBER
          NUMBER of bytes per record, multiple of 512
</code></pre>
<h1 id="archive-format-selection"><a class="header" href="#archive-format-selection">Archive format selection</a></h1>
<pre><code>      -H, --format=FORMAT
              create archive of the given format
	 FORMAT is one of the following:

                 gnu    GNU tar 1.13.x format

                 oldgnu GNU format as per tar &lt;= 1.12

                 pax    POSIX 1003.1-2001 (pax) format

                 posix  same as pax

                 ustar  POSIX 1003.1-1988 (ustar) format

                 v7     old V7 tar format

   --old-archive, --portability
          same as --format=v7

   --pax-option=keyword[[:]=value][,keyword[[:]=value]]...
          control pax keywords

   --posix
          same as --format=posix

   -V, --label=TEXT
          create archive with volume name TEXT; at list/extract time, use TEXT as a globbing pattern for volume name
</code></pre>
<h1 id="压缩选项"><a class="header" href="#压缩选项">压缩选项</a></h1>
<pre><code>    -a, --auto-compress
              use archive suffix to determine the compression program
   -I, --use-compress-program=PROG
          filter through PROG (must accept -d)

   -j, --bzip2
          filter the archive through bzip2

   -J, --xz
          filter the archive through xz

   --lzip filter the archive through lzip

   --lzma filter the archive through lzma

   --lzop

   --no-auto-compress
          do not use archive suffix to determine the compression program

   -z, --gzip, --gunzip, --ungzip
          filter the archive through gzip

   -Z, --compress, --uncompress
          filter the archive through compress

   Note: You might need to install external program (lzip/ncompress/lzma...) to use some of these compression options
</code></pre>
<h1 id="本地文件选择"><a class="header" href="#本地文件选择">本地文件选择</a></h1>
<pre><code>  --add-file=FILE
              add given FILE to the archive (useful if its name starts with a dash)
 --backup[=CONTROL]
          backup before removal, choose version CONTROL

   -C, --directory=DIR
          change to directory DIR

   --exclude=PATTERN
          exclude files, given as a PATTERN

   --exclude-backups
          exclude backup and lock files

   --exclude-caches
          exclude contents of directories containing CACHEDIR.TAG, except for the tag file itself

   --exclude-caches-all
          exclude directories containing CACHEDIR.TAG

   --exclude-caches-under exclude everything under directories containing
          CACHEDIR.TAG

   --exclude-tag=FILE
          exclude contents of directories containing FILE, except for FILE itself

   --exclude-tag-all=FILE exclude directories containing FILE

   --exclude-tag-under=FILE
          exclude everything under directories containing FILE

   --exclude-vcs
          exclude version control system directories

   -h, --dereference
          follow symlinks; archive and dump the files they point to

   --hard-dereference
          follow hard links; archive and dump the files they refer to

   -K, --starting-file=MEMBER-NAME
          begin at member MEMBER-NAME in the archive

   --newer-mtime=DATE
          compare date and time when data changed only

   --no-null
          disable the effect of the previous --null option

   --no-recursion
          avoid descending automatically in directories

   --no-unquote
          do not unquote filenames read with -T

   --null                 -T reads null-terminated names, disable -C

   -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE
          only store files newer than DATE-OR-FILE

   --one-file-system
          stay in local file system when creating archive

   -P, --absolute-names
          don't strip leading `/'s from file names

   --recursion
          recurse into directories (default)

   --suffix=STRING
          backup before removal, override usual suffix ('~' unless overridden by environment variable SIMPLE_BACKUP_SUFFIX)

   -T, --files-from=FILE
          get names to extract or create from FILE

   --unquote
          unquote filenames read with -T (default)

   -X, --exclude-from=FILE
          exclude patterns listed in FILE
</code></pre>
<h1 id="文件名转换"><a class="header" href="#文件名转换">文件名转换</a></h1>
<pre><code>      --strip-components=NUMBER
              strip NUMBER leading components from file names on extraction
  --transform=EXPRESSION, --xform=EXPRESSION
          use sed replace EXPRESSION to transform file names

          File name matching options (affect both exclude and include patterns):

   --anchored
          patterns match file name start

   --ignore-case
          ignore case

   --no-anchored
          patterns match after any `/' (default for exclusion)

   --no-ignore-case
          case sensitive matching (default)

   --no-wildcards
          verbatim string matching

   --no-wildcards-match-slash
          wildcards do not match `/'

   --wildcards
          use wildcards (default)

   --wildcards-match-slash
          wildcards match `/' (default for exclusion)
</code></pre>
<h1 id="信息输出"><a class="header" href="#信息输出">信息输出</a></h1>
<pre><code>    --checkpoint[=NUMBER]
              display progress messages every NUMBERth record (default 10)
 --checkpoint-action=ACTION
          execute ACTION on each checkpoint

   --full-time
          print file time to its full resolution

   --index-file=FILE
          send verbose output to FILE

   -l, --check-links
          print a message if not all links are dumped

   --no-quote-chars=STRING
          disable quoting for characters from STRING

   --quote-chars=STRING
          additionally quote characters from STRING

   --quoting-style=STYLE
          set name quoting style; see below for valid STYLE values

   -R, --block-number
          show block number within archive with each message

   --show-defaults
          show tar defaults

   --show-omitted-dirs
          when listing or extracting, list each directory that does not match search criteria

   --show-transformed-names, --show-stored-names
          show file or archive names after transformation

   --totals[=SIGNAL]
          print total bytes after processing the archive; with an argument - print total bytes when this SIGNAL is delivered; Allowed signals are: SIGHUP, SIGQUIT, SIGINT, SIGUSR1 and SIGUSR2; the names without SIG prefix are also accepted

   --utc  print file modification dates in UTC

   -v, --verbose
          verbosely list files processed

   --warning=KEYWORD
          warning control

   -w, --interactive, --confirmation
          ask for confirmation for every action
</code></pre>
<h1 id="其他选项"><a class="header" href="#其他选项">其他选项</a></h1>
<pre><code>        -?, --help
              give this help list
 --restrict
          disable use of some potentially harmful options

   --usage
          give a short usage message

   --version
          print program version

   Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.

   The backup suffix is `~', unless set with --suffix or SIMPLE_BACKUP_SUFFIX.  The version control may be set with --backup or VERSION_CONTROL, values are:

   none, off
          never make backups

   t, numbered
          make numbered backups

   nil, existing
          numbered if numbered backups exist, simple otherwise

   never, simple
          always make simple backups

   Valid arguments for the --quoting-style option are:

          literal shell shell-always c c-maybe escape locale clocale
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h1>
<p>top 命令可以动态地持续监听进程地运行状态，与此同时，该命令还提供了一个交互界面，用户可以根据需要，人性化地定制自己的输出，进而更清楚地了进程的运行状态。</p>
<h1 id="格式"><a class="header" href="#格式">格式</a></h1>
<p><strong>基本格式</strong></p>
<pre><code>top [选项]
</code></pre>
<p><strong>选项</strong></p>
<ul>
<li>-d 秒数：指定 top 命令每隔几秒更新。默认是 3 秒；</li>
<li>-b：使用批处理模式输出。一般和&quot;-n&quot;选项合用，用于把 top 命令重定向到文件中；</li>
<li>-n 次数：指定 top 命令执行的次数。</li>
<li>-p 进程PID：仅查看指定 ID 的进程；</li>
<li>-q 没有任何延迟的刷新</li>
<li>-s：使 top 命令在安全模式中运行，避免在交互模式中出现错误；</li>
<li>-u 用户名：只监听某个用户的进程；</li>
<li>-i 不显示任何闲置进程或者僵尸进程</li>
<li>-c 显示整个命令行</li>
</ul>
<p><strong>交互式命令选项</strong></p>
<p>常用交互操作</p>
<ul>
<li>
<p>基础操作</p>
<ul>
<li>1：显示CPU详细信息，每核显示一行</li>
<li>d / s ：修改刷新频率，单位为秒</li>
<li>h：可显示帮助界面</li>
<li>n：指定进程列表显示行数，默认为满屏行数</li>
<li>q：退出top</li>
</ul>
</li>
<li>
<p>面板隐藏显示</p>
<ul>
<li>l：隐藏/显示第1行负载信息；</li>
<li>t：隐藏/显示第2~3行CPU信息；</li>
<li>m：隐藏/显示第4~5行内存信息；</li>
</ul>
</li>
<li>
<p>进程列表排序</p>
<ul>
<li>M：根据驻留内存大小进行排序；</li>
<li>P：根据CPU使用百分比大小进行排序；</li>
<li>T：根据时间/累计时间进行排序；</li>
</ul>
</li>
</ul>
<h1 id="top-命令的执行结果"><a class="header" href="#top-命令的执行结果">top 命令的执行结果</a></h1>
<pre><code>top - 12:26:46 up 1 day, 13:32, 2 users, load average: 0.00, 0.00, 0.00
Tasks: 95 total, 1 running, 94 sleeping, 0 stopped, 0 zombie
Cpu(s): 0.1%us, 0.1%sy, 0.0%ni, 99.7%id, 0.1%wa, 0.0%hi, 0.1%si, 0.0%st
Mem: 625344k total, 571504k used, 53840k free, 65800k buffers
Swap: 524280k total, 0k used, 524280k free, 409280k cached
PID   USER PR NI VIRT  RES  SHR S %CPU %MEM   TIME+ COMMAND
19002 root 20  0 2656 1068  856 R  0.3  0.2 0:01.87 top
1     root 20  0 2872 1416 1200 S  0.0  0.2 0:02.55 init
2     root 20  0    0    0    0 S  0.0  0.0 0:00.03 kthreadd
3     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0
4     root 20  0    0    0    0 S  0.0  0.0 0:00.15 ksoftirqd/0
5     root RT  0    0    0    0 S  0.0  0.0 0:00.00 migration/0
6     root RT  0    0    0    0 S  0.0  0.0 0:10.01 watchdog/0
7     root 20  0    0    0    0 S  0.0  0.0 0:05.01 events/0
8     root 20  0    0    0    0 S  0.0  0.0 0:00.00 cgroup
9     root 20  0    0    0    0 S  0.0  0.0 0:00.00 khelper
10    root 20  0    0    0    0 S  0.0  0.0 0:00.00 netns
11    root 20  0    0    0    0 S  0.0  0.0 0:00.00 async/mgr
12    root 20  0    0    0    0 S  0.0  0.0 0:00.00 pm
13    root 20  0    0    0    0 S  0.0  0.0 0:01.70 sync_supers
14    root 20  0    0    0    0 S  0.0  0.0 0:00.63 bdi-default
15    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kintegrityd/0
16    root 20  0    0    0    0 S  0.0  0.0 0:02.52 kblockd/0
17    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpid
18    root 20  0    0    0    0 S  0.0  0.0 0:00.00 kacpi_notify
</code></pre>
<ol>
<li>第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出来判断服务器的资源使用状态的；</li>
</ol>
<p><strong>第一行</strong></p>
<table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody>
<tr><td>12:26:46</td><td>系统当前时间</td></tr>
<tr><td>up 1 day, 13:32</td><td>系统的运行时间.本机己经运行 1 天 13 小时 32 分钟</td></tr>
<tr><td>2 users</td><td>当前登录了两个用户</td></tr>
<tr><td>load average: 0.00,0.00，0.00</td><td>系统在之前 1 分钟、5 分钟、15 分钟的平均负载。如果 CPU 是单核的，则这个数值超过 1 就是高负载：如果 CPU 是四核的，则这个数值超过 4 就是高负载 （这个平均负载完全是依据个人经验来进行判断的，一般认为不应该超过服务器 CPU 的核数）</td></tr>
</tbody></table>
<p><strong>第二行</strong></p>
<blockquote>
<p>系统进程统计信息</p>
</blockquote>
<table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody>
<tr><td>Tasks: 95 total</td><td>系统中的进程总数</td></tr>
<tr><td>1 running</td><td>正在运行的进程数</td></tr>
<tr><td>94 sleeping</td><td>睡眠的进程数</td></tr>
<tr><td>0 stopped</td><td>正在停止的进程数</td></tr>
<tr><td>0 zombie</td><td>僵尸进程数。如果不是 0，则需要手工检查僵尸进程</td></tr>
</tbody></table>
<p><strong>第三行</strong></p>
<blockquote>
<p>CPU 信息</p>
</blockquote>
<table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody>
<tr><td>Cpu(s): 0.1 %us</td><td>用户模式占用的 CPU 百分比</td></tr>
<tr><td>0.1%sy</td><td>系统模式占用的 CPU 百分比</td></tr>
<tr><td>0.0%ni</td><td>改变过优先级的用户进程占用的 CPU 百分比</td></tr>
<tr><td>99.7%id</td><td>空闲 CPU 占用的 CPU 百分比</td></tr>
<tr><td>0.1%wa</td><td>等待输入/输出的进程占用的 CPU 百分比</td></tr>
<tr><td>0.0%hi</td><td>硬中断请求服务占用的 CPU 百分比</td></tr>
<tr><td>0.1%si</td><td>软中断请求服务占用的 CPU 百分比</td></tr>
<tr><td>0.0%st</td><td>st（steal time）意为虚拟时间百分比，当有虚拟机时，虚拟机被hypervisor偷去的CPU时间（如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）</td></tr>
</tbody></table>
<p>第四行</p>
<blockquote>
<p>物理内存信息</p>
</blockquote>
<table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody>
<tr><td>Mem: 625344k total</td><td>物理内存的总量，单位为KB</td></tr>
<tr><td>571504k used</td><td>己经使用的物理内存数量</td></tr>
<tr><td>53840k free</td><td>空闲的物理内存数量。我们使用的是虚拟机，共分配了 628MB内存，所以只有53MB的空闲内存</td></tr>
<tr><td>65800k buffers</td><td>用作内核缓冲的内存量</td></tr>
</tbody></table>
<p>第五行</p>
<blockquote>
<p>交换分区（swap）信息</p>
</blockquote>
<table><thead><tr><th>内 容</th><th>说 明</th></tr></thead><tbody>
<tr><td>Swap: 524280k total</td><td>交换分区（虚拟内存）的总大小</td></tr>
<tr><td>O k used</td><td>已经使用的交换分区的大小</td></tr>
<tr><td>524280 k free</td><td>空闲交换分区的大小</td></tr>
<tr><td>409280k cached</td><td>作为缓存的交换分区的大小</td></tr>
</tbody></table>
<p>如果 1 分钟、5 分钟、15 分钟的平均负载高于 1，则证明系统压力较大。如果 CPU 的使用率过高或空闲率过低，则证明系统压力较大。如果物理内存的空闲内存过小，则也证明系统压力较大。</p>
<p>第二部分从第六行开始，显示的是系统中<strong>进程的信息</strong>；</p>
<p><strong>显示字段管理面板</strong></p>
<p>在top命令中按f按可以查看显示的列信息，按对应字母来开启/关闭列，大写字母表示开启，小写字母表示关闭。带*号的是默认列。</p>
<table><thead><tr><th>英文名</th><th>解释</th></tr></thead><tbody>
<tr><td>PID</td><td>Process Id</td></tr>
<tr><td>USER</td><td>Effective User Name</td></tr>
<tr><td>PR</td><td>Priority（进程优先级，不可更改）</td></tr>
<tr><td>NI</td><td>Nice Value（进程优先级，可更改，负值表示高优先级，正值表示低优先级）</td></tr>
<tr><td>VIRT</td><td>Virtual Image (KiB) 。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr>
<tr><td>RES</td><td>Resident Size (KiB)，进程占用的物理内存，单位kb。RES=CODE+DATA</td></tr>
<tr><td>SHR</td><td>Shared Memory (KiB)，共享内存大小</td></tr>
<tr><td>S</td><td>Process Status，进程状态。D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程</td></tr>
<tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr>
<tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr>
<tr><td>TIME+</td><td>(CPU Time, hundredths) 进程使用的CPU时间总计，单位1/100秒</td></tr>
<tr><td>COMMAND</td><td>(Command name/line) 命令名/命令行</td></tr>
<tr><td>PPID</td><td>(Parent Process Pid)</td></tr>
<tr><td>UID</td><td>Effective User Id</td></tr>
<tr><td>RUID</td><td>Real User Id</td></tr>
<tr><td>RUSER</td><td>Real User Name</td></tr>
<tr><td>SUID</td><td>Saved User Id</td></tr>
<tr><td>SUSER</td><td>Saved User Name</td></tr>
<tr><td>GID</td><td>Group Id</td></tr>
<tr><td>GROUP</td><td>Group Name</td></tr>
<tr><td>PGRP</td><td>Process Group Id</td></tr>
<tr><td>TTY</td><td>Controlling Tty，启动进程的终端名。不是从终端启动的进程则显示为 ?</td></tr>
<tr><td>TPGID</td><td>Tty Process Grp Id</td></tr>
<tr><td>SID</td><td>Session Id</td></tr>
<tr><td>nTH</td><td>Number of Threads</td></tr>
<tr><td>P</td><td>(Last used cpu (SMP)) 最后使用的CPU，仅在多CPU环境下有意义</td></tr>
<tr><td>TIME</td><td>进程使用的CPU时间总计，单位秒</td></tr>
<tr><td>SWAP</td><td>(Swapped size (kb)) 进程使用的虚拟内存中</td></tr>
<tr><td>CODE</td><td>(Code size (kb)) 可执行代码占用的物理内存大小，单位kb</td></tr>
<tr><td>DATA</td><td>可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td></tr>
<tr><td>WCHAN</td><td>(Sleeping in Function) 若该进程在睡眠，则显示睡眠中的系统函数名</td></tr>
</tbody></table>
<h1 id="具体交互性命令"><a class="header" href="#具体交互性命令">具体交互性命令</a></h1>
<pre><code> Z,B       Global: 'Z' change color mappings; 'B' disable/enable bold
            Z：修改颜色配置；B：关闭/开启粗体
  l,t,m     Toggle Summaries: 'l' load avg; 't' task/cpu stats; 'm' mem info
            l：隐藏/显示第1行负载信息；t：隐藏/显示第2~3行CPU信息；m：隐藏/显示第4~5行内存信息；
  1,I       Toggle SMP view: '1' single/separate states; 'I' Irix/Solaris mode
            1：单行/多行显示CPU信息；I：Irix/Solaris模式切换
  f,o     . Fields/Columns: 'f' add or remove; 'o' change display order
            f：列显示控制；o：列排序控制，按字母进行调整
  F or O  . Select sort field  选择排序列
  &lt;,&gt;     . Move sort field: '&lt;' next col left; '&gt;' next col right 上下移动内容
  R,H     . Toggle: 'R' normal/reverse sort; 'H' show threads
            R：内容排序；H：显示线程
  c,i,S   . Toggle: 'c' cmd name/line; 'i' idle tasks; 'S' cumulative time
            c：COMMAND列命令名称与完整命令行路径切换；i：忽略闲置和僵死进程开关；S：累计模式切换
  x,y     . Toggle highlights: 'x' sort field; 'y' running tasks
            x：列排序；y：运行任务
  z,b     . Toggle: 'z' color/mono; 'b' bold/reverse (only if 'x' or 'y')
            z：颜色模式；b：粗体开关 仅适用于x，y模式中
  u       . Show specific user only 按用户进行过滤，当输入错误可按Ctrl + Backspace进行删除
  n or #  . Set maximum tasks displayed 设置进程最大显示条数

  k,r       Manipulate tasks: 'k' kill; 'r' renice
            k：终止一个进程；r：重新设置一个进程的优先级别
  d or s    Set update interval  改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成ms。输入0值则系统将不断刷新，默认值是5s；
  W         Write configuration file 将当前设置写入~/.toprc文件中
  q         Quit       退出
          ( commands shown with '.' require a visible task display window )
            注意：带.的命令需要一个可见的任务显示窗口
</code></pre>
<h1 id="批处理-获取进程信息"><a class="header" href="#批处理-获取进程信息">批处理 获取进程信息</a></h1>
<pre><code> top -b -n 10 &gt; /root/top.log
</code></pre>
<p><strong>会产生 10次 top调用并输出</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="程序和进程"><a class="header" href="#程序和进程">程序和进程</a></h2>
<p>一般而言，程序是一个可执行的文件，而进程是程序执行的实例，</p>
<p>一个程序可以产生任意多个进程，这些进程具有相同的代码。</p>
<h2 id="用户名组名和uidgid"><a class="header" href="#用户名组名和uidgid">用户名/组名和uid/gid</a></h2>
<ol>
<li>
<p>每一个用户具有一个用户名和组名以及对应的uid/gid</p>
</li>
<li>
<p>通常用户名和组名是人类可读的词，而uid/gid是一个整数，系统其实只认识uid/gid, 而不关心具体的username和groupname是什么</p>
</li>
<li>
<p>linux的权限校验机制也都是通过uid和gid来控制的。</p>
</li>
<li>
<p>多个不同的username可以对应同一个uid, 同理多个不同的groupname可对应同一个gid, 反之则不可。</p>
</li>
</ol>
<h2 id="主要gid和次要gid"><a class="header" href="#主要gid和次要gid">主要gid和次要gid</a></h2>
<p>每个用户都有一个主要gid, 可以加入多个次要gid</p>
<ol>
<li>当通过当前用户创建文件时，文件的gid就是用户的主要gid</li>
<li>次要gid主要用于访问权限验证，当用户属于某个次要gid，且要访问的文件的gid是该gid，且文件权限是group可访问的，则用户可访问该文件。</li>
</ol>
<h2 id="程序uid-gid"><a class="header" href="#程序uid-gid">程序uid, gid</a></h2>
<ol>
<li>前面提到，程序就是一个可执行文件，每个文件同样有一个uid和gid，默认为创建该文件的用户的uid/gid</li>
<li>可通过命令chown修改</li>
<li>通过ls -l命名默认看到的是username和groupname, 实际上对应的应该是uid和gid</li>
<li>如果修改/etc/passwd, 删除掉username, 则可以看到看到文件对应的user列变成了uid了。</li>
</ol>
<h2 id="进程uid和gid"><a class="header" href="#进程uid和gid">进程uid和gid</a></h2>
<p>linux访问权限控制是对进程进行控制的，每个进程也有一个uid和gid, 默认是运行进程的用户的uid和gid</p>
<h2 id="setuid和setgid"><a class="header" href="#setuid和setgid">setuid和setgid</a></h2>
<ul>
<li>前面说到，linux是对进程进行权限验证，例如某个进程要访问一个文件 则需要验证进程的uid/gid是否满足该文件的访问权限</li>
<li>默认情况下进程的uid,gid是运行进程的用户的uid和gid</li>
<li>通过设置程序(进程对应的可执行文件) 的setuid和setgid，可以修改进程的uid和gid为程序的uid和gid
<ul>
<li>例如修改某个user为root的程序的setuid位</li>
<li>则任意用户执行该程序时，对应的进程的uid都是root uid, 也就是任何用户都可以root权限执行程序。</li>
</ul>
</li>
</ul>
<pre><code>修改setuid和setgid:
chmod u+s filename
chmod g+s filename
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>关闭TAB提示音
修改/etc/inputrc</p>
<p>如果有的话把set bell-style none前面的#注释去掉</p>
<p>没有的话在最后一行添加</p>
<p>关闭vim提示音
修改/etc/vim/vimrc</p>
<p>在最后一行添加set vb t_vb=</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="按需构建"><a class="header" href="#按需构建">按需构建</a></h1>
<h2 id="1把需要的rpm包下载到本地"><a class="header" href="#1把需要的rpm包下载到本地">1.把需要的rpm包下载到本地</a></h2>
<pre><code class="language-sh">yum install --downloadonly --downloaddir=/yum/ mysql-community-server
</code></pre>
<h2 id="2生成yum仓库数据文件信息repodate信息"><a class="header" href="#2生成yum仓库数据文件信息repodate信息">2.生成yum仓库数据文件信息(repodate信息)</a></h2>
<pre><code class="language-sh">yum install createrepo -y 	# 安装createrepo
createrepo /yum/			# 生成repomd.xml文件
</code></pre>
<p><em># 使用完成后会在/yum/目录里面生成repodate，这个文件里面存放的就是仓库的各项信息</em> </p>
<h2 id="3配置本地仓库"><a class="header" href="#3配置本地仓库">3.配置本地仓库</a></h2>
<pre><code class="language-sh">echo '[local]
name=local repository
baseurl=file:///yum
enabled=1
gpgcheck=0'&gt;
/etc/yum.repos.d/local.repo
</code></pre>
<h2 id="4检查本地仓库信息"><a class="header" href="#4检查本地仓库信息">4.检查本地仓库信息</a></h2>
<pre><code class="language-sh">yum repoinfo local		
# 这里的local可以是Repo-id，也可以是Repo-name
# Repo-id ：配置文件[]里面的内容
# Repo-name ：配置文件name的字段
# 输出正常表示可以进行正常使用
</code></pre>
<h2 id="5通过nginx配置url访问"><a class="header" href="#5通过nginx配置url访问">5.通过nginx配置URL访问</a></h2>
<h1 id="全库同步"><a class="header" href="#全库同步">全库同步</a></h1>
<pre><code class="language-sh">reposync -r &quot;$repoid&quot; -p /yum	# $repoid就是镜像的id，同步并更新
createrepo --update /yum		# 更新repodate信息
yum clean all &amp;&amp; yum repolist	# 清除缓存
</code></pre>
<h1 id="其他-1"><a class="header" href="#其他-1">其他</a></h1>
<pre><code class="language-sh">yum-config-manager enable/disable
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="大端模式和小端模式的区别"><a class="header" href="#大端模式和小端模式的区别">大端模式和小端模式的区别</a></h2>
<p>在C语言中除了8位的char型之外，还有16位的short型，32位的long型（要看具体的编译器），对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。</p>
<ul>
<li>大小端说的是 数据的高字节 是否 放于 开始内存地址 </li>
</ul>
<h3 id="大端模式"><a class="header" href="#大端模式">大端模式</a></h3>
<p>字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中</p>
<h3 id="小端模式"><a class="header" href="#小端模式">小端模式</a></h3>
<p>与大端存储模式相反，在小端存储模式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节</p>
<p>例如，16位宽的数0x1234在小端模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p>
<table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th></tr></thead><tbody>
<tr><td>存放内容</td><td>0x34</td><td>0x12</td></tr>
</tbody></table>
<p>而在大端模式CPU内存中的存放方式则为：</p>
<table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th></tr></thead><tbody>
<tr><td>存放内容</td><td>0x12</td><td>0x34</td></tr>
</tbody></table>
<p>32位宽的数0x12345678在小端模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：</p>
<table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th><th>0x4002</th><th>0x4003</th></tr></thead><tbody>
<tr><td>存放内容</td><td>0x78</td><td>0x56</td><td>0x34</td><td>0x12</td></tr>
</tbody></table>
<p>而在大端模式CPU内存中的存放方式则为：</p>
<table><thead><tr><th>内存地址</th><th>0x4000</th><th>0x4001</th><th>0x4002</th><th>0x4003</th></tr></thead><tbody>
<tr><td>存放内容</td><td>0x12</td><td>0x34</td><td>0x56</td><td>0x78</td></tr>
</tbody></table>
<p>Byte Endian是指字节在内存中的组织，所以也称它为Byte Ordering，或Byte Order。
对于数据中跨越多个字节的对象， 我们必须为它建立这样的约定:</p>
<ul>
<li>
<p>它的地址是多少?</p>
</li>
<li>
<p>它的字节在内存中是如何组织的?</p>
<p>针对第一个问题，有这样的解释:</p>
</li>
</ul>
<p>对于跨越多个字节的对象，一般它所占的字节都是连续的，它的地址等于它所占字节最低地址 (链表是个例外， 但链表的地址可看作链表头的地址)。</p>
<pre><code>比如: int x， 它的地址为0×100。 那么它占据了内存中的Ox100， 0×101， 0×102， 0×103这四个字节（32位系统，所以int占用4个字节）。
</code></pre>
<p>上面只是内存字节组织的一种情况: 多字节对象在内存中的组织有一般有两种约定。 考虑一个W位的整数。
它的各位表达如下:[Xw-1， Xw-2， ... ， X1， X0],它的
MSB (Most Significant Byte， 最高有效字节)为 [Xw-1， Xw-2， ... Xw-8];
LSB (Least Significant Byte， 最低有效字节)为 [X7，X6，...， X0]。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-6"><a class="header" href="#简介-6">简介</a></h1>
<p>当人们提到 Linux 时，他们通常指的是 Linux 发行版。</p>
<p>严格来说，Linux 是一个内核，是操作系统的核心组件，简单地说，它就像是软件应用程序和硬件之间的桥梁。 </p>
<p><strong>Linux 发行版是由 Linux 内核、GNU 工具和库以及软件集合组成的操作系统。</strong></p>
<p>通常，Linux 发行版包括</p>
<ol>
<li>桌面环境</li>
<li>包管理系统和</li>
<li>一组预装的应用程序。</li>
</ol>
<p>一些最流行的 Linux 发行版是 Debian、Red Hat、Ubuntu、Arch Linux、Fedora、CentOS、Kali Linux、OpenSUSE、Linux Mint 等。</p>
<p>当您第一次登录 Linux 系统时，在做任何工作之前，最好先检查一下机器上运行的是什么版本的 Linux。</p>
<p>例如，确定 Linux 发行版可以帮助您确定应该使用哪个包管理器来安装新包。</p>
<p>本文展示了如何使用命令行检查系统上安装的 Linux 发行版和版本。</p>
<h1 id="lsb_release"><a class="header" href="#lsb_release"><code>lsb_release</code></a></h1>
<p>lsb_release 实用程序显示有关 Linux 发行版的 LSB（Linux 标准库）信息。此命令应该适用于安装了 lsb-release 软件包的所有 Linux 发行版：</p>
<pre><code class="language-sh">lsb_release -a
</code></pre>
<pre><code class="language-output">No LSB modules are available.
Distributor ID:	Debian
Description:	Debian GNU/Linux 9.5 (stretch)
Release:	9.5
Codename:	stretch
</code></pre>
<h1 id="etcos-release"><a class="header" href="#etcos-release"><code>/etc/os-release</code></a></h1>
<p>/etc/os-release 文件包含操作系统标识数据，包括有关分发的信息。</p>
<p>这个文件是 systemd 包的一部分，应该存在于所有运行 systemd 的系统上。</p>
<p>要查看 os-release 文件的内容，请使用 cat 或 less ：</p>
<pre><code class="language-sh">echo &quot;$(cat /etc/os-release|grep -w ID= | awk -F'=' '{print $2}'|sed 's/&quot;//g')&quot;
</code></pre>
<h1 id="etcissue"><a class="header" href="#etcissue"><code>/etc/issue</code></a></h1>
<p>文件包含在登录提示之前打印的系统标识文本。</p>
<p>通常，此文件包含有关 Linux 版本的信息：</p>
<h2 id="hostnamectl-command"><a class="header" href="#hostnamectl-command"><code>hostnamectl</code> command</a></h2>
<p>hostnamectl 实用程序是 systemd 的一部分，用于查询和更改系统主机名。</p>
<p>此命令还显示 Linux 发行版和内核版本。</p>
<h1 id="etcrelease"><a class="header" href="#etcrelease"><code>/etc/*release</code></a></h1>
<p>如果上述命令都不适合您，那么很可能您正在运行一个非常陈旧且过时的 Linux 发行版。</p>
<p>在这种情况下，您可以使用以下命令之一，它应该打印发行版或版本文件的内容</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么要有-dma-技术"><a class="header" href="#为什么要有-dma-技术"><strong>为什么要有 DMA 技术?</strong></a></h1>
<p>在没有 DMA 技术前，I/O 的过程是这样的：</p>
<ul>
<li>CPU 发出对应的指令给磁盘控制器，然后返回；</li>
<li>磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个<strong>中断</strong>；</li>
<li>CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。</li>
</ul>
<p>可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。</p>
<p>简单的搬运几个字符数据那没问题，但是如果我们用千兆网卡或者硬盘传输大量数据的时候，都用 CPU 来搬运的话，肯定忙不过来。</p>
<p>计算机科学家们发现了事情的严重性后，于是就发明了 DMA 技术，也就是<strong>直接内存访问（Direct Memory Access）</strong> 技术。</p>
<p>什么是 DMA 技术？简单理解就是，<strong>在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。</strong></p>
<p>那使用 DMA 控制器进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。</p>
<p><img src="10.Linux//images/zero_copy.png" alt="" /></p>
<p>具体过程：</p>
<ul>
<li>用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；</li>
<li>操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；</li>
<li>DMA 进一步将 I/O 请求发送给磁盘；</li>
<li>磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；</li>
<li><strong>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务；</strong></li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；</li>
<li>CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；</li>
</ul>
<h1 id="传统的文件传输有多糟糕"><a class="header" href="#传统的文件传输有多糟糕"><strong>传统的文件传输有多糟糕？</strong></a></h1>
<p>如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将磁盘上的文件读取出来，然后通过网络协议发送给客户端。</p>
<p>传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。</p>
<p>代码通常如下，一般会需要两个系统调用：</p>
<pre><code>read(file, tmp_buf, len);
write(socket, tmp_buf, len);
</code></pre>
<p><img src="10.Linux//images/zero_copy_file_trans.png" alt="" /></p>
<p>其次，还<strong>发生了 4 次数据拷贝</strong>，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：</p>
<ul>
<li><strong>第一次拷贝</strong>，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。</li>
<li><strong>第二次拷贝</strong>，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。</li>
<li><strong>第三次拷贝</strong>，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。</li>
<li><strong>第四次拷贝</strong>，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。</li>
</ul>
<p>我们回过头看这个文件传输的过程，我们只是搬运一份数据，结果却搬运了 4 次，过多的数据拷贝无疑会消耗 CPU 资源，大大降低了系统性能。</p>
<p>这种简单又传统的文件传输方式，存在冗余的上文切换和数据拷贝，在高并发系统里是非常糟糕的，多了很多不必要的开销，会严重影响系统性能。</p>
<p>所以，<strong>要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数。</strong></p>
<h1 id="如何优化文件传输的性能"><a class="header" href="#如何优化文件传输的性能"><strong>如何优化文件传输的性能？</strong></a></h1>
<blockquote>
<p>先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？</p>
</blockquote>
<p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p>
<p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p>
<p>所以，<strong>要想减少上下文切换到次数，就要减少系统调用的次数。</strong></p>
<blockquote>
<p>再来看看，如何减少「数据拷贝」的次数？</p>
</blockquote>
<p>在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。</p>
<p>因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此<strong>用户的缓冲区是没有必要存在的。</strong></p>
<h1 id="如何实现零拷贝"><a class="header" href="#如何实现零拷贝"><strong>如何实现零拷贝？</strong></a></h1>
<p>零拷贝技术实现的方式通常有 2 种：</p>
<ul>
<li>mmap + write</li>
<li>sendfile</li>
</ul>
<p>下面就谈一谈，它们是如何减少「上下文切换」和「数据拷贝」的次数。</p>
<h2 id="mmap--write"><a class="header" href="#mmap--write">mmap + write</a></h2>
<p>在前面我们知道，<strong>read</strong>系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 <strong>mmap</strong> 替换 <strong>read</strong> 系统调用函数。</p>
<pre><code>buf = mmap(file, len);write(sockfd, buf, len);
</code></pre>
<p><strong>mmap</strong> 系统调用函数会直接把内核缓冲区里的数据**「映射」**到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。</p>
<p><img src="10.Linux//images/zero_copy_nmap.png" alt="" /></p>
<p>具体过程如下：</p>
<ul>
<li>应用进程调用了 <strong>mmap</strong> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <strong>write</strong>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
<p>我们可以得知，通过使用 <strong>mmap</strong> 来代替<strong>read</strong>， 可以减少一次数据拷贝的过程。</p>
<p>但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。</p>
<h2 id="sendfile"><a class="header" href="#sendfile">sendfile</a></h2>
<p>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <strong>sendfile</strong>，函数形式如下：</p>
<pre><code class="language-c++">#include &lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
</code></pre>
<p>它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。</p>
<p>首先，它可以替代前面的 <strong>read</strong>和<strong>write</strong>这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。</p>
<p>其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：</p>
<p><img src="10.Linux//images/zero_copy_sendFile.png" alt="" /></p>
<p>但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（<em>The Scatter-Gather Direct Memory Access</em>）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
<p>你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：</p>
<pre><code>$ ethtool -k eth0 | grep scatter-gather
scatter-gather: on
</code></pre>
<p>于是，从 Linux 内核 <strong>2.4</strong>版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <strong>sendfile</strong> 系统调用的过程发生了点变化，具体过程如下：</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
<p>所以，这个过程之中，只进行了 2 次数据拷贝，如下图：</p>
<p><img src="10.Linux//images/zero_copy_sgdma.png" alt="" /></p>
<p>这就是所谓的零拷贝（<em>Zero-copy</em>）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p>
<p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上。</strong></p>
<h1 id="使用零拷贝技术的项目"><a class="header" href="#使用零拷贝技术的项目">使用零拷贝技术的项目</a></h1>
<h2 id="kafka"><a class="header" href="#kafka">Kafka</a></h2>
<p>事实上，Kafka 这个开源项目，就利用了「零拷贝」技术，从而大幅提升了 I/O 的吞吐率，这也是 Kafka 在处理海量数据为什么这么快的原因之一。</p>
<p>如果你追溯 Kafka 文件传输的代码，你会发现，最终它调用了 Java NIO 库里的 <strong>transferTo</strong>方法：</p>
<pre><code class="language-java">@Overridepublic long transferFrom(FileChannel fileChannel, long position, long count) throws IOException {  
return fileChannel.transferTo(position, count, socketChannel);
}
</code></pre>
<p>如果 Linux 系统支持 <strong>sendfile</strong> 系统调用，那么 <strong>transferTo</strong> 实际上最后就会使用到 <strong>sendfile</strong> 系统调用函数。</p>
<h2 id="nginx"><a class="header" href="#nginx">Nginx</a></h2>
<p>另外，Nginx 也支持零拷贝技术，一般默认是开启零拷贝技术，这样有利于提高文件传输的效率，是否开启零拷贝技术的配置如下：</p>
<pre><code>http {... sendfile on...}
</code></pre>
<p>sendfile 配置的具体意思:</p>
<ul>
<li>设置为 on 表示，使用零拷贝技术来传输文件：sendfile ，这样只需要 2 次上下文切换，和 2 次数据拷贝。</li>
<li>设置为 off 表示，使用传统的文件传输技术：read + write，这时就需要 4 次上下文切换，和 4 次数据拷贝。</li>
</ul>
<p>当然，要使用 sendfile，Linux 内核版本必须要 2.1 以上的版本。</p>
<h1 id="pagecache-有什么作用"><a class="header" href="#pagecache-有什么作用"><strong>PageCache 有什么作用？</strong></a></h1>
<p>回顾前面说道文件传输过程，其中第一步都是先需要先把磁盘文件数据拷贝「内核缓冲区」里，这个「内核缓冲区」实际上是<strong>磁盘高速缓存（PageCache）</strong>。</p>
<p>由于零拷贝使用了 PageCache 技术，可以使得零拷贝进一步提升了性能，我们接下来看看 PageCache 是如何做到这一点的。</p>
<p>读写磁盘相比读写内存的速度慢太多了，所以我们应该想办法把「读写磁盘」替换成「读写内存」。于是，我们会通过 DMA 把磁盘里的数据搬运到内存里，这样就可以用读内存替换读磁盘。</p>
<p>但是，内存空间远比磁盘要小，内存注定只能拷贝磁盘里的一小部分数据。</p>
<p>那问题来了，选择哪些磁盘数据拷贝到内存呢？</p>
<p>我们都知道程序运行的时候，具有「局部性」，所以通常，刚被访问的数据在短时间内再次被访问的概率很高，于是我们可以用 <strong>PageCache 来缓存最近被访问的数据</strong>，当空间不足时淘汰最久未被访问的缓存。</p>
<p>所以，读磁盘数据的时候，优先在 PageCache 找，如果数据存在则可以直接返回；如果没有，则从磁盘中读取，然后缓存 PageCache 中。</p>
<p>还有一点，读取磁盘数据的时候，需要找到数据所在的位置，但是对于机械磁盘来说，就是通过磁头旋转到数据所在的扇区，再开始「顺序」读取数据，但是旋转磁头这个物理动作是非常耗时的，为了降低它的影响，<strong>PageCache 使用了「预读功能」</strong>。</p>
<p>比如，假设 read 方法每次只会读 <strong>32 KB</strong>的字节，虽然 read 刚开始只会读 0 ～ 32 KB 的字节，但内核会把其后面的 32～64 KB 也读取到 PageCache，这样后面读取 32～64 KB 的成本就很低，如果在 32～64 KB 淘汰出 PageCache 前，进程读取到它了，收益就非常大。</p>
<p>所以，PageCache 的优点主要是两个：</p>
<ul>
<li>缓存最近被访问的数据；</li>
<li>预读功能；</li>
</ul>
<p>这两个做法，将大大提高读写磁盘的性能。</p>
<p><strong>但是，在传输大文件（GB 级别的文件）的时候，PageCache 会不起作用，那就白白浪费 DMA 多做的一次数据拷贝，造成性能的降低，即使使用了 PageCache 的零拷贝也会损失性能。</strong></p>
<p>这是因为如果你有很多 GB 级别文件需要传输，每当用户访问这些大文件的时候，内核就会把它们载入 PageCache 中，于是 PageCache 空间很快被这些大文件占满。</p>
<p>另外，由于文件太大，可能某些部分的文件数据被再次访问的概率比较低，这样就会带来 2 个问题：</p>
<ul>
<li>PageCache 由于长时间被大文件占据，其他「热点」的小文件可能就无法充分使用到 PageCache，于是这样磁盘读写的性能就会下降了；</li>
<li>PageCache 中的大文件数据，由于没有享受到缓存带来的好处，但却耗费 DMA 多拷贝到 PageCache 一次；</li>
</ul>
<p>所以，针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题。</p>
<h1 id="大文件传输用什么方式实现"><a class="header" href="#大文件传输用什么方式实现"><strong>大文件传输用什么方式实现？</strong></a></h1>
<p>那针对大文件的传输，我们应该使用什么方式呢？</p>
<p>我们先来看看最初的例子，当调用 read 方法读取文件时，进程实际上会阻塞在 read 方法调用，因为要等待磁盘数据的返回，如下图：</p>
<p><img src="10.Linux//images/zero_copy_normal_read.png" alt="" /></p>
<p>具体过程：</p>
<ul>
<li>当调用 read 方法时，会阻塞着，此时内核会向磁盘发起 I/O 请求，磁盘收到请求后，便会寻址，当磁盘数据准备好后，就会向内核发起 I/O 中断，告知内核磁盘数据已经准备好；</li>
<li>内核收到 I/O 中断后，就将数据从磁盘控制器缓冲区拷贝到 PageCache 里；</li>
<li>最后，内核再把 PageCache 中的数据拷贝到用户缓冲区，于是 read 调用就正常返回了。</li>
</ul>
<p>对于阻塞的问题，可以用异步 I/O 来解决，它工作方式如下图：</p>
<p><img src="10.Linux//images/zero_copy_asynchronous.png" alt="" /></p>
<p>它把读操作分为两部分：</p>
<ul>
<li>前半部分，内核向磁盘发起读请求，但是可以**不等待数据就位就可以返回，**于是进程此时可以处理其他任务；</li>
<li>后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的<strong>通知</strong>，再去处理数据；</li>
</ul>
<p>而且，我们可以发现，<strong>异步 I/O 并没有涉及到 PageCache</strong>，所以使用异步 I/O 就意味着要绕开 PageCache。</p>
<p><strong>绕开 PageCache 的 I/O 叫直接 I/O，使用 PageCache 的 I/O 则叫缓存 I/O</strong>。<strong>通常，对于磁盘，异步 I/O 只支持直接 I/O。</strong></p>
<p>前面也提到，大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。</p>
<p>于是，<strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术。</strong></p>
<p>直接 I/O 应用场景常见的两种：</p>
<ul>
<li>应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；</li>
<li>传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。</li>
</ul>
<p>另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：</p>
<ul>
<li>内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后**「合并」**成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；</li>
<li>内核也会**「预读」**后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作；</li>
</ul>
<p>于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。</p>
<p>所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：</p>
<ul>
<li>传输大文件的时候，使用「异步 I/O + 直接 I/O」；</li>
<li>传输小文件的时候，则使用「零拷贝技术」；</li>
</ul>
<p>在 Nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：</p>
<pre><code>location /video/ {  sendfile on;  aio on;  directio 1024m; }
</code></pre>
<p>当文件大小大于 <strong>directio</strong>值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。</p>
<h1 id="总结"><a class="header" href="#总结"><strong>总结</strong></a></h1>
<h2 id="为了解放cpu而-发明了-dma"><a class="header" href="#为了解放cpu而-发明了-dma">为了解放CPU而 发明了 <em>DMA</em></a></h2>
<p>早期 I/O 操作，内存与磁盘的数据传输的工作都是由 CPU 完成的，而此时 CPU 不能执行其他任务，会特别浪费 CPU 资源。</p>
<p>于是，为了解决这一问题，DMA 技术就出现了，每个 I/O 设备都有自己的 DMA 控制器，通过这个 DMA 控制器，CPU 只需要告诉 DMA 控制器，我们要传输什么数据，从哪里来，到哪里去，就可以放心离开了。后续的实际数据传输工作，都会由 DMA 控制器来完成，CPU 不需要参与数据传输的工作。</p>
<h2 id="如何减少文件copy中数据复制的次数"><a class="header" href="#如何减少文件copy中数据复制的次数">如何减少文件Copy中数据复制的次数</a></h2>
<ol>
<li>用户与内核共享一个缓冲区 (nmap，内存映射)</li>
<li>将 内核缓冲区 直接写入到 <em>Socket</em> 缓冲区 （<em>sendFile</em>)</li>
<li>网卡的 SG-DMA 控制器 直接将 内核缓冲区的数据 写入网卡缓冲区</li>
</ol>
<h2 id="零拷贝的局限"><a class="header" href="#零拷贝的局限">零拷贝的局限</a></h2>
<p>需要注意的是，零拷贝技术是不允许进程对文件内容作进一步的加工的，比如压缩数据再发送。</p>
<h2 id="内核缓冲区的实现pagecache"><a class="header" href="#内核缓冲区的实现pagecache">内核缓冲区的实现：PageCache</a></h2>
<ul>
<li>PageCache 会缓存最近访问的数据，提升了访问缓存数据的性能</li>
<li>IO 合并</li>
<li>数据预读</li>
</ul>
<h2 id="大文件传输的方法"><a class="header" href="#大文件传输的方法">大文件传输的方法</a></h2>
<p>针对大文件使用异步 IO 和直接 IO，而对小文件使用零拷贝。</p>
<p><a href="https://www.toutiao.com/i6879648629628502542/">CSDN零拷贝</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="默认参数变量默认值"><a class="header" href="#默认参数变量默认值"><strong>默认参数(变量默认值)</strong></a></h1>
<h2 id="变量为null时取默认值"><a class="header" href="#变量为null时取默认值">变量为null时取默认值</a></h2>
<pre><code class="language-sh">${vari-defaultValue}
</code></pre>
<h2 id="变量为null时-同时改变变量值"><a class="header" href="#变量为null时-同时改变变量值">=变量为null时, 同时改变变量值</a></h2>
<pre><code class="language-sh">${vari=defaultValue}
</code></pre>
<h2 id="--变量为null-或-空字符串"><a class="header" href="#--变量为null-或-空字符串">:- 变量为null 或 空字符串</a></h2>
<pre><code class="language-sh">${vari:-defaultValue}
</code></pre>
<h2 id="变量为null-或-空字符串-同时改变变量值"><a class="header" href="#变量为null-或-空字符串-同时改变变量值">:=变量为null 或 空字符串, 同时改变变量值</a></h2>
<pre><code class="language-sh">{$vari:=defaultValue}
</code></pre>
<h2 id="变量为null-或-空字符串时报错并退出"><a class="header" href="#变量为null-或-空字符串时报错并退出">:?变量为null 或 空字符串时报错并退出</a></h2>
<pre><code class="language-sh">${name:?yjx}
</code></pre>
<h2 id="变量不为空时使用默认值"><a class="header" href="#变量不为空时使用默认值">:+变量不为空时使用默认值</a></h2>
<pre><code class="language-sh">${name:+yjx}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本概念"><a class="header" href="#基本概念">基本概念</a></h1>
<h2 id="计算--信息处理"><a class="header" href="#计算--信息处理"><strong>计算 = 信息处理</strong></a></h2>
<p>借助某种工具, 遵照一定规则,以明确而机械得形式进行</p>
<p>计算模型 = 计算机 = 信息处理工具</p>
<h2 id="算法"><a class="header" href="#算法"><strong>算法</strong></a></h2>
<blockquote>
<p>所谓算法,即特定计算模型下,旨在解决特定问题的指令序列</p>
</blockquote>
<p><strong>基本性质</strong></p>
<ul>
<li>
<p><strong>输入</strong></p>
</li>
<li>
<p><strong>输出</strong></p>
</li>
<li>
<p><strong>正确性</strong></p>
</li>
<li>
<p><strong>确定性</strong></p>
</li>
<li>
<p><strong>可行性</strong></p>
</li>
<li>
<p><strong>有穷性</strong></p>
</li>
</ul>
<p><em>algorithm</em> + da'ta</p>
<h1 id="好算法定义"><a class="header" href="#好算法定义">好算法定义</a></h1>
<p><strong>可读性好</strong></p>
<p><strong>健壮</strong></p>
<p><strong>高效</strong></p>
<p><strong>占用存储空间低</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base64编码"><a class="header" href="#base64编码">Base64编码</a></h1>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<ol>
<li>将二进制数据编码成字符串</li>
<li>操作说明
<ol>
<li>每6位二进制 当作一个 字节 的 低字节位, 高位补0</li>
<li>根据 转换来的字节的十进制 在 码表中找对应的字符</li>
<li>如果最后 还剩 4位二进制则, 则补 二个 '=' 号,如果还剩2位二进制则补一个'='</li>
</ol>
</li>
</ol>
<h2 id="数据量比对"><a class="header" href="#数据量比对">数据量比对</a></h2>
<p>设源文件的字节数为  a</p>
<p>$$
\frac{编码后的数据量}{源数据量} =  \frac{a * 8 }{(a*8/6)*8} = \frac{4}{3}
$$</p>
<h2 id="码表"><a class="header" href="#码表">码表</a></h2>
<table><thead><tr><th>码值</th><th>字符</th><th>码值</th><th>字符</th><th>码值</th><th>字符</th></tr></thead><tbody>
<tr><td>0</td><td>A</td><td>26</td><td>a</td><td>52</td><td>0</td></tr>
<tr><td>1</td><td>B</td><td>27</td><td>b</td><td>53</td><td>1</td></tr>
<tr><td>2</td><td>C</td><td>28</td><td>c</td><td>54</td><td>2</td></tr>
<tr><td>3</td><td>D</td><td>29</td><td>d</td><td>55</td><td>3</td></tr>
<tr><td>4</td><td>E</td><td>30</td><td>e</td><td>56</td><td>4</td></tr>
<tr><td>5</td><td>F</td><td>31</td><td>f</td><td>57</td><td>5</td></tr>
<tr><td>6</td><td>G</td><td>32</td><td>g</td><td>58</td><td>6</td></tr>
<tr><td>7</td><td>H</td><td>33</td><td>h</td><td>59</td><td>7</td></tr>
<tr><td>8</td><td>I</td><td>34</td><td>i</td><td>60</td><td>8</td></tr>
<tr><td>9</td><td>J</td><td>35</td><td>j</td><td>61</td><td>9</td></tr>
<tr><td>10</td><td>K</td><td>36</td><td>k</td><td>62</td><td>+</td></tr>
<tr><td>11</td><td>L</td><td>37</td><td>l</td><td>63</td><td>/</td></tr>
<tr><td>12</td><td>M</td><td>38</td><td>m</td><td></td><td></td></tr>
<tr><td>13</td><td>N</td><td>39</td><td>n</td><td></td><td></td></tr>
<tr><td>14</td><td>O</td><td>40</td><td>o</td><td></td><td></td></tr>
<tr><td>15</td><td>P</td><td>41</td><td>p</td><td></td><td></td></tr>
<tr><td>16</td><td>Q</td><td>42</td><td>q</td><td></td><td></td></tr>
<tr><td>17</td><td>R</td><td>43</td><td>r</td><td></td><td></td></tr>
<tr><td>18</td><td>S</td><td>44</td><td>s</td><td></td><td></td></tr>
<tr><td>19</td><td>T</td><td>45</td><td>t</td><td></td><td></td></tr>
<tr><td>20</td><td>U</td><td>46</td><td>u</td><td></td><td></td></tr>
<tr><td>21</td><td>V</td><td>47</td><td>v</td><td></td><td></td></tr>
<tr><td>22</td><td>W</td><td>48</td><td>w</td><td></td><td></td></tr>
<tr><td>23</td><td>X</td><td>49</td><td>x</td><td></td><td></td></tr>
<tr><td>24</td><td>Y</td><td>50</td><td>y</td><td></td><td></td></tr>
<tr><td>25</td><td>Z</td><td>51</td><td>z</td><td></td><td></td></tr>
</tbody></table>
<h2 id="代码实现"><a class="header" href="#代码实现">代码实现</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
//编码
void encodeToBase64(const char *buf, int len);
//解码
void decodeBase64(const char *buf, int len);
void reverseBase64();

// 编码码表
char codeTable[64] = {
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '+', '/'};

//解码码表
char reverseTable[255];


int main(int argc, char const *argv[])
{
    if (argc != 3)
    {
        printf(&quot;缺少参数\n&quot;);
        return -1;
    }
    reverseBase64();
    switch (argv[1][0])
    {
        // d 为解码
    case 'd':
         decodeBase64(argv[2], strlen(argv[2]));
        break;
        //  e为编码
    case 'e':
         encodeToBase64(argv[2],strlen(argv[2]));
    default:
        break;
    }
    return 0;
}


void reverseBase64()
{
    for (size_t i = 0; i &lt; sizeof(codeTable); i++)
    {
        reverseTable[codeTable[i]] = i;
    }
}
//  原理: 从高位到低位 每次取前六位二进制的 值相加
void doEncodeToBase64(const char *buf, int len)
{
    int i = 6;
    int j = 8;
    int k = 0;
    int rest = 0;
    int sum = 0;
    char c = buf[0];
    while (k &lt; len)
    {
        // 如果当前字节的位数都已处理完毕,则切换到下一个字节,并恢复标识
        if (j == 0)
        {
            j = 8;
            c = buf[++k];
        }

        // 如果已取满 六位 二进制,则将该 低六位二进制对应的 值 根据码表转换成字符,并恢复标识
        if (i == 0)
        {
            i = 6;
            printf(&quot;%c&quot;, codeTable[sum]);
            sum = 0;
        }

        /*
            1. 判断当前字节 c, 当前处理 位置 j , 的二进制是 0 或 1
               (c &gt;&gt; (j - 1) &amp; 1
            2. 计算 6 -&gt; 8 位转换时 位置j 所处的 权重 
                1 &lt;&lt; (i - 1)
            3. 两者相乘
        */     
        sum += ((c &gt;&gt; (j - 1)) &amp; 1) * (1 &lt;&lt; (i - 1));
        i--;
        j--;
    }
    // 补 = 号
    if ((rest = len % 3) == 1)
    {
        printf(&quot;%c==\n&quot;, codeTable[sum]);
    }
    else if (rest == 2)
    {
        printf(&quot;%c=\n&quot;, codeTable[sum]);
    }
}
// 解码原理 同上
void decodeBase64(const char *buf, int len)
{
    int i = 6;
    int j = 8;
    int k = 0;
    int rest = 0;
    int codeInt = reverseTable[buf[k]];
    int sum = 0;

    while (k &lt; len &amp;&amp; buf[k] != '=')
    {
        if (i == 0)
        {
            i = 6;
            codeInt = reverseTable[buf[++k]];
        }
        if (j == 0)
        {
            j = 8;
            printf(&quot;%c&quot;, sum);
            sum = 0;
        }

        sum += ((codeInt &gt;&gt; (i - 1)) &amp; 1) * (1 &lt;&lt; (j - 1));

        i--;
        j--;
    }
}

void encodeToBase64(const char *argv, int len)
{


    char buf[3072];
    FILE *file;
    if (file = fopen(argv, &quot;rb&quot;))
    {
        while ((len = fread(buf, sizeof(char), sizeof(buf), file)) &gt; 0)
        {
            doEncodeToBase64(buf, len);
        }
    }
    else
    {
        // 当 输入的字符串 不为文件时, 直接当作字符串处理
        doEncodeToBase64(argv, len);
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="huffman编码"><a class="header" href="#huffman编码">Huffman编码</a></h1>
<h2 id="编码原理"><a class="header" href="#编码原理">编码原理</a></h2>
<ol>
<li>
<p>huffman二叉树构造过程</p>
<ol>
<li>由给定的m{1..m}个权值，构造m课二叉树,每个二叉树只有一个根节点,它的权值为m(i)</li>
<li>选取根结点的权值最小的两个结点，将他们作为左右子树，构造成一棵新的二叉树，它的根结点的权值置为其左、右子树根结点权值之和</li>
<li>重复执行步骤（2）最后得到Huffman树</li>
</ol>
</li>
<li>
<p>Huffman二叉树的性质</p>
<ol>
<li>
<p>为满二叉树(不存在度为1的结点) : 设叶子结点的个数为  n 则 Huffman树的总</p>
<p>结点个数 = 2 * n  -1 </p>
</li>
<li>
<p>二叉树与字符编码对应关系</p>
<ol>
<li><code>结点</code> 对应 文档中出现的所有字符</li>
<li><code>叶子结点路径</code>:从根据结点到叶子结点的路径,对应每个字符的编码,(由于到叶子结点的各个路径不同)</li>
<li><code>叶子结点路径长度</code>:从根结点到叶子结点的长度, 对应每个编码的 二进制位数</li>
<li><code>叶子结点带权路径长度</code>:编码后该篇文档中某个字符的数据量</li>
<li><code>树的带权路径长度</code>:编码后,改变文档总的数据量</li>
</ol>
</li>
</ol>
</li>
<li>
<p>如下是 文本 <code>abbcccdddd</code>的Huffman树</p>
<ol>
<li>
<p>图</p>
<p><img src="11.algorithm/C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200313200238710.png" alt="image-20200313200238710" /></p>
</li>
<li>
<p>对应编码图</p>
<table><thead><tr><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th></th></tr></thead><tbody>
<tr><td>编码</td><td>100</td><td>101</td><td>11</td><td>0</td><td></td></tr>
<tr><td>路径长度</td><td>3</td><td>3</td><td>2</td><td>1</td><td></td></tr>
<tr><td>结点的权值</td><td>1</td><td>2</td><td>3</td><td>4</td><td></td></tr>
<tr><td>结点的带权路径长度</td><td>3</td><td>6</td><td>6</td><td>4</td><td></td></tr>
<tr><td>整个Huffman树的带权路径长度(bit位)</td><td></td><td></td><td></td><td></td><td>19</td></tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="编码步骤"><a class="header" href="#编码步骤">编码步骤</a></h2>
<h3 id="编码---以文本-abbcccdddd为例"><a class="header" href="#编码---以文本-abbcccdddd为例">编码 --以文本 &quot;abbcccdddd&quot;为例</a></h3>
<ol>
<li>
<p>统计字符个数</p>
<table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody>
<tr><td>1</td><td>2</td><td>3</td><td>4</td></tr>
</tbody></table>
</li>
<li>
<p>依据字符出现的次数构建优先级队列</p>
</li>
<li>
<p>依据优先级队列构建Huffman树</p>
</li>
<li>
<p>遍历Huffman表 构建Huffman编码对照表</p>
<table><thead><tr><th>a</th><th>b</th><th>c</th><th>d</th></tr></thead><tbody>
<tr><td>100</td><td>101</td><td>11</td><td>0</td></tr>
</tbody></table>
</li>
<li>
<p>依据编码对照表,重新对字符串编码</p>
<p>abbcccdddd -&gt;  1001011011111110000</p>
</li>
<li>
<p>将编码写入文件</p>
<ol>
<li>写入表头
<ol>
<li>表头部分 =  编码对照表长度 + 编码对照表</li>
</ol>
</li>
<li>写入数据</li>
</ol>
</li>
</ol>
<h3 id="解码"><a class="header" href="#解码">解码</a></h3>
<ol>
<li>读入表头部分,形成Huffman编码</li>
<li>将Huffman编码表 转换成 Huffman树 便于解析数据部分</li>
<li>读入数据,依据Huffman树转换字符</li>
</ol>
<h2 id="数据量分析"><a class="header" href="#数据量分析">数据量分析</a></h2>
<ol>
<li>原数据量(bit数) = 10* 8 = 80 ;</li>
<li>编码后数据量 = wpl值 = 19 ;</li>
<li>理论压缩比率 = 19 / 80 ;</li>
<li>实际压缩比率 = (19 + 表头部分数据) / 80</li>
</ol>
<h2 id="c语言实现"><a class="header" href="#c语言实现">C语言实现</a></h2>
<ol>
<li>
<p>编码</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
typedef struct __tag_binary_node
{
    struct __tag_binary_node *right;
    struct __tag_binary_node *left;
    struct __tag_binary_node *next;
    int data;
    char c;
} binary_node;

typedef struct __tag_huffmanTable
{
    int val;
    int start;
} huffmanTable;

//[字符 - 字符出现次数]  对照表
int charTable[255] = {0};
// [字符 - 对应bit编码表 ]
huffmanTable *htable[255] = {0};

binary_node *new_binary_node(int data, char c)
{
    binary_node *node = (binary_node *)malloc(sizeof(binary_node));
    node-&gt;data = data;
    node-&gt;right = NULL;
    node-&gt;left = NULL;
    node-&gt;next = NULL;
    node-&gt;c = c;
    return node;
}

void priority_enqueue(binary_node **head, binary_node *node)
{
    if (head == NULL)
    {
        return;
    }

    binary_node *tmpnode = *head;

    if (*head != NULL)
    {
        if (node-&gt;data - tmpnode-&gt;data &gt; 0)
        {
            while (tmpnode-&gt;next &amp;&amp; node-&gt;data - tmpnode-&gt;next-&gt;data &gt; 0)
            {
                tmpnode = tmpnode-&gt;next;
            };
            node-&gt;next = tmpnode-&gt;next;
            tmpnode-&gt;next = node;
        }
        else
        {
            node-&gt;next = tmpnode;
            *head = node;
        }
    }
    else
    {
        *head = node;
    }
}

binary_node *priority_dequeue(binary_node **head)
{
    if (*head == NULL)
    {
        return NULL;
    }
    binary_node *node = *head;
    *head = (*head)-&gt;next;
    return node;
}

void countChar(FILE *f)
{
    char buf[1024];
    int len;
    while ((len = fread(buf, sizeof(char), sizeof(buf), f)) &gt; 0)
    {
        for (size_t i = 0; i &lt; len; i++)
        {
            charTable[buf[i]]++;
        }
    }
}
//构造Huffman树
void buildPriorityQueue(binary_node **head)
{
    for (size_t i = 0; i &lt; sizeof(charTable) / sizeof(int); i++)
    {
        if (charTable[i])
        {
            binary_node *node = new_binary_node(charTable[i], i);
            priority_enqueue(head, node);
        }
    }
}

//根据 优先级队列转换 成 huaffmantree
binary_node *buildHuffman(binary_node **head)
{
    binary_node *tmpnode1 = NULL;
    binary_node *tmpnode2 = NULL;
    while (*head)
    {
        tmpnode1 = priority_dequeue(head);
        tmpnode2 = priority_dequeue(head);
        if (tmpnode2 != NULL)
        {
            binary_node *node = new_binary_node(tmpnode1-&gt;data + tmpnode2-&gt;data, 0);
            node-&gt;left = tmpnode1;
            node-&gt;right = tmpnode2;
            priority_enqueue(head, node);
        }
    }
    return tmpnode1;
}

//按习惯, 字节都是从高位 开始写入,所以 逆序转换
int reverseByte(int sum, int start)
{
    int count = 0;
    for (size_t i = 0; i &lt; start; i++)
    {
        count += ((sum &gt;&gt; i) &amp; 1) * (1 &lt;&lt; start - i - 1);
    }
    return count;
}
// 根据 Huffman树 构建Huffman编码对照表, sum计算每次走过路径的值, i表示路径长度, wpl = 所有叶子结点的权值 * 路径长度
int tohuffManTable(binary_node *node, int i, int sum)
{
    int wpl = 0;
    if (node-&gt;left != NULL)
    {
        wpl += tohuffManTable(node-&gt;left, i + 1, sum);
    }

    if (node-&gt;right != NULL)
    {
        wpl += tohuffManTable(node-&gt;right, i + 1, sum + (1 &lt;&lt; i));
    }

    if (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)
    {

        htable[node-&gt;c] = (huffmanTable *)malloc(sizeof(huffmanTable));
        htable[node-&gt;c]-&gt;val = reverseByte(sum, i);
        htable[node-&gt;c]-&gt;start = i;
        wpl += node-&gt;data * i;
    }
    return wpl;
}
/* 
    编码文件的格式  = 表头 + 编码后的数据
    表头 =  出现字符的个数 (int)  +  wpl(int)  +  {字符:Huffman编码对照表}
*/
void encodeFile(FILE *src, int wpl, FILE *f)
{
    int size_metadata = 0;
    int size_data = 0;
    int size_real = 0;
    //插入表头
    //统计字符的个数
    int tablesize = 0;
    for (size_t i = 0; i &lt; 255; i++)
    {
        if (htable[i])
        {
            tablesize++;
        }
    }
    //出现字符的个数 (int)
    fwrite(&amp;tablesize, sizeof(int), 1, f);
    size_metadata += sizeof(int);
    //wpl
    fwrite(&amp;wpl, sizeof(int), 1, f);
    size_metadata += sizeof(int);

    for (size_t i = 0; i &lt; 255; i++)
    {
        if (htable[i])
        {
            //该字符
            fwrite(&amp;i, sizeof(char), 1, f);
            size_metadata += sizeof(char);
            //该字符对应的Huffman编码
            fwrite(htable[i], sizeof(huffmanTable), 1, f);
            size_metadata += sizeof(huffmanTable);
        }
    }

    unsigned int sum = 0, k = 0;
    char buf[1024];

    // 初始化
    int len = fread(buf, sizeof(char), sizeof(buf), src);
    size_real += len;
    huffmanTable *t = htable[buf[0]];
    int start = t-&gt;start;
    int toLen = sizeof(int) * 8;

    while (1)
    {
        if (toLen == 0)
        {
            //如果 toLen,32 位 都已填充完则,写入sum到文件, 并重置 sum,toLen
            toLen = sizeof(int) * 8;
            fwrite(&amp;sum, sizeof(sum), 1, f);
            size_data += sizeof(int);
            sum = 0;
        }

        if (start == 0)
        {
            //若某个字符 已写完,则K++, 更换下一个字符
            ++k;
            //若buf缓冲区已读完,则继续从文件中读下一个
            if (k == len)
            {
                //若文件已读完则跳出循环,while循环唯一出口
                if ((len = fread(buf, sizeof(char), sizeof(buf), src)) &lt;= 0)
                {
                    break;
                }
                //缓冲区读入之后,重置k
                k = 0;
                size_real += len;
            }
            //重置 t,start
            t = htable[buf[k]];
            start = t-&gt;start;
        }
        /*
            32位无符号整型中对应的权重: 1 &lt;&lt; toLen - 1
            判断编码 在start位的 0或1: (t-&gt;val &gt;&gt; start - 1) &amp; 1 
        */
        sum += (1 &lt;&lt; toLen - 1) * ((t-&gt;val &gt;&gt; start - 1) &amp; 1);
        toLen--;
        start--;
    }
    // 退出后 还剩最后一个没写完
    fwrite(&amp;sum, sizeof(sum), 1, f);
    size_data += sizeof(int);

    printf(&quot;元数据:%d,编码数据:%d,真实数据:%d,理论压缩率%.2f,实际压缩率%.2f\n&quot;, size_metadata, size_data, size_real, size_data * 1.0 / size_real, (size_data + size_metadata) * 1.0 / size_real);
}

int main(int argc, char const *argv[])
{
    if (argc != 3)
    {
        printf(&quot;usage: %s srcFilePath  destFilePath&quot;, argv[0]);
        return 1;
    }
    FILE *newfile = fopen(argv[1], &quot;r&quot;);
    if (newfile == NULL)
    {
        printf(&quot;源文件不存在,或者目标路径不可用\n&quot;);
        return 1;
    }
    FILE *f = fopen(argv[2], &quot;wb&quot;);
    // 统计字符出现个数
    countChar(newfile);
    rewind(newfile);

    //构建优先级队列
    binary_node *head = NULL;
    buildPriorityQueue(&amp;head);

    //构建Huffman树
    binary_node *rootNode = buildHuffman(&amp;head);

    //遍历Huffman树形成 编码表,并求出 wpl(weighted path length),即对应 编码后的 bit数
    int wpl = tohuffManTable(rootNode, 0, 0);
    //求出remain
    int remain = (sizeof(int) * 8 - wpl % (sizeof(int) * 8));

    //编码文件
    encodeFile(newfile, wpl, f);

    return 0;
}
</code></pre>
</li>
<li>
<p>解码</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
typedef struct __tag_binary_node
{
    struct __tag_binary_node *right;
    struct __tag_binary_node *left;
    struct __tag_binary_node *next;
    int data;
    char c;
} binary_node;

typedef struct __tag_huffmanTable
{
    int val;
    int start;
} huffmanTable;

binary_node *new_binary_node(int data, char c)
{
    binary_node *node = (binary_node *)malloc(sizeof(binary_node));
    node-&gt;data = data;
    node-&gt;right = NULL;
    node-&gt;left = NULL;
    node-&gt;next = NULL;
    node-&gt;c = c;
    return node;
}



void decodeTable()
{
    FILE *f = fopen(&quot;C:\\Users\\Administrator\\Documents\\Tencent Files\\1259103745\\FileRecv\\b.txt&quot;, &quot;rb&quot;);

    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);

    //读 tableSize
    int tableSize = 0;
    fread(&amp;tableSize, sizeof(int), 1, f);
    size -= sizeof(int);
    //读 wpl
    int wpl = 0;
    fread(&amp;wpl, sizeof(int), 1, f);
    size -= sizeof(int);
    int remain = 32 - wpl % 32;
    printf(&quot;wpl=%d,remain=%d&quot;, wpl, remain);
    char ch = 0;
    //读Huffmantable,并生成Huffman树
    binary_node *head = new_binary_node(0, 0), *tmpNode = head;
    int start;
    for (size_t i = 0; i &lt; tableSize; i++)
    {
        huffmanTable *t = (huffmanTable *)malloc(sizeof(huffmanTable));
        fread(&amp;ch, sizeof(char), 1, f);
        size -= sizeof(char);
        fread(t, sizeof(huffmanTable), 1, f);
        size -= sizeof(huffmanTable);
        start = t-&gt;start;
        while (--start &gt;= 0)
        {
            if (t-&gt;val &amp; (1 &lt;&lt; start))
            {
                if (tmpNode-&gt;right == NULL)
                {
                    tmpNode-&gt;right = new_binary_node(0, 0);
                    if (start == 0)
                    {
                        tmpNode-&gt;right-&gt;c = ch;
                    }
                }
                tmpNode = tmpNode-&gt;right;
            }
            else
            {
                if (tmpNode-&gt;left == NULL)
                {
                    tmpNode-&gt;left = new_binary_node(0, 0);
                    if (start == 0)
                    {
                        tmpNode-&gt;left-&gt;c = ch;
                    }
                }
                tmpNode = tmpNode-&gt;left;
            }
        }
        tmpNode = head;
    }
    unsigned int read;
    long alreadyRead = 0;
    int toLen = 0;
    do
    {
        if (toLen == 0)
        {
            toLen = sizeof(int) * 8;
            fread(&amp;read, sizeof(int), 1, f);
            alreadyRead += sizeof(int);
            if (alreadyRead == size)
            {
                toLen -= remain;
                read &gt;&gt;= remain;
            }
        }
        if (tmpNode-&gt;right == NULL &amp;&amp; tmpNode-&gt;left == NULL)
        {
            putchar(tmpNode-&gt;c);
            tmpNode = head;
        }
        if (read &amp; (1 &lt;&lt; toLen - 1))
        {
            tmpNode = tmpNode-&gt;right;
        }
        else
        {
            tmpNode = tmpNode-&gt;left;
        }
        toLen--;
    } while (alreadyRead &lt; size || toLen != 0);
    putchar(tmpNode-&gt;c);
}

int main(int argc, char const *argv[])
{

    //解码文字
    decodeTable();
    return 0;
}
</code></pre>
</li>
</ol>
<h2 id="写在最后"><a class="header" href="#写在最后">写在最后</a></h2>
<ol>
<li>编码的难点在于 位与 字符间 的切换</li>
<li>目前只支持 ASCII编码的字符</li>
<li>写入表头部分格式 是本人自定义的</li>
<li>本篇博客的目的供自己学习参考用,如有错误 欢迎批评指正</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
//编码
void encodeToBase64(const char *buf, int len);
//解码
void decodeBase64(const char *buf, int len);
void reverseBase64();</p>
<p>// 编码码表
char codeTable[64] = {
'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
'+', '/'};</p>
<p>//解码码表
char reverseTable[255];</p>
<p>int main(int argc, char const *argv[])
{
if (argc != 3)
{
printf(&quot;缺少参数\n&quot;);
return -1;
}
reverseBase64();
switch (argv[1][0])
{
// d 为解码
case 'd':
decodeBase64(argv[2], strlen(argv[2]));
break;
//  e为编码
case 'e':
encodeToBase64(argv[2],strlen(argv[2]));
default:
break;
}
return 0;
}</p>
<p>void reverseBase64()
{
for (size_t i = 0; i &lt; sizeof(codeTable); i++)
{
reverseTable[codeTable[i]] = i;
}
}
//  原理: 从高位到低位 取得 二进制的 值相加
void doEncodeToBase64(const char *buf, int len)
{
int i = 6;
int j = 8;
int k = 0;
int rest = 0;
int sum = 0;
char c = buf[0];
while (k &lt; len)
{
// 如果当前字节的位数都已处理完毕,则切换到下一个字节,并恢复标识
if (j == 0)
{
j = 8;
c = buf[++k];
}</p>
<pre><code>    // 如果已取满 六位 二进制,则将该 低六位二进制对应的 值 转换成字符,并恢复标识
    if (i == 0)
    {
        i = 6;
        printf(&quot;%c&quot;, codeTable[sum]);
        sum = 0;
    }

    /*
        1. 判断当前字节 c, 当前处理 位置 j , 的二进制是 0 或 1
           (c &gt;&gt; (j - 1)
        2. 计算 6 -&gt; 8 位转换时 位置j 所处的 权重 
            1 &lt;&lt; (i - 1)
        3. 两者相乘
    */     
    sum += ((c &gt;&gt; (j - 1)) &amp; 1) * (1 &lt;&lt; (i - 1));
    i--;
    j--;
}
if ((rest = len % 3) == 1)
{
    printf(&quot;%c==\n&quot;, codeTable[sum]);
}
else if (rest == 2)
{
    printf(&quot;%c=\n&quot;, codeTable[sum]);
}
</code></pre>
<p>}
// 解码原理 同上
void decodeBase64(const char *buf, int len)
{
int i = 6;
int j = 8;
int k = 0;
int rest = 0;
int codeInt = reverseTable[buf[k]];
int sum = 0;</p>
<pre><code>while (k &lt; len &amp;&amp; buf[k] != '=')
{
    if (i == 0)
    {
        i = 6;
        codeInt = reverseTable[buf[++k]];
    }
    if (j == 0)
    {
        j = 8;
        printf(&quot;%c&quot;, sum);
        sum = 0;
    }

    sum += ((codeInt &gt;&gt; (i - 1)) &amp; 1) * (1 &lt;&lt; (j - 1));

    i--;
    j--;
}
</code></pre>
<p>}</p>
<p>void encodeToBase64(const char *argv, int len)
{</p>
<pre><code>char buf[3072];
FILE *file;
if (file = fopen(argv, &quot;rb&quot;))
{
    while ((len = fread(buf, sizeof(char), sizeof(buf), file)) &gt; 0)
    {
        doEncodeToBase64(buf, len);
    }
}
else
{
    // 当 输入的字符串 不为文件时, 直接当作字符串处理
    doEncodeToBase64(argv, len);
}
</code></pre>
<p>}</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fnv-hash-history"><a class="header" href="#fnv-hash-history">FNV hash history</a></h2>
<p>The basis of the <strong>FNV</strong> hash algorithm was taken from an idea sent as reviewer comments to the IEEE POSIX P1003.2 committee by <a href="http://www.research.att.com/%7Egsf/">Glenn Fowler</a> and <a href="http://www.research.att.com/info/kpv/">Phong Vo</a> back in 1991. In a subsequent ballot round: <a href="http://www.isthe.com/chongo/index.html">Landon Curt Noll</a> improved on their algorithm. Some people tried this hash and found that it worked rather well. In an EMail message to Landon, they named it the <code>**Fowler/Noll/Vo**'' or **FNV** hash.</code></p>
<p>FNV hash算法 的基础取自 1991年 由 <a href="http://www.research.att.com/%7Egsf/">Glenn Fowler</a> and <a href="http://www.research.att.com/info/kpv/">Phong Vo</a>  作为审稿人意见 ， 提交给  IEEE POSIX P1003.2 委员会 的一个想法。在随后的一轮投票中， <a href="http://www.isthe.com/chongo/index.html">Landon Curt Noll</a>  改进了他们的算法。有些人尝试了这个哈希，发现它工作得很好。 他们将其命名为 <code>**Fowler/Noll/Vo**'' or **FNV** hash</code></p>
<p><strong>FNV</strong> hashes are designed to be fast while maintaining a low collision rate. The <strong>FNV</strong> speed allows one to quickly hash lots of data while maintaining a reasonable collision rate. The high dispersion of the <strong>FNV</strong> hashes makes them well suited for hashing nearly identical strings such as URLs, hostnames, filenames, text, IP addresses, etc.</p>
<p>The IETF has an informational draft on <a href="http://tools.ietf.org/html/draft-eastlake-fnv-03">The FNV Non-Cryptographic Hash Algorithm</a></p>
<p>FNV哈希值 设计为 快速、同时保持低的冲突，FNV 哈希值的高分散性 使它非常适合对 几乎相同的字符串如  URL、主机名、文件名、文本、IP地址等 进行hash处理</p>
<p>IETF有一个关于<a href="http://tools.ietf.org/html/draft-eastlake-fnv-03">FNV非加密哈希算法</a>的信息草案。</p>
<p>The <strong>FNV</strong> hash is in wide spread use:</p>
<ul>
<li><a href="http://www.isthe.com/chongo/tech/comp/calc/index.html">calc</a></li>
<li>Domain Name Servers(DNS)</li>
<li>mdbm key/value data lookup functions</li>
<li>Database indexing hashes</li>
<li>major web search / indexing engines</li>
<li>high performance EMail servers</li>
<li>Netnews history file Message-ID lookup functions</li>
<li>Anti-spam filters</li>
<li>NFS implementations (e.g., <a href="http://www.freebsd.org/releases/4.3R/notes.html">FreeBSD 4.3</a>, IRIX, Linux (NFS v4))</li>
<li><a href="http://www.cohesia.com/">Cohesia MASS project</a> server collision avoidance</li>
<li>spellchecker programmed in Ada 95</li>
<li><a href="http://flatassembler.net/">flatassembler</a>'s open source x86 assembler - <a href="http://board.flatassembler.net/viewtopic.php?t=854">user-defined symbol hashtree</a></li>
<li><a href="http://www.isthe.com/chongo/tech/comp/fnv/#PowerBASIC">PowerBASIC</a> inline assembly routine</li>
<li>text based referenced resources for video games on the PS2, Gamecube and XBOX</li>
<li>non-cryptographic file fingerprints</li>
<li><a href="http://fret.sourceforge.net/">FRET</a> - a tool to identify file data structures / helps to understand file formats</li>
<li>used to in the process of computing Unique IDs in DASM (DTN Applications for Symbian Mobile-phones)</li>
<li>Used by Microsoft in their hash_map implementation for VC++ 2005</li>
<li>Used in an implementation of <a href="http://www.last.fm/user/RJ/journal/2007/04/10/392555/">libketama</a> for use in items such as <a href="http://pecl.php.net/package/memcache">memcache</a>.</li>
<li>Used in the realpath cache in <a href="http://www.php.net/">PHP 5.x</a> (php-5.2.3/TSRM/tsrm_virtual_cwd.c).</li>
<li>Used to <a href="http://www.slideshare.net/Eweaver/improving-running-components-at-twitter">improve the fragment cache</a> at <a href="http://twitter.com/">twitter</a> (see slide 31).</li>
<li>Used in the <a href="http://sourceforge.net/projects/fasmlab/">BSD IDE project</a></li>
<li>Used in the <a href="http://www.deliantra.net/">deliantra game server</a> for it's shared string implementation</li>
<li>Used to improve <a href="http://www.sanmayce.com/Downloads/">Leprechaun</a>, an extremely fast word list creator</li>
<li>Favored as a hash for IPv6 Flow Labels in a <a href="https://researchspace.auckland.ac.nz/bitstream/handle/2292/13240/flowhashRep.pdf">University of Auckland Computer Science Technical Report (2012-002)</a> of March 2012</li>
<li>Used in the speed-sensitive guts of <a href="http://twistylists.blogspot.com/">twistylists</a>, an open-source structured namespace manager</li>
</ul>
<p>The core of the <strong>FNV-1</strong> hash algorithm is as follows:</p>
<pre><code class="language-c">hash = offset_basis
for each _octet_of_data_ to be hashed
 hash = hash * FNV_prime
 hash = hash xor _octet_of_data_
return hash
</code></pre>
<p><strong>NOTE:</strong> We recommend that you use the <a href="http://www.isthe.com/chongo/tech/comp/fnv/#FNV-1a">FNV-1a alternative algorithm</a> instead of the <strong>FNV-1</strong> hash where possible.</p>
<h2 id="parameters-of-the-fnv-1fnv-1a-hash"><a class="header" href="#parameters-of-the-fnv-1fnv-1a-hash">Parameters of the FNV-1/FNV-1a hash</a></h2>
<p>The <strong>FNV-1</strong> hash parameters are as follows:</p>
<ul>
<li>
<p>hash值是 一个n位的 无符合整形。n是 hash的长度</p>
</li>
<li>
<p>The multiplication is performed modulo 2<strong>n</strong> where <strong>n</strong> is the bit length of <strong>hash</strong>.</p>
</li>
<li>
<p>The xor is performed on the low order octet (8 bits) of <strong>hash</strong>.</p>
</li>
<li>
<p>The <strong><em>FNV_prime</em></strong> is dependent on <strong>n</strong>, the size of the hash:</p>
<blockquote>
<p>32 bit <strong><em>FNV_prime</em></strong> = 224 + 28 + 0x93 = 16777619</p>
<p>64 bit <strong><em>FNV_prime</em></strong> = 240 + 28 + 0xb3 = 1099511628211</p>
<p>128 bit <strong><em>FNV_prime</em></strong> = 288 + 28 + 0x3b = 309485009821345068724781371</p>
<p>256 bit <strong><em>FNV_prime</em></strong> = 2168 + 28 + 0x63 = 374144419156711147060143317175368453031918731002211</p>
<p>512 bit <strong><em>FNV_prime</em></strong> = 2344 + 28 + 0x57 =<br />
35835915874844867368919076489095108449946327955754392558399825615420669938882575<br />
126094039892345713852759</p>
<p>1024 bit <strong><em>FNV_prime</em></strong> = 2680 + 28 + 0x8d =<br />
50164565101131186554345988110352789550307653454047907443030175238311120551081474<br />
51509157692220295382716162651878526895249385292291816524375083746691371804094271<br />
873160484737966720260389217684476157468082573</p>
</blockquote>
<p>Part of the magic of <strong>FNV</strong> is the selection of the <strong><em>FNV_prime</em></strong> for a given sized unsigned integer. Some primes do hash better than other primes for a given integer size.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-2"><a class="header" href="#介绍-2">介绍</a></h1>
<p>AVL树是一种自平衡二叉搜索树（BST binary search tree），其中左子树和右子树的高度之差对于所有节点都不能超过一个。</p>
<h1 id="最小失衡子树"><a class="header" href="#最小失衡子树">最小失衡子树</a></h1>
<ul>
<li>只有对  插入的树 新增一个层次 才会导致失衡，所以 最小失衡子树 （从插入结点往上遍历，找到的第一个失衡子树）的高度必定大于等于2，左右子树高度差的绝对值 必定大于等于2</li>
</ul>
<h1 id="导致平衡二叉树-失衡的情况"><a class="header" href="#导致平衡二叉树-失衡的情况">导致平衡二叉树 失衡的情况</a></h1>
<p><strong>则 对于第二层，失衡有两种类别</strong></p>
<ul>
<li>位于左边</li>
<li>位于右边</li>
</ul>
<p><strong>对于第三层，失衡也有两种类别</strong></p>
<ul>
<li>位于左边</li>
<li>位于右边</li>
</ul>
<h2 id="left-left-case"><a class="header" href="#left-left-case"><strong>Left Left Case</strong></a></h2>
<blockquote>
<p>失衡 位于 Left，left 情况</p>
</blockquote>
<pre><code>T1, T2, T3 and T4 are subtrees.
         z                                      y 
        / \                                   /   \
       y   T4      Right Rotate (z)          x      z
      / \          - - - - - - - - -&gt;      /  \    /  \ 
     x   T3                               T1  T2  T3  T4
    / \
  T1   T2
</code></pre>
<h2 id="left-right-case"><a class="header" href="#left-right-case"><strong>Left Right Case</strong></a></h2>
<blockquote>
<p>失衡 位于 Left，right 情况</p>
</blockquote>
<pre><code>     z                               z                           x
    / \                            /   \                        /  \ 
   y   T4  Left Rotate (y)        x    T4  Right Rotate(z)    y      z
  / \      - - - - - - - - -&gt;    /  \      - - - - - - - -&gt;  / \    / \
T1   x                          y    T3                    T1  T2 T3  T4
    / \                        / \
  T2   T3                    T1   T2
</code></pre>
<h2 id="right-right-case"><a class="header" href="#right-right-case"><strong>Right Right Case</strong></a></h2>
<blockquote>
<p>失衡 位于 right,right 情况</p>
</blockquote>
<pre><code>  z                                y
 /  \                            /   \ 
T1   y     Left Rotate(z)       z      x
    /  \   - - - - - - - -&gt;    / \    / \
   T2   x                     T1  T2 T3  T4
       / \
     T3  T4
</code></pre>
<h2 id="right-left-case"><a class="header" href="#right-left-case"><strong>Right Left Case</strong></a></h2>
<blockquote>
<p>失衡 位于 Left，left 情况</p>
</blockquote>
<pre><code>   z                            z                            x
  / \                          / \                          /  \ 
T1   y   Right Rotate (y)    T1   x      Left Rotate(z)   z      y
    / \  - - - - - - - - -&gt;     /  \   - - - - - - - -&gt;  / \    / \
   x   T4                      T2   y                  T1  T2  T3  T4
  / \                              /  \
T2   T3                           T3   T4
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="位运算介绍"><a class="header" href="#位运算介绍">位运算介绍</a></h1>
<blockquote>
<p>程序中的所有数在计算机内存中都是以二进制的形式储存的。位运算就是直接对<strong>整数在内存中的二进制位进行操作</strong>。</p>
</blockquote>
<p>位运算就是直接操作二进制数，那么有哪些种类的位运算呢？</p>
<h2 id="与"><a class="header" href="#与"><strong>&amp; (与)</strong></a></h2>
<p><strong>规则</strong>：将整数对应的 二进制对应 按位进行逻辑AND运算</p>
<p><strong>真值表</strong>：</p>
<table><thead><tr><th></th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>1</td><td>1</td><td>0</td></tr>
<tr><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>
<h2 id="-或"><a class="header" href="#-或"><strong>| (或)</strong></a></h2>
<p><strong>真值表</strong></p>
<table><thead><tr><th></th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>1</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
</tbody></table>
<h2 id="-异或"><a class="header" href="#-异或"><strong>^ (异或)</strong></a></h2>
<p>**</p>
<table><thead><tr><th></th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
</tbody></table>
<h2 id="取反"><a class="header" href="#取反"><strong>取反~</strong></a></h2>
<p>如果是1，则为0，如果是0则为1</p>
<h2 id="移位运算符"><a class="header" href="#移位运算符"><strong>移位运算符</strong></a></h2>
<p>左移运算&lt;&lt;：左移后右边位补 0，高位溢出</p>
<p>带符号右移运算&gt;&gt;：右移后左边位补符号位</p>
<p>无符号右移运算&gt;&gt;&gt;：右移后左边位补 0</p>
<h1 id="位运算小技巧"><a class="header" href="#位运算小技巧"><strong>位运算小技巧</strong></a></h1>
<h2 id="奇偶判断"><a class="header" href="#奇偶判断">奇偶判断</a></h2>
<pre><code class="language-java">//普通算法
if( n % 2 == 1)
    // n 是个奇数
}

//位运算
if(n &amp; 1 == 1){
    // n 是个奇数。
}
</code></pre>
<p>其核心就是判断二进制的<strong>最后一位是否为1</strong>，如果为1那么结果加上2^0=1一定是个奇数，否则就是个偶数。</p>
<h2 id="交换两个数"><a class="header" href="#交换两个数"><strong>交换两个数</strong></a></h2>
<pre><code class="language-java">a=a^b;//a=a^b
b=a^b;//b=(a^b)^b=a^0=a
a=a^b;//a=(a^b)^(a^b^b)=0^b=0
</code></pre>
<h2 id="二进制枚举"><a class="header" href="#二进制枚举"><strong>二进制枚举</strong></a></h2>
<blockquote>
<p>每一个二进制位就是一种状态，</p>
</blockquote>
<pre><code class="language-java">for(int i = 0; i &lt; (1&lt;&lt;n); i++) //从0～2^n-1个状态
{
  for(int j = 0; j &lt; n; j++) //遍历二进制的每一位 共n位
  {
    if(i &amp; (1 &lt;&lt; j))//判断二进制数字i的第j位是否存在
    {
      //操作或者输出
    }
  }
}
</code></pre>
<h2 id="不用加减乘除做加法"><a class="header" href="#不用加减乘除做加法"><strong>不用加减乘除做加法</strong></a></h2>
<blockquote>
<p>核心：<strong>a&amp;b</strong> 得到需要进位的，左移一位，a^b 直接相加</p>
</blockquote>
<pre><code class="language-c++">public class Solution {
     public int Add(int num1,int num2) {
  /*
   *  5+3   5^3(0110)   5&amp;3(0001) 
   *  0101    
   *  0011 
   */
  int a=num1^num2;
  int b=num1&amp;num2;
  b=b&lt;&lt;1;
  if(b==0)return a;
  else {
   return Add(a, b);
  }        
  }
}
</code></pre>
<h2 id="二进制中1的个数"><a class="header" href="#二进制中1的个数"><strong>二进制中1的个数</strong></a></h2>
<h3 id="法一"><a class="header" href="#法一"><strong>法一</strong></a></h3>
<p><strong>暴力搜索</strong></p>
<pre><code class="language-java">public int NumberOf1(int n) {
  int va=0;
  for(int i=0;i&lt;32;i++)
  {
    if((n&amp;(1&lt;&lt;i))!=0)
    {           
      va++;
    }
  }
  return va;       
}
</code></pre>
<h3 id="法二"><a class="header" href="#法二"><strong>法二</strong></a></h3>
<p><strong>每次消除 最小的那个1</strong></p>
<pre><code class="language-c++">public class Solution {
    public int NumberOf1(int n) {
    int count=0;
    while (n!=0) {
     n=n&amp;(n-1);
     count++;
    }
    return count;
 }
}
</code></pre>
<h2 id="只出现一次的一个数字①"><a class="header" href="#只出现一次的一个数字①"><strong>只出现一次的(一个)数字</strong>①</a></h2>
<p><strong>问题描述</strong></p>
<ul>
<li><strong>给定一个非空整数数组，除了某个元素只出现一次以外，<strong>其余每个元素均出现两次</strong>。找出那个只出现了一次的元素。</strong></li>
<li>异或运算特点： 
<ul>
<li><strong>0和任意数字进行异或操作结果为数字本身.</strong></li>
<li><strong>两个相同的数字进行异或的结果为0.</strong></li>
</ul>
</li>
</ul>
<p>对所有数组元素，求 异或则可以找出那个 一次元素的值</p>
<pre><code class="language-c++">class Solution {
    public int singleNumber(int[] nums) {
        int value=0;
        for(int i=0;i&lt;nums.length;i++)
        {
            value^=nums[i];
        }
        return value;
    }
}
</code></pre>
<h2 id="只出现一次的一个数字②"><a class="header" href="#只出现一次的一个数字②"><strong>只出现一次的(一个)数字②</strong></a></h2>
<p>判断 数组中所有元素，32位 中，为1的个数应为3的倍数，如果不是3的倍数 则相加</p>
<pre><code class="language-java">class Solution {
    public int singleNumber(int[] nums) {
        int value=0;
        for(int i=0;i&lt;32;i++)
        {
            int sum=0;
            for(int num:nums)
            {
                if(((num&gt;&gt;i)&amp;1)==1)
                {
                    sum++;
                }
            }
            if(sum%3==1)
                value+=(1&lt;&lt;i);
        }
        return value;
    }
}
</code></pre>
<h2 id="只出现一次的两个数字③"><a class="header" href="#只出现一次的两个数字③"><strong>只出现一次的(两个)数字③</strong></a></h2>
<p>一个整型数组里除了两个数字之外，<strong>其他的数字都出现了两次</strong>。请写程序找出这两个只出现一次的数字。</p>
<ul>
<li>先异或一遍，得到 <code>a^b</code> 的值</li>
<li>然后 取第一个为1的位位 n</li>
<li>再将数组一分为2，第n位为0的 一定存在一个只出现一次的数，该位为1的一定也存在一个 只出现一次的数</li>
</ul>
<pre><code class="language-java">public int[] singleNumbers(int[] nums) {
    int value[]=new int[2];
    if(nums.length==2)
        return  nums;
    int val=0;//异或求的值
    for(int i=0;i&lt;nums.length;i++)
    {
        val^=nums[i];
    }
    int index=getFirst1(val);
    int num1=0,num2=0;
    for(int i=0;i&lt;nums.length;i++)
    {
        if(((nums[i]&gt;&gt;index)&amp;1)==0)//如果这个数第index为0 和num1异或
            num1^=nums[i];
        else//否则和 num2 异或
            num2^=nums[i];
    }
    value[0]=num1;
    value[1]=num2;
    return  value;
}

private int getFirst1(int val) {
    int index=0;
    while (((val&amp;1)==0&amp;&amp;index&lt;32))
    {
        val&gt;&gt;=1;// val=val/2
        index++;
    }
    return index;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态规划的核心"><a class="header" href="#动态规划的核心">动态规划的核心</a></h1>
<p>动态规划算法的核心是记住已经求过的解</p>
<p>记住求解的方式有两种：①<strong>自顶向下的备忘录法</strong> ②<strong>自底向上</strong></p>
<h1 id="以-fibonacci--数列举例"><a class="header" href="#以-fibonacci--数列举例">以 <strong>Fibonacci</strong>  数列举例</a></h1>
<h2 id="自顶向下的备忘录法"><a class="header" href="#自顶向下的备忘录法"><strong>自顶向下的备忘录法</strong></a></h2>
<pre><code class="language-c">public static int Fibonacci(int n)
{
        if(n&lt;=0)
            return n;
        int []Memo=new int[n+1];        
        for(int i=0;i&lt;=n;i++)
            Memo[i]=-1;
        return fib(n, Memo);
    }
    public static int fib(int n,int []Memo)
    {

        if(Memo[n]!=-1)
            return Memo[n];
    //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。               
        if(n&lt;=2)
            Memo[n]=1;

        else Memo[n]=fib( n-1,Memo)+fib(n-2,Memo);  

        return Memo[n];
    }
</code></pre>
<h2 id="自底向上的动态规划"><a class="header" href="#自底向上的动态规划"><strong>自底向上的动态规划</strong></a></h2>
<pre><code class="language-c">public static int fib(int n)
{
        if(n&lt;=0)
            return n;
        int []Memo=new int[n+1];
        Memo[0]=0;
        Memo[1]=1;
        for(int i=2;i&lt;=n;i++)
        {
            Memo[i]=Memo[i-1]+Memo[i-2];
        }       
        return Memo[n];
}
</code></pre>
<p>自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。观察参与循环的只有 i，i-1 , i-2三项，因此该方法的空间可以进一步的压缩如下。</p>
<pre><code class="language-c">public static int fib(int n)
    {
        if(n&lt;=1)
            return n;

        int Memo_i_2=0;
        int Memo_i_1=1;
        int Memo_i=1;
        for(int i=2;i&lt;=n;i++)
        {
            Memo_i=Memo_i_2+Memo_i_1;
            Memo_i_2=Memo_i_1;
            Memo_i_1=Memo_i;
        }       
        return Memo_i;
    }
</code></pre>
<h1 id="钢条切割问题"><a class="header" href="#钢条切割问题">钢条切割问题</a></h1>
<p><strong>长度价格表</strong></p>
<table><thead><tr><th>长度</th><th>价格</th></tr></thead><tbody>
<tr><td>1</td><td>1</td></tr>
<tr><td>2</td><td>5</td></tr>
<tr><td>3</td><td>8</td></tr>
<tr><td>4</td><td>9</td></tr>
<tr><td>5</td><td>10</td></tr>
<tr><td>6</td><td>17</td></tr>
<tr><td>7</td><td>17</td></tr>
<tr><td>8</td><td>20</td></tr>
<tr><td>9</td><td>24</td></tr>
<tr><td>10</td><td>30</td></tr>
</tbody></table>
<p><strong>收益描述</strong></p>
<p>$ r_n = max(p_n,r_1+r_{n-1},r_2+r_{n-2},...,r_{n-1}+r_1)$ </p>
<p><strong>简单描述</strong></p>
<p>$ \max_{i=1}^n(p_i+r_{n-i}) $</p>
<p><strong>递归版本</strong></p>
<pre><code class="language-c">public static int cut(int []p,int n)
    {
        if(n==0)
            return 0;
        int q=Integer.MIN_VALUE;
        for(int i=1;i&lt;=n;i++)
        {
            q=Math.max(q, p[i-1]+cut(p, n-i));  
        }
        return q;
    }
</code></pre>
<p><strong>备忘录版本</strong></p>
<pre><code class="language-c">public static int cutMemo(int []p)
    {
        int []r=new int[p.length+1];
        for(int i=0;i&lt;=p.length;i++)
            r[i]=-1;                        
        return cut(p, p.length, r);
    }
    public static int cut(int []p,int n,int []r)
    {
        int q=-1;
        if(r[n]&gt;=0)
            return r[n];
        if(n==0)
            q=0;
        else {
            for(int i=1;i&lt;=n;i++)
                q=Math.max(q, cut(p, n-i,r)+p[i-1]);
        }
        r[n]=q;

        return q;
    }
</code></pre>
<p><strong>自底向上的动态规划</strong></p>
<pre><code class="language-c">public static int buttom_up_cut(int []p)
{
        int []r=new int[p.length+1];
        for(int i=1;i&lt;=p.length;i++)
        {
            int q=-1;
            //①
            for(int j=1;j&lt;=i;j++)
                q=Math.max(q, p[j-1]+r[i-j]);
            r[i]=q;
        }
        return r[p.length];
}
</code></pre>
<h1 id="动态规划原理"><a class="header" href="#动态规划原理">动态规划原理</a></h1>
<h2 id="最优子结构"><a class="header" href="#最优子结构"><strong>最优子结构</strong></a></h2>
<h2 id="重叠子问题"><a class="header" href="#重叠子问题"><strong>重叠子问题</strong></a></h2>
<h1 id="动态规划的经典模型"><a class="header" href="#动态规划的经典模型"><strong>动态规划的经典模型</strong></a></h1>
<h2 id="线性模型"><a class="header" href="#线性模型"><strong>线性模型</strong></a></h2>
<p>状态的排布是呈线性的</p>
<h2 id="区间模型"><a class="header" href="#区间模型"><strong>区间模型</strong></a></h2>
<p>区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。</p>
<h2 id="背包模型"><a class="header" href="#背包模型"><strong>背包模型</strong></a></h2>
<p>有N种物品（每种物品1件）和一个容量为V的背包。放入第 i 种物品耗费的空间是Ci，得到的价值是Wi。求解将哪些物品装入背包可使价值总和最大。f[i][v]表示前i种物品恰好放入一个容量为v的背包可以获得的最大价值。决策为第i个物品在前i-1个物品放置完毕后，是选择放还是不放，状态转移方程为：</p>
<p>$ f[i][v] = max{ f[i-1][v], f[i-1][v – C_i] +W_i } $</p>
<p>时间复杂度O(VN)，空间复杂度O(VN) （空间复杂度可利用滚动数组进行优化达到O(V) ）。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="1-动态规划概念"><a class="header" href="#1-动态规划概念">1. 动态规划概念</a></h2>
<p>动态规划的本质不在于是递推或是递归，也不需要纠结是不是内存换时间。</p>
<p>动态规划 方法论 意在帮助我们快速找到解决问题的办法</p>
<p>如下图。我们在解决某些最优问题时可将解决问题的过程按照一定次序分为若干个互相联系的阶段（1, 2, ..., N），从而将一个大问题化成一系列子问题，然后逐个求解。</p>
<p>在每一个阶段都需要作出决策，从而使整个过程达到最优
各个阶段决策的选取<strong>仅依赖当前状态</strong>（这里的当前状态指的是当前阶段的输入状态），从而确定输出状态</p>
<p>当各个阶段决策确定后，就组成了一个决策序列，这个决策序列就决定了问题的最终解决方案。</p>
<p>这种把一个问题可看作是一个前后关联具有链状结构的多阶段过程就称为<strong>多阶段决策过程</strong>。</p>
<p>动态规划将一个大问题化成<strong>一族互相联系、同类型的子问题</strong>
既然是同类型，我们在逐个解决子问题的时候，就可以利用相同的决策，从而更容易的解决问题。</p>
<p>互相联系利用前面已经解决的子问题的最优化结果来依次进行计算接下来的子问题，当最后一个子问题得到最优解时，就是整个问题的最优解。</p>
<p>这里面包括两个关键点：
每一个阶段可能包括很多状态，前后阶段的状态通过决策联系在一起。</p>
<p>如果要利用前阶段子问题的结果解决现阶段的子问题，必须要能够建立前后阶段状态的转移关系，最好可以通过方程表示。用专业术语我们又叫做**”状态转移方程“**。</p>
<p>我们在衡量最优解的时候需要有一个指标函数，最优解就是让这个指标函数达到最优值，比如最大或者最小</p>
<p>如果我们可以将问题拆分成子问题，那么这个<strong>指标函数也必须具有分离性</strong>
，也就是必须能够利用子问题的最优递推的求出整体最优。当整体最优求解出以后，就可以知道各个子问题的最优解。</p>
<p>例如，平时购物找零钱时，为使找回的零钱的硬币数最少，不要求找零钱的所有方案，而是从最大面值的币种开始，按递减的顺序考虑各面额，先尽量用大面值的面额，当不足大面值时才去考虑下一个较小面值，这就是贪心算法</p>
<ol start="2">
<li></li>
<li>
<p>题目1:找零钱问题</p>
</li>
<li>
<p>题目2:最短路径算法</p>
</li>
<li>
<p>总结三步</p>
</li>
<li>
<p>找状态</p>
</li>
<li>
<p>找状态转移方程</p>
</li>
<li>
<p>编码</p>
</li>
<li>
<p>优化</p>
</li>
<li>
<p>最长递增子序列</p>
</li>
<li>
<p>最长连续递增子序列</p>
</li>
<li>
<p>0-1背包问题</p>
</li>
<li>
<p>总结</p>
</li>
<li>
<p>动态规划 本质</p>
</li>
<li>
<p>降低问题的复杂度</p>
</li>
<li>
<p>子问题 推导出 大问题</p>
</li>
<li>
<p>技巧</p>
</li>
<li>
<p>找状态</p>
</li>
<li>
<p>此状态是否能 由子状态得到，或者说子状态对 父状态有没有帮助</p>
</li>
<li>
<p>code</p>
</li>
<li>
<p>根据转移写出 递归式。因为递归式是最自然的 表达形式</p>
</li>
<li>
<p>优化</p>
</li>
<li>
<p>消除重叠子问题：加缓存 优化时间复杂度</p>
</li>
<li>
<p>自顶向下-&gt;自底向上：改成迭代</p>
</li>
<li>
<p>叠加状态 优化空间复杂度</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符编码"><a class="header" href="#字符编码">字符编码</a></h1>
<h2 id="ascii"><a class="header" href="#ascii">ASCII</a></h2>
<ol>
<li>一共128个字符的编码</li>
<li>占七位的bit位,最前面的一位统一为0</li>
</ol>
<h2 id="iso-8859-1"><a class="header" href="#iso-8859-1">ISO-8859-1</a></h2>
<ol>
<li>扩展的ASCII编码,对 1000 0000 ~ 1111 1111 这一段进行了编码,总共能表示256个字符</li>
<li>但仍然无法表示中文</li>
</ol>
<h2 id="gb2312"><a class="header" href="#gb2312">GB2312</a></h2>
<ol>
<li>
<p>是第一个汉字编码国家标准共收录汉字6763个，其中一级汉字3755个，二级汉字3008个</p>
</li>
<li>
<p>同时，GB2312编码收录了包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符</p>
</li>
<li>
<p>编码原理</p>
<ol>
<li>分为<code>94</code>个区,每个区对应<code>94</code>个码位则 <code>GB2312</code>的编码范围为 <code>0101~9494</code> (十进制)
<ol>
<li>01-09区 收录除汉字外的682个字符</li>
<li>10-15区为空白区，没有使用。</li>
<li>16-55区收录3755个一级汉字，按拼音排序。</li>
<li>56-87区收录3008个二级汉字，按部首/笔画排序。</li>
<li>88-94区为空白区，没有使用。</li>
</ol>
</li>
<li>加上0xA0 即为 GB2312实际编码值 二进制编码范围为 <code>0xA1A1~0XFEFE</code></li>
<li>GB2312采用双字节编码, 高字节表示区位,低字节表示码位</li>
</ol>
</li>
<li>
<p>example</p>
<ol>
<li>'李' 的区位码是3278 ,32区78位,  转换成 十六进制  0x204E, 加上0xA0 =  0xC0EE</li>
</ol>
</li>
<li>
<p>汉字码位与码点查询</p>
<p>https://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php</p>
</li>
</ol>
<h2 id="big5"><a class="header" href="#big5">BIG5</a></h2>
<ol>
<li>
<p>BIG5采用双字节编码,高位字节使用了0x81-0xFE，低位字节使用了0x40-0x7E，及0xA1-0xFE</p>
</li>
<li>
<p>是繁体中文字符集编码,共收录13060个中文字，其中有二字为重复编码，即“兀、兀”（A461及C94A)和“嗀、嗀”(DCD1及DDFC)</p>
</li>
<li>
<p>具体分区</p>
<pre><code>8140-A0FE 保留给使用者自定义字符（造字区）
A140-A3BF 标点符号、希腊字母及特殊符号。其中在A259-A261，收录了度量衡单位用字：兙兛兞兝兡兣嗧瓩糎。
A3C0-A3FE 保留。此区没有开放作造字区用。
A440-C67E 常用汉字，先按笔划再按部首排序。
C6A1-F9DC 其它汉字。
F9DD-F9FE 制表符。
</code></pre>
</li>
</ol>
<h2 id="gbk"><a class="header" href="#gbk">GBK</a></h2>
<ol>
<li>
<p>GBK编码扩展了GB2312，完全兼容GB2312编码,不兼容BIG5编码</p>
</li>
<li>
<p>编码范围</p>
<p>8140－FEFE，剔除xx7F码位，共23940个码位,</p>
<p>共收录汉字和图形符号21886个，其中汉字（包括部首和构件）21003个，图形符号883个</p>
</li>
</ol>
<h2 id="ansi"><a class="header" href="#ansi">ANSI</a></h2>
<ol>
<li>在winodws平台 对于英文文件是<code>ASCII</code>编码，对于简体中文文件是<code>GB2312</code>编码</li>
<li>在繁体中文Windows操作系统中，ANSI编码代表Big5；</li>
<li>在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码</li>
<li>不同 ANSI 编码之间互不兼容</li>
</ol>
<h2 id="unicode"><a class="header" href="#unicode">Unicode</a></h2>
<h3 id="unicode简介"><a class="header" href="#unicode简介">Unicode简介</a></h3>
<ol>
<li>
<p>Unicode是一张表,规定了每个字符对应二进制的值</p>
</li>
<li>
<p>Unicode表包含了1114112个码点，即从000000（十六进制） - 10FFFF（十六进制)</p>
</li>
<li>
<p>Unicode将码空间划分为17个平面, 从 00-10(十六进制),最高位的一个字节,每个平面有65536个码点,即两个字节</p>
<ol>
<li>基本多语言平面（Basic Multilingual Plane）码点从 0000~FFFF,包含了最常用的字符
<ol>
<li>其中从D800到DFFF之间的码位区段是永久保留不映射到字符的</li>
</ol>
</li>
<li>其他平面称为辅助平面(Supplementary Planes)</li>
</ol>
</li>
<li>
<p>Unicode只是一个符号集，只规定的字符所对应的码点，并没有指定如何存储</p>
</li>
<li>
<p>unicode码点表</p>
<p>https://unicode-table.com/cn</p>
</li>
<li>
<p>关于Unicode编码方案主要有两条主线：UCS和UTF。UTF主线由Unicode Consortium进行维护管理，UCS主线由ISO/IEC进行维护管理。</p>
</li>
<li>
<p><strong>注意，BMP里存在一种特殊区域: 代理区(Surrogate)。Unicode标准规定U+D800 - U+DFFF的值不对应于任何字符</strong>。后面可以看到，UTF-16就巧妙地利用了这一段空白区域进行了编码的转换。</p>
</li>
</ol>
<h3 id="ucsuniversal-character-set"><a class="header" href="#ucsuniversal-character-set">UCS(Universal Character Set)</a></h3>
<h4 id="ucs-2"><a class="header" href="#ucs-2">UCS-2</a></h4>
<ol>
<li>定长二个字节编码, 0000~FFFF 对应的码点范围 对应第一个Unicode平面</li>
<li>采用BOM(Byte Order Mark)机制，该机制作用如下：
<ol>
<li>确定字节流采用的是大端序还是小端序。</li>
<li>确定字节流的Unicode编码方案。</li>
</ol>
</li>
</ol>
<h4 id="ucs-4"><a class="header" href="#ucs-4">UCS-4</a></h4>
<ol>
<li>UCS-4是定长字节的，固定使用4个字节进行编码。也采用了BOM机制。</li>
</ol>
<h3 id="utf-8unicode-transformation-format"><a class="header" href="#utf-8unicode-transformation-format">UTF-8(Unicode Transformation Format)</a></h3>
<ol>
<li>
<p>UTF-8是一种变长编码方式，使用1-4个字节进行编码</p>
</li>
<li>
<p>完全兼容ASCII</p>
</li>
<li>
<p>编码规则</p>
<ol>
<li>
<p>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码</p>
</li>
<li>
<p>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
</li>
<li>
<p>unicode范围以及 对应UTF-8编码方式</p>
<table><thead><tr><th style="text-align: left">Unicode范围(十六进制位数)</th><th>十进制范围</th><th>二进制范围</th><th>UTF-8编码方式</th><th>UTf-8实际可编码的位数</th></tr></thead><tbody>
<tr><td style="text-align: left">0000 0000 ~ 0000 007F</td><td>0~127</td><td>1-7</td><td>0xxx xxxx<br /> (ASCII编码范围)</td><td>7</td></tr>
<tr><td style="text-align: left">0000 0080 ~ 0000 07FF</td><td>128~2047</td><td>7-11</td><td>110x xxxx 10xx xxxx</td><td>11</td></tr>
<tr><td style="text-align: left">0000 0800 ~ 0000 FFFF</td><td>2048~65535</td><td>11-16</td><td>1110 xxxx 10xx xxxx 10xx xxxx</td><td>16</td></tr>
<tr><td style="text-align: left">0001 0000 ~ 0010 FFFF</td><td>65536~1114111</td><td>16~21</td><td>11110xxx 10xx xxxx 10xx xxxx 10xx xxxx</td><td>21</td></tr>
</tbody></table>
</li>
<li>
<p>Unicode规定从 0000~FFFF 为基本多语言平面,故 前三个字节为 BMP平面</p>
</li>
</ol>
</li>
<li>
<p>举例</p>
<ol>
<li>'我'的 Unicode码 <strong>6211</strong>(十六进制)
<ol>
<li>根据范围占三个字节</li>
<li><code>6211</code>的二进制为 <code>110 001000 010001</code></li>
<li>将'我'二进制代码从低位到高位依次填入x中，不足的填入0
<ol>
<li>UTF-8编码位:  <code>11100110 10001000 10010001</code></li>
<li>UTF-8编码的十六进制为 E6 88 91</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="utf-16"><a class="header" href="#utf-16">UTF-16</a></h3>
<ol>
<li>
<p>UTF-16使用2或4个字节编码</p>
</li>
<li>
<ol>
<li>-若Unicode码点在第一平面（BPM）(0x0000 ~ 0xFFFF)中，则使用2个字节进行编码。</li>
<li>若Unicode码点在其他平面（辅助平面）(0x01 0000~0x10 FFFF)，则使用4个字节进行编码。
<ol>
<li>首先减去 0x01 0000 得到二个字节 最大值为 0x 0F FFFF,共20位有效位数</li>
<li>取高十位 扩充成 二个字节, 高十位的取值 为 D800 ~ DBFF</li>
<li>取低十位 扩充成 二个字节,低十位的取值 为 DC00 ~ DFFF</li>
<li>组合四个字节即为UTF-16编码</li>
</ol>
</li>
<li>识别大端 还是小端 be,le
<ol>
<li>在文件前加入FE FF 采用大端序(大端在前的顺序)</li>
<li>则在文件前加入FF FE 采用小端序(小端在前的顺序)</li>
</ol>
</li>
</ol>
</li>
<li>
<p>举例</p>
<ol>
<li>'我' 字的Unicode码 <strong>6211</strong>(十六进制) 位于基本平面 所以取原值 <code>6211</code>
<ol>
<li>unicode编码 <code>0x01 0001</code></li>
<li>减去01 0000 , 得 0x 0  0001</li>
<li>高字节 :  0 + D800</li>
<li>低字节:   1 + DC00 = DC01</li>
<li>UTF-16得编码为:<code>D800 DC01</code> (大端模式)</li>
<li>小端模式 <code>00D8 01DC</code></li>
</ol>
</li>
</ol>
</li>
<li>
<p>Java String  UniCode采用 UTF16编码</p>
</li>
</ol>
<h3 id="字符编码的区别"><a class="header" href="#字符编码的区别">字符编码的区别</a></h3>
<h4 id="ucs-2-与-utf-16区别"><a class="header" href="#ucs-2-与-utf-16区别">UCS-2 与 UTF-16区别</a></h4>
<p>​		UCS-2采用的两个字节进行编码。在0000到FFFF的码位范围内，它和UTF-16基本一致，为什么说基本一致，因为在UTF-16中从U+D800到U+DFFF的码位不对应于任何字符</p>
<p>　　UCS-2只能表示BMP内的码点（只采用2个字节）</p>
<p>而UTF-16可以表示辅助平面内的码点（采用4个字节）。</p>
<p>　　我们可以抽象的认为UTF-16可看成是UCS-2的父集。在没有辅助平面字符（surrogate code points）前，UTF-16与UCS-2所指的意思基本一致。</p>
<p>但当引入辅助平面字符后，想要表示辅助平面字符时，就只能用UTF-16编码了。</p>
<h4 id="ucs--4与-utf-16的区别"><a class="header" href="#ucs--4与-utf-16的区别">UCS -4与 UTF-16的区别</a></h4>
<p>　　在BMP上，UTF-16采用2个字节表示，而在辅助平面上，UTF-16采用的是4个字节表示。对于UCS-4，不管在哪个平面都采用的是四个字节表示。</p>
<h4 id="为什么utf-8编码不需要bom机制"><a class="header" href="#为什么utf-8编码不需要bom机制">为什么UTF-8编码不需要BOM机制</a></h4>
<p>　　因为在UTF-8编码中，其自身已经带了控制信息，如1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx，其中1110就起到了控制作用，所以不需要额外的BOM机制。</p>
<h3 id="emoji表情的unicode编码"><a class="header" href="#emoji表情的unicode编码"><strong>emoji表情的unicode编码</strong></a></h3>
<p>Unicode只是规定了 emoji 的码位和含义，以及用文字指导它们代表的表情长什么样，并没有规定它的具体样式</p>
<p>渲染的工作则由各个系统自己实现。如果用户的系统没有实现某个emoji表情的渲染，就会显示成一个空方框。</p>
<p>在MAC中，输入ctrl + cmd + 空格后在弹出的面板里添加unicode代码表就可以看见每个unicode码位对应的字符了。</p>
<p>从U+1F300开始，存放的这些小表情就是emoji表情。</p>
<p>​		可以发现简单的笑脸对应的是Unicode的一个码位，但一个蒸馏器对应了两个码位，一个金发男子表情竟然对应了五个码位。我们看到，一个emoji表情也是变长存储的，而且一个表情可占用多个码位组成。那么这些表情的渲染又有什么规则呢？</p>
<p>要解答这个问题，需要阅读unicode官方介绍<a href="https://www.unicode.org/reports/tr51/#Emoji_Properties_and_Data_Files">emoji表情的文档</a></p>
<pre><code>text_presentation_selector := \x{FE0E}
</code></pre>
<p>U+FE0E的含义是，一个text_presentation_selector，大概意思是文本表示选择符。</p>
<pre><code>text_presentation_sequence := emoji_character text_presentation_selector
</code></pre>
<p>这个定义表明，加上了这个U+FE0E修饰的emoji字符会构成一个文本表示序列</p>
<p>所以，这个text_presentation_selector U+FE0E是用来修饰前面的emoji表情,指定其展示方式的。</p>
<pre><code class="language-javascript">emoji_presentation_selector := \x{FE0F}
emoji_presentation_sequence := emoji_character emoji_presentation_selector
</code></pre>
<p>例如这个蒸馏器表情就是由U+FE0F修饰U+2697产生的</p>
<p>由此，我们理解了U+FE0F的作用，相当于一个修饰符，在渲染文字时如果遇到了U+FE0F就和前面的字符组合一下，改成渲染成一个emoji表情的形式</p>
<p>这样就可以理解上面的蒸馏器为什么占用了二个Unicode码位了。本身这个表情就是由其他字符加上修饰符组合而成的。</p>
<pre><code>emoji_modifier := \p{Emoji_Modifier}
emoji_modifier_base := \p{Emoji_Modifier_Base}
emoji_modifier_sequence := emoji_modifier_base emoji_modifier
</code></pre>
<p>在输入法中找到U+1F471号字符</p>
<p>再找到U+1F3FF号字符，单独输出</p>
<p>这次再将两个表情连在一起输出，结果变成了一个</p>
<p>类似还有其他的组合规则，如国旗，键盘等都有各自的组合规则，也是用具有不同属性的unicode字符组合而成。详情可翻阅文档查阅。</p>
<h4 id="zwj"><a class="header" href="#zwj">ZWJ</a></h4>
<p>zero-width joiner，意思是零宽度连字符</p>
<p>占用码位U+200D，这个字符不是为emoji单独服务的</p>
<p>用于插入在某些语言的字符中，使左右的两个字符连在一起产生连字效果，合成单个人类可读的字符。</p>
<p>具体到emoji表情中，某些单个显示表情也会由多个独立的ZWJ连字合成得到。</p>
<p>可以看到，这个红发女子就是由U+1F469和U+1F9B0使用U+200D连字得到的。下面我们来输入看看这两个字符分别代表什么。</p>
<p>红发女子就是由U+1F469和U+1F9B0使用U+200D连字得到的</p>
<p>这表明，U+1F469代表的是一个女子，而U+1F9B0单个表情代表的是头发的颜色，利用U+200D组合到一起，就得到了红发女子这个表情。</p>
<h2 id="参考链接"><a class="header" href="#参考链接">参考链接</a></h2>
<ol>
<li>https://www.qqxiuzi.cn/zh/hanzi-gb2312-bianma.php</li>
<li>https://www.cnblogs.com/leesf456/p/5317574.html</li>
<li>https://www.qqxiuzi.cn/bianma/zifuji.php</li>
<li>https://cloud.tencent.com/developer/article/1680413</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>布隆过滤器可以用于检索一个元素是否在一个集合中</p>
<p>布隆过滤器可以检查值是 <strong>“可能在集合中”</strong> 还是 <strong>“绝对不在集合中”</strong>
$$
P_fp \approx (1-e^-\frac{kn}{m})^k
$$
n是已添加的数量</p>
<p>k是哈希的次数</p>
<p>m是布隆过滤器的长度</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点数的表示"><a class="header" href="#浮点数的表示">浮点数的表示</a></h1>
<ul>
<li>浮点数是一种 <strong>公式化</strong> 的表达方式，用来近似表示实数，并且可以在表达范围和表示精度之间进行权衡（因此被称为浮点数）</li>
</ul>
<pre><code>N=M×RE
</code></pre>
<p>比如： 12.345=1.2345×10112.345=1.2345×101</p>
<p>其中，M(Mantissa)被称为浮点数的 <strong>尾数</strong> ，R(Radix)被称为阶码的 <strong>基数</strong> ，E(Exponent)被称为阶的 <strong>阶码</strong> 。计算机中一般规定R为2、8或16，是一个确定的常数，不需要在浮点数中明确表示出来。</p>
<h1 id="浮点数的规格化表示"><a class="header" href="#浮点数的规格化表示">浮点数的规格化表示</a></h1>
<h2 id="浮点的规格化"><a class="header" href="#浮点的规格化">浮点的规格化</a></h2>
<p>按照上面的指数表示方法，一个浮点数会有不同的表示：</p>
<p>0.3×1000.3×100；0.03×1010.03×101；0.003×1020.003×102；0.0003×1030.0003×103；</p>
<p><strong>为了提高数据的表示精度同时保证数据表示的唯一性，需要对浮点数做规格化处理。</strong></p>
<p>即要求尾数域的最高有效位应为1,称满足这种表示要求的浮点数为规格化表示：把不满足这一表示要求的尾数，变成满足这一要求的尾数的操作过程，叫作浮点数的规格化处理，通过尾数移位和修改阶码实现。</p>
<h2 id="ieee754的规定"><a class="header" href="#ieee754的规定">IEEE754的规定</a></h2>
<ul>
<li>尾数用原码,且隐藏尾数最高位。</li>
</ul>
<p>原码非0值浮点数的尾数数值最高位必定为 1，因此可以忽略掉该位,这样用同样多的位数就能多存一位二进制数，有利于提高数据表示精度，称这种处理方案使用了隐藏位技术。</p>
<ul>
<li><strong>阶码使用“移码”，基固定为2</strong></li>
</ul>
<p><img src="11.algorithm//images/float_component_float.png" alt="" /></p>
<p><img src="11.algorithm//images/float_component_double.png" alt="" /></p>
<p>至此，我们引入IEEE754 标准，该标准约束了浮点数的大部分使用设置：(尾数用原码；阶码用“移码”；基为2)</p>
<ul>
<li>Sign（1bit）：表示浮点数是正数还是负数。0表示正数，1表示负数。</li>
<li>Exponent（8bits）：指数（阶码）部分。类似于科学技术法中的M*10^N中的N，只不过这里是以2为底数而不是10。需要注意的是，这部分中是以2^7-1即127，也即01111111代表2^0，转换时需要根据127作偏移调整。</li>
<li>Mantissa（23bits）：基数部分。浮点数具体数值的实际表示。</li>
</ul>
<h1 id="单精度范围表示"><a class="header" href="#单精度范围表示">单精度范围表示</a></h1>
<p><img src="11.algorithm//images/float_range.jfif" alt="" /></p>
<h1 id="389-用-浮点数表示"><a class="header" href="#389-用-浮点数表示">3.89 用 浮点数表示</a></h1>
<p>$$
转化为二进制为\
0.89 \approx
1/(1&lt;&lt;1) +1/(1&lt;&lt;2) + 1/(1&lt;&lt;3) + \
1/(1&lt;&lt;7) + 1/(1&lt;&lt;8) + 1/(1&lt;&lt;9) + 1/(1&lt;&lt;10) +\
1/(1&lt;&lt;12) + 1/(1&lt;&lt;14) + 1/(1&lt;&lt;15) + 1/(1&lt;&lt;16) +\
1/(1&lt;&lt;21) + 1/(1&lt;&lt;22)\
(3.89)<em>{10} \approx (11.1110 0011 1101 0111 0000 11)</em>{2}\
浮点表示（一般对指数部分+127，便于浮点之间比较计算）\
0\qquad 10000000\qquad 11110001111010111000011\
浮点十六进制表示\
0100\quad 0000\quad 0111\quad 1000\quad 1111\quad 0101\quad 1100\quad 0011\
0x4078F5C3
$$</p>
<h1 id="c语言验证代码"><a class="header" href="#c语言验证代码">C语言验证代码</a></h1>
<pre><code class="language-C">int main(int argc, char const *argv[])
{
    float f = 3.89f; 
    printf(&quot;%#x\n&quot;,*(int *)&amp;f);
    return 0;
}
</code></pre>
<h1 id="浮点数-最大值"><a class="header" href="#浮点数-最大值">浮点数 最大值</a></h1>
<ul>
<li>浮点值定义 <code>float.h</code></li>
</ul>
<p><code>#define FLT_MAX         3.402823466e+38F        /* max value */</code>
$$
最大值\
(0\quad1111\ 1110\quad 1111\ 1111\ 1111\ 1111\ 1111\ 111 \)<em>{2}\
(0X7F7F\ FFFF)</em>{16}\
Infinity值，无限值 (当阶码全为1时)，符号位为1则是负无穷，符号位0则是正无穷\
(0\quad1111\ 1111\quad 1111\ 1111\ 1111\ 1111\ 1111\ 111 \)<em>{2}\
(0X7FFF\ FFFF)</em>{16}\
$$</p>
<h1 id="浮点数的表示精度"><a class="header" href="#浮点数的表示精度"><strong>浮点数的表示精度</strong></a></h1>
<p>一般提到浮点数的精度（有效位数）的时候，总是会出现 <strong>float的有效位为6~7位, double的有效位为15~16位</strong> 。</p>
<p><img src="11.algorithm//images/float_range_specific.jfif" alt="" /></p>
<p><strong>由上面的表格可以看出：</strong></p>
<p>2−232−23 和 2−222−22 之间是存在间隔的，即0.0000001和0.0000002之间的小数我们是没有办法描述的，因此23位尾数最多只能描述到小数点后第7位；此外，我们通过四舍五入可以很容易发现0.0000003=0.0000004=2−23+2−220.0000003=0.0000004=2−23+2−22, 这表明第7位有效数字只是部分准确。而第6位及之前的都是可以准确描述的，因此我们说<strong>float的有效位为6~7位。</strong></p>
<p><a href="https://www.toutiao.com/i6752086508737413643/">参考文档</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍-3"><a class="header" href="#介绍-3">介绍</a></h1>
<ul>
<li>红黑树是一种自平衡二进制搜索树，其中每个节点都有一个额外的位，该位通常被解释为颜色（红色或黑色）。
这些颜色用于确保在插入和删除过程中树保持平衡。</li>
<li>尽管树的平衡不是完美的，但足以减少搜索时间并将其维持在O（log n）时间左右，其中n是树中元素的总数。
这棵树是鲁道夫·拜耳（Rudolf Bayer）于1972年发明的。</li>
<li>必须注意的是，由于每个节点仅需要1位空间来存储颜色信息</li>
</ul>
<h1 id="红黑树规则"><a class="header" href="#红黑树规则">红黑树规则</a></h1>
<ol>
<li>结点有颜色，不是红色就是黑色</li>
<li>根节点 是 黑色的</li>
<li>没有两个邻接的红结点</li>
<li>从节点（包括根）到其任何后代NULL节点的每条路径都具有相同数量的黑色节点。</li>
</ol>
<h4 id="why-red-black-trees"><a class="header" href="#why-red-black-trees"><strong>Why Red-Black Trees?</strong></a></h4>
<ul>
<li>大多数BST（二叉搜索树）操作(e.g., search, max, min, insert, delete.. etc)  都的时间复杂度是  O(h) ，h是 BST的高度</li>
<li>一颗斜的二叉树 的 上述操作可能花费 O(n)的时间</li>
<li>红黑树能够保证 上述操作 的时间复杂度 始终小于 <em>O(log n)</em></li>
</ul>
<h1 id="与avl树相比"><a class="header" href="#与avl树相比">与AVL树相比</a></h1>
<ul>
<li>与红黑树相比，AVL树更加平衡，但是它们可能会在插入和删除过程中引起更多旋转。</li>
<li>因此，如果您的应用程序涉及频繁的插入和删除操作，则应首选红黑树。</li>
<li>如果插入和删除操作的频率较低，而搜索操作的频率较高，则AVL树应优先于Red-Black树。</li>
</ul>
<h1 id="红黑树如何保持平衡"><a class="header" href="#红黑树如何保持平衡">红黑树如何保持平衡</a></h1>
<p><strong>关于红黑树的有趣之处</strong>：</p>
<ul>
<li>
<p>红黑树的黑色高度是从根节点到叶节点的路径上的黑色节点数，叶子节点也被视为黑色节点</p>
</li>
<li>
<p>所以 高度为h的红黑树的黑色高度&gt; = h / 2</p>
</li>
<li>
<p>具有n个节点的红黑树的高度为  <code>h &lt;= 2 log2（n + 1）</code>。</p>
</li>
<li>
<p>所有NULL结点 算 黑色</p>
</li>
<li>
<p>节点的黑色深度定义为从根到该节点的黑色节点的数量，即黑色祖先的数量。</p>
</li>
<li>
<p>每棵红黑树都是二叉树的特例。</p>
</li>
</ul>
<blockquote>
<p>从一个节点到其最远的后代叶的节点数不超过到最近的后代叶的节点数的两倍。</p>
</blockquote>
<h1 id="红黑树插入"><a class="header" href="#红黑树插入">红黑树插入</a></h1>
<ul>
<li>设插入的结点为 当前结点</li>
<li><strong>当前结点的parent为 黑色 或者 当前结点为root结点 则 跳过</strong></li>
<li>当 插入结点的 parent为红色 则需要 重新平衡
<ul>
<li>当 <em>uncle</em>也为 红色  则 将 <em>uncle</em> 与 <em>parent</em> 均变为黑色，将 <em>grand_parent</em> 变为 红色， 这样所有路径 <strong>黑色结点个数</strong> 不变</li>
<li>当uncle为黑色，<strong>核心原则就是</strong> <strong>在不增加黑色结点的情况下 将红结点转移到 <em>uncle</em> 上去</strong> 解决办法：通过旋转将黑色结点下沉</li>
</ul>
</li>
</ul>
<p><strong>LEFT LEFT</strong></p>
<p><img src="11.algorithm/../../images/redBlackCase_left_left.png" alt="" /></p>
<p><strong>简单证明</strong>:</p>
<pre><code>装换前已知： g-&gt;T1的黑高度 = g-&gt;T2的黑高度 = g-&gt;T3的黑高度 = g-&gt;u的黑高度
转换后 
	x是 红黑树
	由 g到 T3的黑高 = g到 u的黑高 故
	由 x,g都是红节点 故 p也满足 红黑树性质
</code></pre>
<p><strong>LEFT RIGHT</strong></p>
<p><img src="11.algorithm/../../images/redBlackCase_left_right.png" alt="" /></p>
<p><strong>RIGHT RIGHT</strong></p>
<p><img src="11.algorithm/../../images/redBlackCase_right_right.png" alt="" /></p>
<p><strong>RIGHT LEFT</strong></p>
<p><img src="11.algorithm/../../images/redBlackCase_right_left.png" alt="" /></p>
<pre><code class="language-cpp">void RBTree::fixViolation(Node *&amp;root, Node *&amp;pt)
{
    Node *parent_pt = nullptr;
    Node *grand_parent_pt = nullptr;

    // 当 目标结点 不为根节点，且存在 连续的两个红节点才需要处理
    while ((pt != root) &amp;&amp; (pt-&gt;color != BLACK) &amp;&amp;
           (pt-&gt;parent-&gt;color == RED))
    {

        //取 parent,grand_parent
        parent_pt = pt-&gt;parent;
        grand_parent_pt = pt-&gt;parent-&gt;parent;

        /*  Case : A 
            Parent of pt is left child  
            of Grand-parent of pt */
        if (parent_pt == grand_parent_pt-&gt;left)
        {

            Node *uncle_pt = grand_parent_pt-&gt;right;

            /* Case : 1 
               The uncle of pt is also red 
               Only Recoloring required */
            if (uncle_pt != nullptr &amp;&amp; uncle_pt-&gt;color == RED)
            {
                grand_parent_pt-&gt;color = RED;
                parent_pt-&gt;color = BLACK;
                uncle_pt-&gt;color = BLACK;
                pt = grand_parent_pt;
            }

            else
            {
                /* Case : 2 
                   pt is right child of its parent 
                   Left-rotation required */
                if (pt == parent_pt-&gt;right)
                {
                    rotateLeft(root, parent_pt);
                    pt = parent_pt;
                    parent_pt = pt-&gt;parent;
                }

                /* Case : 3 
                   pt is left child of its parent 
                   Right-rotation required */
                rotateRight(root, grand_parent_pt);

                //swap(parent_pt-&gt;color,grand_parent_pt-&gt;color);
                auto color = parent_pt-&gt;color;
                parent_pt-&gt;color = grand_parent_pt-&gt;color;
                grand_parent_pt-&gt;color = color;
                pt = parent_pt;
            }
        }

        /* Case : B 
           Parent of pt is right child  
           of Grand-parent of pt */
        else
        {
            Node *uncle_pt = grand_parent_pt-&gt;left;

            /*  Case : 1 
                The uncle of pt is also red 
                Only Recoloring required */
            if ((uncle_pt != NULL) &amp;&amp; (uncle_pt-&gt;color ==
                                       RED))
            {
                grand_parent_pt-&gt;color = RED;
                parent_pt-&gt;color = BLACK;
                uncle_pt-&gt;color = BLACK;
                pt = grand_parent_pt;
            }
            else
            {
                /* Case : 2 
                   pt is left child of its parent 
                   Right-rotation required */
                if (pt == parent_pt-&gt;left)
                {
                    rotateRight(root, parent_pt);
                    pt = parent_pt;
                    parent_pt = pt-&gt;parent;
                }

                /* Case : 3 
                   pt is right child of its parent 
                   Left-rotation required */
                rotateLeft(root, grand_parent_pt);

                //swap(parent_pt-&gt;color,grand_parent_pt-&gt;color);
                auto color = parent_pt-&gt;color;
                parent_pt-&gt;color = grand_parent_pt-&gt;color;
                grand_parent_pt-&gt;color = color;

                pt = parent_pt;
            }
        }
    }

    root-&gt;color = BLACK;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基本概念-1"><a class="header" href="#基本概念-1">基本概念</a></h1>
<ul>
<li>从局部最优解出发,得出全局最优解</li>
<li>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）</li>
<li><strong>对所采用的贪心策略一定要仔细分析其是否满足无后效性</strong></li>
</ul>
<h1 id="贪心算法适用场景"><a class="header" href="#贪心算法适用场景">贪心算法适用场景</a></h1>
<ul>
<li><strong>局部最优策略能导致产生全局最优解。</strong></li>
<li><strong>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解</strong></li>
<li>贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。</li>
<li>贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。</li>
</ul>
<h1 id="例题分析"><a class="header" href="#例题分析">例题分析</a></h1>
<pre><code>有一个背包，容量是M=150，有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。
 物品：A     B    C    D E F G
 重量：35  30 60 50 40 10 25
 价值：10 40 30 50 35 40 30
</code></pre>
<p>分析：目标函数： ∑pi最大</p>
<p>约束:  装入的物品总质量不超过背包容量：∑wi&lt;=M( M=150)</p>
<p>（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？不能
（2）每次挑选所占重量最小的物品装入是否能得到最优解？ 不能
（3）每次选取单位重量价值最大的物品，且遇见单位价值相同的时候,优先装重量小的  成为解本题的策略</p>
<p><strong>代码实现</strong></p>
<p>​	</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="简介-7"><a class="header" href="#简介-7">简介</a></h2>
<p>逆波兰表达式又叫做<a href="https://baike.baidu.com/item/%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/6160580">后缀表达式</a>。逆波兰表示法是波兰<a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%AD%A6%E5%AE%B6/1240880">逻辑学家</a>J・卢卡西维兹(J・ Lukasiewicz)于1929年首先提出的一种表达式的表示方法 [1] 。后来,人们就把用这种表示法写出的表达式称作“逆波兰表达式”。逆波兰表达式把运算量写在前面,把算符写在后面。</p>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>逻辑提问式类似于算术表达式，对于检索而言，这种表达式并不是最优和最简洁的形式，需要进行必要的转换。1929年波兰的逻辑学家卢卡西维兹(Jan Lucasiewicz)提出了将运算符放在运算项后面的逻辑表达式，又称“逆波兰表达式”。采用这种表达式组织逻辑提问式非常方便检索运算，是日本的福岛先生最早将逆波兰表达式应用于情报检索的，故又称为“福岛方法”。 [2] </p>
<p>逆波兰表达式又叫做后缀表达式，是一种没有括号，并严格遵循“从左到右”运算的后缀式表达方法，如下表所示：</p>
<table><thead><tr><th>正常的表达式</th><th>逆波兰表达式</th></tr></thead><tbody>
<tr><td>a+b</td><td>a,b,+</td></tr>
<tr><td>a+(b-c)</td><td>a,b,c,-,+</td></tr>
<tr><td>a+(b-c)*d</td><td>a,d,b,c,-,*,+</td></tr>
<tr><td>a*(b+c)+d</td><td>a,b,c,+,*,d,+</td></tr>
</tbody></table>
<h2 id="逆波兰表达式的转化"><a class="header" href="#逆波兰表达式的转化">逆波兰表达式的转化</a></h2>
<h3 id="一般算法"><a class="header" href="#一般算法">一般算法</a></h3>
<p>将一个普通的中序表达式转换为逆序表达式的一般算法是</p>
<ol>
<li>构造一个运算符栈</li>
<li>此运算符在栈内遵循越往栈顶优先级越高的原则</li>
<li>读入一个用中缀表达式的简单算术表达式</li>
<li>从左至右 扫描该算术表达式 从第一个字符开始判断 如果是 操作数则直接 输出。
<ol>
<li>如果是操作符，则需要比较
<ol>
<li>如果该操作符优先级关系 高于此栈顶操作符 则 将该操作符入栈	</li>
<li>若低于栈顶操作符 从栈顶中弹出，直到栈顶操作符 的优先级关系 低于当前运算符</li>
<li>然后将该运算符入栈</li>
</ol>
</li>
</ol>
</li>
<li>重复3,4 步骤</li>
</ol>
<h3 id="算术运算表达式的"><a class="header" href="#算术运算表达式的">算术运算表达式的</a></h3>
<pre><code>#include &lt;stack&gt;
class Solution {
public:
    int evalRPN(vector&lt;string&gt; &amp;tokens) {
        int i=0;
        stack&lt;int&gt; s;
        int ret=0;
        while(i&lt;tokens.size()){
            while(i&lt;tokens.size() &amp;&amp; tokens[i]!=&quot;+&quot; &amp;&amp; tokens[i]!=&quot;-&quot; &amp;&amp; tokens[i]!=&quot;*&quot; &amp;&amp; tokens[i]!=&quot;/&quot;)
                s.push(atoi(tokens[i++].c_str()));
            int right_num=s.top();
            s.pop();
            if(s.empty())
                return right_num;
            int left_num=s.top();
            s.pop();
            if(tokens[i]==&quot;+&quot;)
                ret=left_num+right_num;
            else if(tokens[i]==&quot;-&quot;)
                ret=left_num-right_num;
            else if(tokens[i]==&quot;*&quot;)
                ret=left_num*right_num;       
            else if(tokens[i]==&quot;/&quot;)
                ret=left_num/right_num;
            s.push(ret);
            i++;
        }
        return s.top();
    }
};
</code></pre>
<h3 id="bool表达式"><a class="header" href="#bool表达式">Bool表达式</a></h3>
<pre><code>
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
